// Code generated by go2go; DO NOT EDIT.


//line io_test.go2:5
package genericio

//line io_test.go2:5
import (
//line io_test.go2:5
 "bytes"
//line io_test.go2:5
 "crypto/sha1"
//line io_test.go2:5
 "errors"
//line io_test.go2:5
 "fmt"
//line io_test.go2:5
 "io"
//line io_test.go2:5
 "io/ioutil"
//line io_test.go2:5
 "runtime"
//line io_test.go2:5
 "sort"
//line io_test.go2:5
 "strings"
//line io_test.go2:5
 "sync"
//line io_test.go2:5
 "testing"
//line io_test.go2:5
 "time"
//line io_test.go2:5
)

//line io_test.go2:17
type Buffer struct {
	bytes.Buffer
	io.ReaderFrom
	io.WriterTo
}

//line io_test.go2:25
func TestCopy(t *testing.T) {
			rb := new(Buffer)
			wb := new(Buffer)
			rb.Buffer.WriteString("hello, world.")
//line io_test.go2:28
 instantiate୦୦Copy୦byte(wb, rb)
//line io_test.go2:30
 if wb.Buffer.String() != "hello, world." {
		t.Errorf("Copy did not work properly")
	}
}

func TestCopyNegative(t *testing.T) {
			rb := new(Buffer)
			wb := new(Buffer)
			rb.Buffer.WriteString("hello")
//line io_test.go2:38
 instantiate୦୦Copy୦byte(wb, &instantiate୦୦LimitedReader୦byte{R: rb, N: -1})
//line io_test.go2:40
 if wb.Buffer.String() != "" {
		t.Errorf("Copy on LimitedReader with N<0 copied data")
	}
//line io_test.go2:42
 instantiate୦୦CopyN୦byte(wb, rb, -1)
//line io_test.go2:45
 if wb.Buffer.String() != "" {
		t.Errorf("CopyN with N<0 copied data")
	}
}

func TestCopyBuffer(t *testing.T) {
			rb := new(Buffer)
			wb := new(Buffer)
			rb.Buffer.WriteString("hello, world.")
//line io_test.go2:53
 instantiate୦୦CopyBuffer୦byte(wb, rb, make([]byte, 1))
//line io_test.go2:55
 if wb.Buffer.String() != "hello, world." {
		t.Errorf("CopyBuffer did not work properly")
	}
}

func TestCopyBufferNil(t *testing.T) {
			rb := new(Buffer)
			wb := new(Buffer)
			rb.Buffer.WriteString("hello, world.")
//line io_test.go2:63
 instantiate୦୦CopyBuffer୦byte(wb, rb, nil)
//line io_test.go2:65
 if wb.Buffer.String() != "hello, world." {
		t.Errorf("CopyBuffer did not work properly")
	}
}

func TestCopyReadFrom(t *testing.T) {
			rb := new(Buffer)
			wb := new(bytes.Buffer)
			rb.Buffer.WriteString("hello, world.")
//line io_test.go2:73
 instantiate୦୦Copy୦byte(wb, rb)
//line io_test.go2:75
 if wb.String() != "hello, world." {
		t.Errorf("Copy did not work properly")
	}
}

func TestCopyWriteTo(t *testing.T) {
			rb := new(bytes.Buffer)
			wb := new(Buffer)
			rb.WriteString("hello, world.")
//line io_test.go2:83
 instantiate୦୦Copy୦byte(wb, rb)
//line io_test.go2:85
 if wb.Buffer.String() != "hello, world." {
		t.Errorf("Copy did not work properly")
	}
}

//line io_test.go2:91
type writeToChecker struct {
	bytes.Buffer
	writeToCalled bool
}

func (wt *writeToChecker) WriteTo(w instantiate୦୦Writer୦byte,) (int64, error) {
	wt.writeToCalled = true
	return wt.Buffer.WriteTo(w)
}

//line io_test.go2:104
func TestCopyPriority(t *testing.T) {
			rb := new(writeToChecker)
			wb := new(bytes.Buffer)
			rb.Buffer.WriteString("hello, world.")
//line io_test.go2:107
 instantiate୦୦Copy୦byte(wb, rb)
//line io_test.go2:109
 if wb.String() != "hello, world." {
		t.Errorf("Copy did not work properly")
	} else if !rb.writeToCalled {
		t.Errorf("WriteTo was not prioritized over ReadFrom")
	}
}

type zeroErrReader struct {
	err error
}

func (r zeroErrReader) Read(p []byte) (int, error) {
	return copy(p, []byte{0}), r.err
}

type errWriter struct {
	err error
}

func (w errWriter) Write([]byte) (int, error) {
	return 0, w.err
}

//line io_test.go2:135
func TestCopyReadErrWriteErr(t *testing.T) {
	er, ew := errors.New("readError"), errors.New("writeError")
	r, w := zeroErrReader{err: er}, errWriter{err: ew}
	n, err := instantiate୦୦Copy୦byte(w, r)
	if n != 0 || err != ew {
		t.Errorf("Copy(zeroErrReader, errWriter) = %d, %v; want 0, writeError", n, err)
	}
}

func TestCopyN(t *testing.T) {
			rb := new(Buffer)
			wb := new(Buffer)
			rb.Buffer.WriteString("hello, world.")
//line io_test.go2:147
 instantiate୦୦CopyN୦byte(wb, rb, 5)
//line io_test.go2:149
 if wb.Buffer.String() != "hello" {
		t.Errorf("CopyN did not work properly")
	}
}

func TestCopyNReadFrom(t *testing.T) {
			rb := new(Buffer)
			wb := new(bytes.Buffer)
			rb.Buffer.WriteString("hello")
//line io_test.go2:157
 instantiate୦୦CopyN୦byte(wb, rb, 5)
//line io_test.go2:159
 if wb.String() != "hello" {
		t.Errorf("CopyN did not work properly")
	}
}

func TestCopyNWriteTo(t *testing.T) {
			rb := new(bytes.Buffer)
			wb := new(Buffer)
			rb.WriteString("hello, world.")
//line io_test.go2:167
 instantiate୦୦CopyN୦byte(wb, rb, 5)
//line io_test.go2:169
 if wb.Buffer.String() != "hello" {
		t.Errorf("CopyN did not work properly")
	}
}

func BenchmarkCopyNSmall(b *testing.B) {
	bs := bytes.Repeat([]byte{0}, 512+1)
	rd := bytes.NewReader(bs)
	buf := new(Buffer)
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
//line io_test.go2:180
  instantiate୦୦CopyN୦byte(buf, rd, 512)
//line io_test.go2:182
  rd.Reset(bs)
	}
}

func BenchmarkCopyNLarge(b *testing.B) {
	bs := bytes.Repeat([]byte{0}, (32*1024)+1)
	rd := bytes.NewReader(bs)
	buf := new(Buffer)
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
//line io_test.go2:192
  instantiate୦୦CopyN୦byte(buf, rd, 32*1024)
//line io_test.go2:194
  rd.Reset(bs)
	}
}

type noReadFrom struct {
	w instantiate୦୦Writer୦byte
}

func (w *noReadFrom) Write(p []byte) (n int, err error) {
	return w.w.Write(p)
}

type wantedAndErrReader struct{}

func (wantedAndErrReader) Read(p []byte) (int, error) {
	return len(p), errors.New("wantedAndErrReader error")
}

func TestCopyNEOF(t *testing.T) {

//line io_test.go2:216
 b := new(bytes.Buffer)

	n, err := instantiate୦୦CopyN୦byte(&noReadFrom{b}, strings.NewReader("foo"), 3)
	if n != 3 || err != nil {
		t.Errorf("CopyN(noReadFrom, foo, 3) = %d, %v; want 3, nil", n, err)
	}

	n, err = instantiate୦୦CopyN୦byte(&noReadFrom{b}, strings.NewReader("foo"), 4)
	if n != 3 || err != EOF {
		t.Errorf("CopyN(noReadFrom, foo, 4) = %d, %v; want 3, EOF", n, err)
	}

	n, err = instantiate୦୦CopyN୦byte(b, strings.NewReader("foo"), 3)
	if n != 3 || err != nil {
		t.Errorf("CopyN(bytes.Buffer, foo, 3) = %d, %v; want 3, nil", n, err)
	}

	n, err = instantiate୦୦CopyN୦byte(b, strings.NewReader("foo"), 4)
	if n != 3 || err != EOF {
		t.Errorf("CopyN(bytes.Buffer, foo, 4) = %d, %v; want 3, EOF", n, err)
	}

	n, err = instantiate୦୦CopyN୦byte(b, wantedAndErrReader{}, 5)
	if n != 5 || err != nil {
		t.Errorf("CopyN(bytes.Buffer, wantedAndErrReader, 5) = %d, %v; want 5, nil", n, err)
	}

	n, err = instantiate୦୦CopyN୦byte(&noReadFrom{b}, wantedAndErrReader{}, 5)
	if n != 5 || err != nil {
		t.Errorf("CopyN(noReadFrom, wantedAndErrReader, 5) = %d, %v; want 5, nil", n, err)
	}
}

func TestReadAtLeast(t *testing.T) {
	var rb bytes.Buffer
	testReadAtLeast(t, &rb)
}

//line io_test.go2:256
type dataAndErrorBuffer struct {
	err error
	bytes.Buffer
}

func (r *dataAndErrorBuffer) Read(p []byte) (n int, err error) {
	n, err = r.Buffer.Read(p)
	if n > 0 && r.Buffer.Len() == 0 && err == nil {
		err = r.err
	}
	return
}

func TestReadAtLeastWithDataAndEOF(t *testing.T) {
	var rb dataAndErrorBuffer
	rb.err = EOF
	testReadAtLeast(t, &rb)
}

func TestReadAtLeastWithDataAndError(t *testing.T) {
	var rb dataAndErrorBuffer
	rb.err = fmt.Errorf("fake error")
	testReadAtLeast(t, &rb)
}

func testReadAtLeast(t *testing.T, rb instantiate୦୦ReadWriter୦byte,) {
	rb.Write([]byte("0123"))
	buf := make([]byte, 2)
	n, err := instantiate୦୦ReadAtLeast୦byte(rb, buf, 2)
	if err != nil {
		t.Error(err)
	}
	if n != 2 {
		t.Errorf("expected to have read 2 bytes, got %v", n)
	}
	n, err = instantiate୦୦ReadAtLeast୦byte(rb, buf, 4)
	if err != ErrShortBuffer {
		t.Errorf("expected ErrShortBuffer got %v", err)
	}
	if n != 0 {
		t.Errorf("expected to have read 0 bytes, got %v", n)
	}
	n, err = instantiate୦୦ReadAtLeast୦byte(rb, buf, 1)
	if err != nil {
		t.Error(err)
	}
	if n != 2 {
		t.Errorf("expected to have read 2 bytes, got %v", n)
	}
	n, err = instantiate୦୦ReadAtLeast୦byte(rb, buf, 2)
	if err != EOF {
		t.Errorf("expected EOF, got %v", err)
	}
	if n != 0 {
		t.Errorf("expected to have read 0 bytes, got %v", n)
	}
	rb.Write([]byte("4"))
	n, err = instantiate୦୦ReadAtLeast୦byte(rb, buf, 2)
	want := ErrUnexpectedEOF
	if rb, ok := rb.(*dataAndErrorBuffer); ok && rb.err != EOF {
		want = rb.err
	}
	if err != want {
		t.Errorf("expected %v, got %v", want, err)
	}
	if n != 1 {
		t.Errorf("expected to have read 1 bytes, got %v", n)
	}
}

func TestTeeReader(t *testing.T) {
	src := []byte("hello, world")
	dst := make([]byte, len(src))
	rb := bytes.NewBuffer(src)
	wb := new(bytes.Buffer)
	r := instantiate୦୦TeeReader୦byte(rb, wb)
	if n, err := instantiate୦୦ReadFull୦byte(r, dst); err != nil || n != len(src) {
		t.Fatalf("ReadFull(r, dst) = %d, %v; want %d, nil", n, err, len(src))
	}
	if !bytes.Equal(dst, src) {
		t.Errorf("bytes read = %q want %q", dst, src)
	}
	if !bytes.Equal(wb.Bytes(), src) {
		t.Errorf("bytes written = %q want %q", wb.Bytes(), src)
	}
	if n, err := r.Read(dst); n != 0 || err != EOF {
		t.Errorf("r.Read at EOF = %d, %v want 0, EOF", n, err)
	}
	rb = bytes.NewBuffer(src)
	pr, pw := instantiate୦୦Pipe୦byte()
	pr.Close()
	r = instantiate୦୦TeeReader୦byte(rb, pw)
	if n, err := instantiate୦୦ReadFull୦byte(r, dst); n != 0 || err != ErrClosedPipe {
		t.Errorf("closed tee: ReadFull(r, dst) = %d, %v; want 0, EPIPE", n, err)
	}
}

func TestSectionReader_ReadAt(t *testing.T) {
	dat := "a long sample data, 1234567890"
	tests := []struct {
		data   string
		off    int
		n      int
		bufLen int
		at     int
		exp    string
		err    error
	}{
		{data: "", off: 0, n: 10, bufLen: 2, at: 0, exp: "", err: EOF},
		{data: dat, off: 0, n: len(dat), bufLen: 0, at: 0, exp: "", err: nil},
		{data: dat, off: len(dat), n: 1, bufLen: 1, at: 0, exp: "", err: EOF},
		{data: dat, off: 0, n: len(dat) + 2, bufLen: len(dat), at: 0, exp: dat, err: nil},
		{data: dat, off: 0, n: len(dat), bufLen: len(dat) / 2, at: 0, exp: dat[:len(dat)/2], err: nil},
		{data: dat, off: 0, n: len(dat), bufLen: len(dat), at: 0, exp: dat, err: nil},
		{data: dat, off: 0, n: len(dat), bufLen: len(dat) / 2, at: 2, exp: dat[2 : 2+len(dat)/2], err: nil},
		{data: dat, off: 3, n: len(dat), bufLen: len(dat) / 2, at: 2, exp: dat[5 : 5+len(dat)/2], err: nil},
		{data: dat, off: 3, n: len(dat) / 2, bufLen: len(dat)/2 - 2, at: 2, exp: dat[5 : 5+len(dat)/2-2], err: nil},
		{data: dat, off: 3, n: len(dat) / 2, bufLen: len(dat)/2 + 2, at: 2, exp: dat[5 : 5+len(dat)/2-2], err: EOF},
		{data: dat, off: 0, n: 0, bufLen: 0, at: -1, exp: "", err: EOF},
		{data: dat, off: 0, n: 0, bufLen: 0, at: 1, exp: "", err: EOF},
	}
	for i, tt := range tests {
		r := strings.NewReader(tt.data)
		s := instantiate୦୦NewSectionReader୦byte(r, int64(tt.off), int64(tt.n))
		buf := make([]byte, tt.bufLen)
		if n, err := s.ReadAt(buf, int64(tt.at)); n != len(tt.exp) || string(buf[:n]) != tt.exp || err != tt.err {
			t.Fatalf("%d: ReadAt(%d) = %q, %v; expected %q, %v", i, tt.at, buf[:n], err, tt.exp, tt.err)
		}
	}
}

func TestSectionReader_Seek(t *testing.T) {

	br := bytes.NewReader([]byte("foo"))
	sr := instantiate୦୦NewSectionReader୦byte(br, 0, int64(len("foo")))

	for _, whence := range []int{SeekStart, SeekCurrent, SeekEnd} {
		for offset := int64(-3); offset <= 4; offset++ {
			brOff, brErr := br.Seek(offset, whence)
			srOff, srErr := sr.Seek(offset, whence)
			if (brErr != nil) != (srErr != nil) || brOff != srOff {
				t.Errorf("For whence %d, offset %d: bytes.Reader.Seek = (%v, %v) != SectionReader.Seek = (%v, %v)",
					whence, offset, brOff, brErr, srErr, srOff)
			}
		}
	}

//line io_test.go2:404
 got, err := sr.Seek(100, SeekStart)
	if err != nil || got != 100 {
		t.Errorf("Seek = %v, %v; want 100, nil", got, err)
	}

	n, err := sr.Read(make([]byte, 10))
	if n != 0 || err != EOF {
		t.Errorf("Read = %v, %v; want 0, EOF", n, err)
	}
}

func TestSectionReader_Size(t *testing.T) {
	tests := []struct {
		data string
		want int64
	}{
		{"a long sample data, 1234567890", 30},
		{"", 0},
	}

	for _, tt := range tests {
		r := strings.NewReader(tt.data)
		sr := instantiate୦୦NewSectionReader୦byte(r, 0, int64(len(tt.data)))
		if got := sr.Size(); got != tt.want {
			t.Errorf("Size = %v; want %v", got, tt.want)
		}
	}
}
//line io.go2:332
func instantiate୦୦Copy୦byte(dst instantiate୦୦Writer୦byte, src instantiate୦୦Reader୦byte,) (written int64, err error) {
	return instantiate୦୦copyBuffer୦byte(dst, src, nil)
}

//line io.go2:334
type instantiate୦୦LimitedReader୦byte struct {
//line io.go2:409
 R instantiate୦୦Reader୦byte
	N int64
}

func (l *instantiate୦୦LimitedReader୦byte,) Read(p []byte,

//line io.go2:413
) (n int, err error) {
	if l.N <= 0 {
		return 0, EOF
	}
	if int64(len(p)) > l.N {
		p = p[0:l.N]
	}
	n, err = l.R.Read(p)
	l.N -= int64(n)
	return
}
//line io.go2:308
func instantiate୦୦CopyN୦byte(dst instantiate୦୦Writer୦byte, src instantiate୦୦Reader୦byte, n int64) (written int64, err error) {
	written, err = instantiate୦୦Copy୦byte(dst, instantiate୦୦LimitReader୦byte(src, n))
	if written == n {
		return n, nil
	}
	if written < n && err == nil {

		err = EOF
	}
	return
}

//line io.go2:343
func instantiate୦୦CopyBuffer୦byte(dst instantiate୦୦Writer୦byte, src instantiate୦୦Reader୦byte, buf []byte,

//line io.go2:343
) (written int64, err error) {
	if buf != nil && len(buf) == 0 {
		panic("empty buffer in io.CopyBuffer")
	}
	return instantiate୦୦copyBuffer୦byte(dst, src, buf)
}

//line io.go2:348
type instantiate୦୦Writer୦byte interface {
//line io.go2:92
 Write(p []byte) (n int, err error)
}
//line io.go2:93
type instantiate୦୦ReadWriter୦byte interface {
//line io.go2:121
 instantiate୦୦Reader୦byte
//line io.go2:121
 instantiate୦୦Writer୦byte
//line io.go2:124
}

//line io.go2:273
func instantiate୦୦ReadAtLeast୦byte(r instantiate୦୦Reader୦byte, buf []byte, min int) (n int, err error) {
	if len(buf) < min {
		return 0, ErrShortBuffer
	}
	for n < min && err == nil {
		var nn int
		nn, err = r.Read(buf[n:])
		n += nn
	}
	if n >= min {
		err = nil
	} else if n > 0 && err == EOF {
		err = ErrUnexpectedEOF
	}
	return
}

//line io.go2:497
func instantiate୦୦TeeReader୦byte(r instantiate୦୦Reader୦byte, w instantiate୦୦Writer୦byte,) instantiate୦୦Reader୦byte {
	return &instantiate୦୦teeReader୦byte{r, w}
}
//line io.go2:297
func instantiate୦୦ReadFull୦byte(r instantiate୦୦Reader୦byte, buf []byte) (n int, err error) {
	return instantiate୦୦ReadAtLeast୦byte(r, buf, len(buf))
}
//line pipe.go2:197
func instantiate୦୦Pipe୦byte() (*instantiate୦୦PipeReader୦byte, *instantiate୦୦PipeWriter୦byte,) {
	p := &instantiate୦୦pipe୦byte{
		wrCh: make(chan []byte),
		rdCh: make(chan int),
		done: make(chan struct{}),
	}
	return &instantiate୦୦PipeReader୦byte{p}, &instantiate୦୦PipeWriter୦byte{p}
}

//line io.go2:427
func instantiate୦୦NewSectionReader୦byte(r instantiate୦୦ReaderAt୦byte, off int64, n int64) *instantiate୦୦SectionReader୦byte {
	return &instantiate୦୦SectionReader୦byte{r, off, off, off + n}
}

//line io.go2:429
type instantiate୦୦Reader୦byte interface {
//line io.go2:79
 Read(p []byte,

//line io.go2:79
 ) (n int, err error)
}

//line io.go2:352
func instantiate୦୦copyBuffer୦byte(dst instantiate୦୦Writer୦byte, src instantiate୦୦Reader୦byte, buf []byte,) (written int64, err error) {

//line io.go2:355
 if wt, ok := src.(instantiate୦୦WriterTo୦byte); ok {
		return wt.WriteTo(dst)
	}

	if rt, ok := dst.(instantiate୦୦ReaderFrom୦byte); ok {
		return rt.ReadFrom(src)
	}
	if buf == nil {
		size := 32 * 1024
		if l, ok := src.(*instantiate୦୦LimitedReader୦byte); ok && int64(size) > l.N {
			if l.N < 1 {
				size = 1
			} else {
				size = int(l.N)
			}
		}
		buf = make([]byte, size)
	}
	for {
		nr, er := src.Read(buf)
		if nr > 0 {
			nw, ew := dst.Write(buf[0:nr])
			if nw > 0 {
				written += int64(nw)
			}
			if ew != nil {
				err = ew
				break
			}
			if nr != nw {
				err = ErrShortWrite
				break
			}
		}
		if er != nil {
			if er != EOF {
				err = er
			}
			break
		}
	}
	return written, err
}

//line io.go2:402
func instantiate୦୦LimitReader୦byte(r instantiate୦୦Reader୦byte, n int64) instantiate୦୦Reader୦byte {
//line io.go2:402
 return &instantiate୦୦LimitedReader୦byte{r, n}
//line io.go2:402
}

//line io.go2:402
type instantiate୦୦teeReader୦byte struct {
//line io.go2:502
 r instantiate୦୦Reader୦byte
	w instantiate୦୦Writer୦byte
}

func (t *instantiate୦୦teeReader୦byte,) Read(p []byte,

//line io.go2:506
) (n int, err error) {
	n, err = t.r.Read(p)
	if n > 0 {
		if n, err := t.w.Write(p[:n]); err != nil {
			return n, err
		}
	}
	return
}

//line io.go2:514
type instantiate୦୦PipeReader୦byte struct {
//line pipe.go2:125
 p *instantiate୦୦pipe୦byte
}

//line pipe.go2:133
func (r *instantiate୦୦PipeReader୦byte,) Read(data []byte) (n int, err error) {
	return r.p.Read(data)
}

//line pipe.go2:139
func (r *instantiate୦୦PipeReader୦byte,) Close() error {
	return r.CloseWithError(nil)
}

//line pipe.go2:148
func (r *instantiate୦୦PipeReader୦byte,) CloseWithError(err error) error {
	return r.p.CloseRead(err)
}

//line pipe.go2:150
type instantiate୦୦PipeWriter୦byte struct {
//line pipe.go2:154
 p *instantiate୦୦pipe୦byte
}

//line pipe.go2:162
func (w *instantiate୦୦PipeWriter୦byte,) Write(data []byte) (n int, err error) {
	return w.p.Write(data)
}

//line pipe.go2:168
func (w *instantiate୦୦PipeWriter୦byte,) Close() error {
	return w.CloseWithError(nil)
}

//line pipe.go2:178
func (w *instantiate୦୦PipeWriter୦byte,) CloseWithError(err error) error {
	return w.p.CloseWrite(err)
}

//line pipe.go2:180
type instantiate୦୦pipe୦byte struct {
//line pipe.go2:40
 wrMu sync.Mutex
			wrCh chan []byte
			rdCh chan int

			once sync.Once
			done chan struct{}
			rerr onceError
			werr onceError
}

func (p *instantiate୦୦pipe୦byte,) Read(b []byte) (n int, err error) {
	select {
	case <-p.done:
		return 0, p.readCloseError()
	default:
	}

	select {
	case bw := <-p.wrCh:
		nr := copy(b, bw)
		p.rdCh <- nr
		return nr, nil
	case <-p.done:
		return 0, p.readCloseError()
	}
}

func (p *instantiate୦୦pipe୦byte,) readCloseError() error {
	rerr := p.rerr.Load()
	if werr := p.werr.Load(); rerr == nil && werr != nil {
		return werr
	}
	return ErrClosedPipe
}

func (p *instantiate୦୦pipe୦byte,) CloseRead(err error) error {
	if err == nil {
		err = ErrClosedPipe
	}
	p.rerr.Store(err)
	p.once.Do(func() { close(p.done) })
	return nil
}

func (p *instantiate୦୦pipe୦byte,) Write(b []byte) (n int, err error) {
	select {
	case <-p.done:
		return 0, p.writeCloseError()
	default:
		p.wrMu.Lock()
		defer p.wrMu.Unlock()
	}

	for once := true; once || len(b) > 0; once = false {
		select {
		case p.wrCh <- b:
			nw := <-p.rdCh
			b = b[nw:]
			n += nw
		case <-p.done:
			return n, p.writeCloseError()
		}
	}
	return n, nil
}

func (p *instantiate୦୦pipe୦byte,) writeCloseError() error {
	werr := p.werr.Load()
	if rerr := p.rerr.Load(); werr == nil && rerr != nil {
		return rerr
	}
	return ErrClosedPipe
}

func (p *instantiate୦୦pipe୦byte,) CloseWrite(err error) error {
	if err == nil {
		err = EOF
	}
	p.werr.Store(err)
	p.once.Do(func() { close(p.done) })
	return nil
}

//line pipe.go2:121
type instantiate୦୦ReaderAt୦byte interface {
//line io.go2:213
 ReadAt(p []byte, off int64) (n int, err error)
}
//line io.go2:214
type instantiate୦୦SectionReader୦byte struct {
//line io.go2:434
 r instantiate୦୦ReaderAt୦byte
	base  int64
	off   int64
	limit int64
}

func (s *instantiate୦୦SectionReader୦byte,) Read(p []byte,

//line io.go2:440
) (n int, err error) {
	if s.off >= s.limit {
		return 0, EOF
	}
	if max := s.limit - s.off; int64(len(p)) > max {
		p = p[0:max]
	}
	n, err = s.r.ReadAt(p, s.off)
	s.off += int64(n)
	return
}

//line io.go2:455
func (s *instantiate୦୦SectionReader୦byte,) Seek(offset int64, whence int) (int64, error) {
	switch whence {
	default:
		return 0, errWhence
	case SeekStart:
		offset += s.base
	case SeekCurrent:
		offset += s.off
	case SeekEnd:
		offset += s.limit
	}
	if offset < s.base {
		return 0, errOffset
	}
	s.off = offset
	return offset - s.base, nil
}

func (s *instantiate୦୦SectionReader୦byte,) ReadAt(p []byte,

//line io.go2:473
 off int64) (n int, err error) {
	if off < 0 || off >= s.limit-s.base {
		return 0, EOF
	}
	off += s.base
	if max := s.limit - off; int64(len(p)) > max {
		p = p[0:max]
		n, err = s.r.ReadAt(p, off)
		if err == nil {
			err = EOF
		}
		return n, err
	}
	return s.r.ReadAt(p, off)
}

//line io.go2:490
func (s *instantiate୦୦SectionReader୦byte,) Size() int64 { return s.limit - s.base }

//line io.go2:490
type instantiate୦୦WriterTo୦byte interface {
//line io.go2:183
 WriteTo(w instantiate୦୦Writer୦byte,) (n int64, err error)
}
//line io.go2:184
type instantiate୦୦ReaderFrom୦byte interface {
//line io.go2:172
 ReadFrom(r instantiate୦୦Reader୦byte,) (n int64, err error)
}
//line io.go2:173
type _ bytes.Buffer

//line io.go2:173
const _ = sha1.BlockSize

//line io.go2:173
var _ = errors.As
//line io.go2:173
var _ = fmt.Errorf

//line io.go2:173
type _ io.ByteReader

//line io.go2:173
var _ = ioutil.Discard
//line io.go2:173
var _ = runtime.BlockProfile

//line io.go2:173
type _ sort.Float64Slice
//line io.go2:173
type _ strings.Builder
//line io.go2:173
type _ sync.Cond

//line io.go2:173
var _ = testing.AllocsPerRun

//line io.go2:173
const _ = time.ANSIC
