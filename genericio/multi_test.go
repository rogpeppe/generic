// Code generated by go2go; DO NOT EDIT.


//line multi_test.go2:5
package genericio

//line multi_test.go2:5
import (
//line multi_test.go2:5
 "bytes"
//line multi_test.go2:5
 "crypto/sha1"
//line multi_test.go2:5
 "errors"
//line multi_test.go2:5
 "fmt"
//line multi_test.go2:5
 "io"
//line multi_test.go2:5
 "io/ioutil"
//line multi_test.go2:5
 "runtime"
//line multi_test.go2:5
 "sort"
//line multi_test.go2:5
 "strings"
//line multi_test.go2:5
 "sync"
//line multi_test.go2:5
 "testing"
//line multi_test.go2:5
 "time"
//line multi_test.go2:5
)

//line multi_test.go2:19
func TestMultiReader(t *testing.T) {
	var mr instantiate୦୦Reader୦byte
	var buf []byte
	nread := 0
	withFooBar := func(tests func()) {
		r1 := strings.NewReader("foo ")
		r2 := strings.NewReader("")
		r3 := strings.NewReader("bar")
		mr = instantiate୦୦MultiReader୦byte(r1, r2, r3)
		buf = make([]byte, 20)
		tests()
	}
	expectRead := func(size int, expected string, eerr error) {
		nread++
		n, gerr := mr.Read(buf[0:size])
		if n != len(expected) {
			t.Errorf("#%d, expected %d bytes; got %d",
				nread, len(expected), n)
		}
		got := string(buf[0:n])
		if got != expected {
			t.Errorf("#%d, expected %q; got %q",
				nread, expected, got)
		}
		if gerr != eerr {
			t.Errorf("#%d, expected error %v; got %v",
				nread, eerr, gerr)
		}
		buf = buf[n:]
	}
	withFooBar(func() {
		expectRead(2, "fo", nil)
		expectRead(5, "o ", nil)
		expectRead(5, "bar", nil)
		expectRead(5, "", EOF)
	})
	withFooBar(func() {
		expectRead(4, "foo ", nil)
		expectRead(1, "b", nil)
		expectRead(3, "ar", nil)
		expectRead(1, "", EOF)
	})
	withFooBar(func() {
		expectRead(5, "foo ", nil)
	})
}

func TestMultiWriter(t *testing.T) {
	sink := new(bytes.Buffer)

	testMultiWriter(t, struct {
//line multi_test.go2:69
  instantiate୦୦Writer୦byte

					fmt.Stringer
	}{sink, sink})
}

func TestMultiWriter_String(t *testing.T) {
	testMultiWriter(t, new(bytes.Buffer))
}

func testMultiWriter(t *testing.T, sink interface {
//line multi_test.go2:79
 instantiate୦୦Writer୦byte

				fmt.Stringer
}) {
	sha1 := sha1.New()
	mw := instantiate୦୦MultiWriter୦byte(sha1, sink)

	sourceString := "My input text."
	source := strings.NewReader(sourceString)
	written, err := instantiate୦୦Copy୦byte(mw, source)

	if written != int64(len(sourceString)) {
		t.Errorf("short write of %d, not %d", written, len(sourceString))
	}

	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}

	sha1hex := fmt.Sprintf("%x", sha1.Sum(nil))
	if sha1hex != "01cb303fa8c30a64123067c5aa6284ba7ec2d31b" {
		t.Error("incorrect sha1 value")
	}

	if sink.String() != sourceString {
		t.Errorf("expected %q; got %q", sourceString, sink.String())
	}
}

//line multi_test.go2:109
type writerFunc func(p []byte) (int, error)

func (f writerFunc) Write(p []byte) (int, error) {
	return f(p)
}

//line multi_test.go2:116
func TestMultiWriterSingleChainFlatten(t *testing.T) {
	pc := make([]uintptr, 1000)
	n := runtime.Callers(0, pc)
	var myDepth = callDepth(pc[:n])
	var writeDepth int
	var w instantiate୦୦Writer୦byte = instantiate୦୦MultiWriter୦byte(writerFunc(func(p []byte) (int, error) {
		n := runtime.Callers(1, pc)
		writeDepth += callDepth(pc[:n])
		return 0, nil
	}))

	mw := w

	for i := 0; i < 100; i++ {
		mw = instantiate୦୦MultiWriter୦byte(w)
	}

	mw = instantiate୦୦MultiWriter୦byte(w, mw, w, mw)
	mw.Write(nil)

	if writeDepth != 4*(myDepth+2) {
		t.Errorf("multiWriter did not flatten chained multiWriters: expected writeDepth %d, got %d",
			4*(myDepth+2), writeDepth)
	}
}

func TestMultiWriterError(t *testing.T) {
	f1 := writerFunc(func(p []byte) (int, error) {
		return len(p) / 2, ErrShortWrite
	})
	f2 := writerFunc(func(p []byte) (int, error) {
		t.Errorf("MultiWriter called f2.Write")
		return len(p), nil
	})
	w := instantiate୦୦MultiWriter୦byte(f1, f2)
	n, err := w.Write(make([]byte, 100))
	if n != 50 || err != ErrShortWrite {
		t.Errorf("Write = %d, %v, want 50, ErrShortWrite", n, err)
	}
}

//line multi_test.go2:158
func TestMultiReaderCopy(t *testing.T) {
	slice := []instantiate୦୦Reader୦byte{strings.NewReader("hello world")}
	r := instantiate୦୦MultiReader୦byte(slice...)
	slice[0] = nil
	data, err := ioutil.ReadAll(r)
	if err != nil || string(data) != "hello world" {
		t.Errorf("ReadAll() = %q, %v, want %q, nil", data, err, "hello world")
	}
}

//line multi_test.go2:169
func TestMultiWriterCopy(t *testing.T) {
	var buf bytes.Buffer
	slice := []instantiate୦୦Writer୦byte{&buf}
	w := instantiate୦୦MultiWriter୦byte(slice...)
	slice[0] = nil
	n, err := w.Write([]byte("hello world"))
	if err != nil || n != 11 {
		t.Errorf("Write(`hello world`) = %d, %v, want 11, nil", n, err)
	}
	if buf.String() != "hello world" {
		t.Errorf("buf.String() = %q, want %q", buf.String(), "hello world")
	}
}

//line multi_test.go2:184
type readerFunc func(p []byte) (int, error)

func (f readerFunc) Read(p []byte) (int, error) {
	return f(p)
}

//line multi_test.go2:191
func callDepth(callers []uintptr) (depth int) {
	frames := runtime.CallersFrames(callers)
	more := true
	for more {
		_, more = frames.Next()
		depth++
	}
	return
}

//line multi_test.go2:202
func TestMultiReaderFlatten(t *testing.T) {
	pc := make([]uintptr, 1000)
	n := runtime.Callers(0, pc)
	var myDepth = callDepth(pc[:n])
	var readDepth int
	var r instantiate୦୦Reader୦byte = instantiate୦୦MultiReader୦byte(readerFunc(func(p []byte) (int, error) {
		n := runtime.Callers(1, pc)
		readDepth = callDepth(pc[:n])
		return 0, errors.New("irrelevant")
	}))

//line multi_test.go2:214
 for i := 0; i < 100; i++ {
		r = instantiate୦୦MultiReader୦byte(r)
	}

	r.Read(nil)

	if readDepth != myDepth+2 {
		t.Errorf("multiReader did not flatten chained multiReaders: expected readDepth %d, got %d",
			myDepth+2, readDepth)
	}
}

//line multi_test.go2:228
type byteAndEOFReader byte

func (b byteAndEOFReader) Read(p []byte) (n int, err error) {
	if len(p) == 0 {

//line multi_test.go2:234
  panic("unexpected call")
	}
	p[0] = byte(b)
	return 1, EOF
}

//line multi_test.go2:241
func TestMultiReaderSingleByteWithEOF(t *testing.T) {
	got, err := ioutil.ReadAll(instantiate୦୦LimitReader୦byte(instantiate୦୦MultiReader୦byte(byteAndEOFReader('a'), byteAndEOFReader('b')), 10))
	if err != nil {
		t.Fatal(err)
	}
	const want = "ab"
	if string(got) != want {
		t.Errorf("got %q; want %q", got, want)
	}
}

//line multi_test.go2:255
func TestMultiReaderFinalEOF(t *testing.T) {
	r := instantiate୦୦MultiReader୦byte(bytes.NewReader(nil), byteAndEOFReader('a'))
	buf := make([]byte, 2)
	n, err := r.Read(buf)
	if n != 1 || err != EOF {
		t.Errorf("got %v, %v; want 1, EOF", n, err)
	}
}

func TestMultiReaderFreesExhaustedReaders(t *testing.T) {
				var mr instantiate୦୦Reader୦byte
				closed := make(chan struct{})

//line multi_test.go2:270
 func() {
		buf1 := bytes.NewReader([]byte("foo"))
		buf2 := bytes.NewReader([]byte("bar"))
		mr = instantiate୦୦MultiReader୦byte(buf1, buf2)
		runtime.SetFinalizer(buf1, func(*bytes.Reader) {
			close(closed)
		})
	}()

	buf := make([]byte, 4)
	if n, err := instantiate୦୦ReadFull୦byte(mr, buf); err != nil || string(buf) != "foob" {
		t.Fatalf(`ReadFull = %d (%q), %v; want 3, "foo", nil`, n, buf[:n], err)
	}

	runtime.GC()
	select {
	case <-closed:
	case <-time.After(5 * time.Second):
		t.Fatal("timeout waiting for collection of buf1")
	}

	if n, err := instantiate୦୦ReadFull୦byte(mr, buf[:2]); err != nil || string(buf[:2]) != "ar" {
		t.Fatalf(`ReadFull = %d (%q), %v; want 2, "ar", nil`, n, buf[:n], err)
	}
}

func TestInterleavedMultiReader(t *testing.T) {
				r1 := strings.NewReader("123")
				r2 := strings.NewReader("45678")

				mr1 := instantiate୦୦MultiReader୦byte(r1, r2)
				mr2 := instantiate୦୦MultiReader୦byte(mr1)

				buf := make([]byte, 4)

//line multi_test.go2:307
 n, err := instantiate୦୦ReadFull୦byte(mr2, buf)
	if got := string(buf[:n]); got != "1234" || err != nil {
		t.Errorf(`ReadFull(mr2) = (%q, %v), want ("1234", nil)`, got, err)
	}

//line multi_test.go2:314
 n, err = instantiate୦୦ReadFull୦byte(mr1, buf)
	if got := string(buf[:n]); got != "5678" || err != nil {
		t.Errorf(`ReadFull(mr1) = (%q, %v), want ("5678", nil)`, got, err)
	}
}
//line multi.go2:48
func instantiate୦୦MultiReader୦byte(readers ...instantiate୦୦Reader୦byte,) instantiate୦୦Reader୦byte {
	r := make([]instantiate୦୦Reader୦byte, len(readers))
	copy(r, readers)
	return &instantiate୦୦multiReader୦byte{r}
}

//line multi.go2:78
func instantiate୦୦MultiWriter୦byte(writers ...instantiate୦୦Writer୦byte,) instantiate୦୦Writer୦byte {
	allWriters := make([]instantiate୦୦Writer୦byte, 0, len(writers))
	for _, w := range writers {
		if mw, ok := w.(*instantiate୦୦multiWriter୦byte); ok {
			allWriters = append(allWriters, mw.writers...)
		} else {
			allWriters = append(allWriters, w)
		}
	}
	return &instantiate୦୦multiWriter୦byte{allWriters}
}

//line multi.go2:88
type instantiate୦୦multiReader୦byte struct {
//line multi.go2:14
 readers []instantiate୦୦Reader୦byte
}

func (mr *instantiate୦୦multiReader୦byte,) Read(p []byte) (n int, err error) {
	for len(mr.readers) > 0 {

		if len(mr.readers) == 1 {
			if r, ok := mr.readers[0].(*instantiate୦୦multiReader୦byte); ok {
				mr.readers = r.readers
				continue
			}
		}
		n, err = mr.readers[0].Read(p)
		if err == EOF {

//line multi.go2:30
   mr.readers[0] = instantiate୦୦eofReader୦byte{}
			mr.readers = mr.readers[1:]
		}
		if n > 0 || err != EOF {
			if err == EOF && len(mr.readers) > 0 {

				err = nil
			}
			return
		}
	}
	return 0, EOF
}

//line multi.go2:42
type instantiate୦୦multiWriter୦byte struct {
//line multi.go2:55
 writers []instantiate୦୦Writer୦byte
}

func (t *instantiate୦୦multiWriter୦byte,) Write(p []byte) (n int, err error) {
	for _, w := range t.writers {
		n, err = w.Write(p)
		if err != nil {
			return
		}
		if n != len(p) {
			err = ErrShortWrite
			return
		}
	}
	return len(p), nil
}

//line multi.go2:70
type instantiate୦୦eofReader୦byte struct{}

//line multi.go2:9
func (instantiate୦୦eofReader୦byte,) Read([]byte) (int, error) {
	return 0, EOF
}

//line multi.go2:11
type _ bytes.Buffer

//line multi.go2:11
const _ = sha1.BlockSize

//line multi.go2:11
var _ = errors.As
//line multi.go2:11
var _ = fmt.Errorf

//line multi.go2:11
type _ io.ByteReader

//line multi.go2:11
var _ = ioutil.Discard
//line multi.go2:11
var _ = runtime.BlockProfile

//line multi.go2:11
type _ sort.Float64Slice
//line multi.go2:11
type _ strings.Builder
//line multi.go2:11
type _ sync.Cond

//line multi.go2:11
var _ = testing.AllocsPerRun

//line multi.go2:11
const _ = time.ANSIC
