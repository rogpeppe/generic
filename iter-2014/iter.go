// An example package using Go-as-if-it-had-parametric-polymorphism,
// with an "iter" package in the standard library, following an
// already idiomatic Go iteration pattern.
//
// The feature is entirely imaginary, but I've tried to write
// the code to fit as much within Go's existing idioms as possible.
//
// Generics questions that this code does not attempt to resolve:
//	- What semantics are there for equality of values
//	with parametric types?
//	- what happens if you convert a value with parametric type
//	to an interface?
//
// Points given for pointing out syntax errors, logical inconsistencies
// or language-feature implementation roadtraps.
package main

import (
	"bufio"
	"fmt"
	"io"
	"log"
	"strings"
	"sync"
)

func main() {
	r := strings.NewReader("light blue\nfaded khaki\n")
	iter0 := BufioScanner(bufio.NewScanner(r))
	iter1 := NewSlice([]string{"one", "two"})
	both := Sequence(iter0, iter1)
	prefixed := Map(both, nil, func(s string) string {
		return "x: " + s
	})
	foo, err := Gather(prefixed)
	if err != nil {
		log.Fatal(err)
	}
	// foo is []string{"x: light blue", "x: faded khaki", "x: one", "x: two"}
	fmt.Printf("%v\n", foo)
}

///////////////////////////////////////////////////////////

// The iter package implements a general iterator interface type, Iter,
// and some functions that operate on values of that type.
// package iter

// Iter represents an iterable collection of values.
type Iter[T any] interface {
	// Next advances the iterator to the next value, which will then
	// be available through Value method. It returns
	// false when the iteration stops, either by reaching the end
	// or an error. After Scan returns false, the Err method
	// will return any error that occurred during iteration..
	Next() bool

	// Value returns the most recent value generated by a call to Next.
	// It may be called any number of times between calls to Next.
	// If called after Next has returned false, it returns the zero value.
	Value() T

	// Err returns the first error encountered.
	Err() error

	// Close closes the iterator and frees any associated resources.
	Close() error
}

// Gather iterates through all the items in iter
// and returns them as a slice.
func Gather[T any](iter Iter[T]) ([]T, error) {
	var slice []T
	for iter.Next() {
		slice = append(slice, iter.Value())
	}
	return slice, iter.Err()
}

// Identity is the identity function for
// a given type.
func Identity[T any](t T) T {
	return t
}

// Pair holds two arbitrarily typed values
type Pair[A, B any] struct {
	A A
	B B
}

// Zip returns an iterator that returns all the items
// in a and b in pairs. If one iterator returns more
// values than the other, the other part of the
// pair will contain the zero value.
func Zip[A, B any](a Iter[A], b Iter[B]) Iter[Pair[A, B]] {
	return &zipper[A, B]{
		a: a,
		b: b,
	}
}

type zipper[A, B any] struct {
	err error
	a   Iter[A]
	b   Iter[B]
}

func (z *zipper[A, B]) Next() bool {
	aok, bok := z.a.Next(), z.b.Next()
	return aok || bok
}

func (z *zipper[A, B]) Err() error {
	if z.err != nil {
		return z.err
	}
	if err := z.a.Err(); err != nil {
		z.err = err
	} else if err := z.b.Err(); err != nil {
		z.err = err
	}
	return z.err
}

func (z *zipper[A, B]) Value() Pair[A, B] {
	return Pair[A, B]{
		A: z.a.Value(),
		B: z.b.Value(),
	}
}

func (z *zipper[A, B]) Close() error {
	err1 := z.a.Close()
	err2 := z.b.Close()
	if err1 == nil {
		err1 = err2
	}
	return err1
}

func CloseAll[C io.Closer](xs []C) {
	for _, x := range xs {
		x.Close()
	}
}

// Map returns an iterator that produces
// a value f(x) for every value in the given iterator.
// Any non-nil error returned from the underlying iterator
// will be transformed by the given err function.
func Map[S, T any](
	iter Iter[S],
	transformError func(error) error,
	f func(S) T,
) Iter[T] {
	if transformError == nil {
		transformError = Identity[error]
	}
	m := &mapping[S, T]{
		f:              f,
		transformError: transformError,
	}
	// Can't put this in the struct literal because of https://github.com/golang/go/issues/44345
	m.Iter = iter
	return m
}

// mapping implements the iterator returned by Map.
// Note the embedding of a type name with
// a parametric type parameter.
// When checking for interface type compatibility,
// methods must be compatible. So if S==T
// then mapping will automatically
// implement Iter[S] but not Iter[T].
// It will implement interface {
//	Next() bool
//	Close() error
//	Err() error
// }
type mapping[S, T any] struct {
	Iter[S]
	f              func(S) T
	transformError func(error) error
}

func (m *mapping[S, T]) Value() T {
	return m.f(m.Iter.Value())
}

func (m *mapping[S, T]) Err() error {
	return m.transformError(m.Iter.Err())
}

func BufioScanner(r *bufio.Scanner) Iter[string] {
	return bufioScanner{r}
}

type bufioScanner struct {
	r *bufio.Scanner
}

func (b bufioScanner) Next() bool {
	return b.r.Scan()
}

func (b bufioScanner) Err() error {
	return b.r.Err()
}

func (b bufioScanner) Value() string {
	return b.r.Text()
}

func (b bufioScanner) Close() error {
	return nil
}

type slice[T any] struct {
	first  bool
	values []T
}

// Slice implements Iter on a slice.
// The values are traversed from beginning to end.
func NewSlice[T any](values []T) Iter[T] {
	return &slice[T]{
		first:  true,
		values: values,
	}
}

func (s *slice[T]) Next() bool {
	if s.first {
		s.first = false
	} else {
		s.values = s.values[1:]
	}
	return len(s.values) > 0
}

func (s *slice[T]) Err() error {
	return nil
}

func (s *slice[T]) Close() error {
	return nil
}

func (s *slice[T]) Value() T {
	return s.values[0]
}

// Sequence returns an iterator that iterates
// through each of the given iterators in turn.
// The first error will terminate any remaining
// iterators. All are closed in turn when or before
// the returned iterator is closed.
//
func Sequence[T any](iters ...Iter[T]) Iter[T] {
	return &sequence[T]{
		iters: iters,
	}
}

type sequence[T any] struct {
	iters []Iter[T]
	err   error
}

func (s *sequence[T]) Next() bool {
	for len(s.iters) > 0 {
		iter := s.iters[0]
		if iter.Next() {
			return true
		}
		if err := iter.Err(); err != nil {
			s.err = err
			s.Close()
			s.iters = nil
			return false
		}
		s.iters = s.iters[1:]
	}
	return false
}

func (s *sequence[T]) Err() error {
	if s.err != nil {
		return s.err
	}
	if len(s.iters) > 0 {
		s.err = s.iters[0].Err()
		return s.err
	}
	return nil
}

func (s *sequence[T]) Value() T {
	if len(s.iters) == 0 {
		return *new(T)
	}
	return s.iters[0].Value()
}

func (s *sequence[T]) Close() error {
	var closeErr error
	for len(s.iters) > 0 {
		if err := s.iters[0].Close(); err != nil && closeErr == nil {
			closeErr = err
		}
		s.iters = s.iters[1:]
	}
	return closeErr
}

// Concurrent returns a channel reading the
// results of al the given iterators running
// concurrently.
func Concurrent[T any](iters ...Iter[T]) chan T {
	c := make(chan T)
	go func() {
		var wg sync.WaitGroup
		for _, iter := range iters {
			iter := iter
			go func() {
				defer wg.Done()
				defer iter.Close()
				for iter.Next() {
					c <- iter.Value()
				}
			}()
		}
		wg.Wait()
		close(c)
	}()
	return c
}
