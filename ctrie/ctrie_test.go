// Code generated by go2go; DO NOT EDIT.


//line ctrie_test.go2:17
package ctrie

//line ctrie_test.go2:17
import (
//line ctrie_test.go2:17
 "bytes"
//line ctrie_test.go2:17
 "fmt"
//line ctrie_test.go2:17
 "github.com/rogpeppe/generic/gatomic"
//line ctrie_test.go2:17
 "hash/maphash"
//line ctrie_test.go2:17
 "math/bits"
//line ctrie_test.go2:17
 "strconv"
//line ctrie_test.go2:17
 "sync"
//line ctrie_test.go2:17
 "sync/atomic"
//line ctrie_test.go2:17
 "testing"
//line ctrie_test.go2:17
 "time"
//line ctrie_test.go2:17
 "unsafe"
//line ctrie_test.go2:17
)

//line ctrie_test.go2:29
func TestCtrie(t *testing.T) {
				ctrie := instantiate୦୦NewWithFuncs୦୮6୮7byte୦string(bytes.Equal, BytesHash)

				_, ok := ctrie.Get([]byte("foo"))
				assertFalse(t, ok)

				ctrie.Set([]byte("foo"), "bar")
				val, ok := ctrie.Get([]byte("foo"))
				assertTrue(t, ok)
//line ctrie_test.go2:37
 instantiate୦୦assertEqual୦string(t, "bar", val)

//line ctrie_test.go2:40
 ctrie.Set([]byte("fooooo"), "baz")
				val, ok = ctrie.Get([]byte("foo"))
				assertTrue(t, ok)
//line ctrie_test.go2:42
 instantiate୦୦assertEqual୦string(t, "bar", val)
//line ctrie_test.go2:44
 val, ok = ctrie.Get([]byte("fooooo"))
				assertTrue(t, ok)
//line ctrie_test.go2:45
 instantiate୦୦assertEqual୦string(t, "baz", val)

//line ctrie_test.go2:48
 for i := 0; i < 100; i++ {
		ctrie.Set([]byte(strconv.Itoa(i)), "blah")
	}
	for i := 0; i < 100; i++ {
					val, ok = ctrie.Get([]byte(strconv.Itoa(i)))
					assertTrue(t, ok)
//line ctrie_test.go2:53
  instantiate୦୦assertEqual୦string(t, "blah", val)
//line ctrie_test.go2:55
 }

				val, ok = ctrie.Get([]byte("foo"))
				assertTrue(t, ok)
//line ctrie_test.go2:58
 instantiate୦୦assertEqual୦string(t, "bar", val)
//line ctrie_test.go2:60
 ctrie.Set([]byte("foo"), "qux")
				val, ok = ctrie.Get([]byte("foo"))
				assertTrue(t, ok)
//line ctrie_test.go2:62
 instantiate୦୦assertEqual୦string(t, "qux", val)

//line ctrie_test.go2:65
 val, ok = ctrie.Delete([]byte("foo"))
				assertTrue(t, ok)
//line ctrie_test.go2:66
 instantiate୦୦assertEqual୦string(t, "qux", val)

//line ctrie_test.go2:69
 _, ok = ctrie.Delete([]byte("foo"))
				assertFalse(t, ok)

				val, ok = ctrie.Delete([]byte("fooooo"))
				assertTrue(t, ok)
//line ctrie_test.go2:73
 instantiate୦୦assertEqual୦string(t, "baz", val)

//line ctrie_test.go2:76
 for i := 0; i < 100; i++ {
		ctrie.Delete([]byte(strconv.Itoa(i)))
	}
}

func TestSetLNode(t *testing.T) {
	ctrie := instantiate୦୦NewWithFuncs୦୮6୮7byte୦int(bytes.Equal, func([]byte) uint64 { return 0 })

	for i := 0; i < 10; i++ {
		ctrie.Set([]byte(strconv.Itoa(i)), i)
	}

	for i := 0; i < 10; i++ {
					val, ok := ctrie.Get([]byte(strconv.Itoa(i)))
					assertTrue(t, ok)
//line ctrie_test.go2:90
  instantiate୦୦assertEqual୦int(t, i, val)
//line ctrie_test.go2:92
 }
	_, ok := ctrie.Get([]byte("11"))
	assertFalse(t, ok)

	for i := 0; i < 10; i++ {
					val, ok := ctrie.Delete([]byte(strconv.Itoa(i)))
					assertTrue(t, ok)
//line ctrie_test.go2:98
  instantiate୦୦assertEqual୦int(t, i, val)
//line ctrie_test.go2:100
 }
}

func TestSetTNode(t *testing.T) {
	ctrie := instantiate୦୦NewWithFuncs୦୮6୮7byte୦int(bytes.Equal, BytesHash)

	for i := 0; i < 10000; i++ {
		ctrie.Set([]byte(strconv.Itoa(i)), i)
	}

	for i := 0; i < 5000; i++ {
		ctrie.Delete([]byte(strconv.Itoa(i)))
	}

	for i := 0; i < 10000; i++ {
		ctrie.Set([]byte(strconv.Itoa(i)), i)
	}

	for i := 0; i < 10000; i++ {
					val, ok := ctrie.Get([]byte(strconv.Itoa(i)))
					assertTrue(t, ok)
//line ctrie_test.go2:120
  instantiate୦୦assertEqual୦int(t, i, val)
//line ctrie_test.go2:122
 }
}

func TestConcurrency(t *testing.T) {
	ctrie := instantiate୦୦NewWithFuncs୦୮6୮7byte୦int(bytes.Equal, BytesHash)
	var wg sync.WaitGroup
	wg.Add(2)

	go func() {
		for i := 0; i < 10000; i++ {
			ctrie.Set([]byte(strconv.Itoa(i)), i)
		}
		wg.Done()
	}()

	go func() {
		for i := 0; i < 10000; i++ {
			val, ok := ctrie.Get([]byte(strconv.Itoa(i)))
			if ok {
//line ctrie_test.go2:140
    instantiate୦୦assertEqual୦int(t, i, val)
//line ctrie_test.go2:142
   }
		}
		wg.Done()
	}()

	for i := 0; i < 10000; i++ {
		time.Sleep(5)
		ctrie.Delete([]byte(strconv.Itoa(i)))
	}

	wg.Wait()
}

func TestConcurrency2(t *testing.T) {
	ctrie := instantiate୦୦NewWithFuncs୦୮6୮7byte୦int(bytes.Equal, BytesHash)
	var wg sync.WaitGroup
	wg.Add(4)

	go func() {
		for i := 0; i < 10000; i++ {
			ctrie.Set([]byte(strconv.Itoa(i)), i)
		}
		wg.Done()
	}()

	go func() {
		for i := 0; i < 10000; i++ {
			val, ok := ctrie.Get([]byte(strconv.Itoa(i)))
			if ok {
//line ctrie_test.go2:170
    instantiate୦୦assertEqual୦int(t, i, val)
//line ctrie_test.go2:172
   }
		}
		wg.Done()
	}()

	go func() {
		for i := 0; i < 10000; i++ {
			ctrie.Clone()
		}
		wg.Done()
	}()

	go func() {
		for i := 0; i < 10000; i++ {
			ctrie.RClone()
		}
		wg.Done()
	}()

				wg.Wait()
//line ctrie_test.go2:191
 instantiate୦୦assertEqual୦int(t, 10000, ctrie.Len())
//line ctrie_test.go2:193
}

func TestClone(t *testing.T) {
	ctrie := instantiate୦୦NewWithFuncs୦୮6୮7byte୦interface୮4୮5(bytes.Equal, BytesHash)
	for i := 0; i < 100; i++ {
		ctrie.Set([]byte(strconv.Itoa(i)), i)
	}

				snapshot := ctrie.Clone()

//line ctrie_test.go2:204
 for i := 0; i < 100; i++ {
					val, ok := snapshot.Get([]byte(strconv.Itoa(i)))
					assertTrue(t, ok)
//line ctrie_test.go2:206
  instantiate୦୦assertEqual୦interface୮4୮5(t, interface{}(i), val)
//line ctrie_test.go2:208
 }

//line ctrie_test.go2:211
 for i := 0; i < 100; i++ {
		ctrie.Delete([]byte(strconv.Itoa(i)))
	}

//line ctrie_test.go2:216
 for i := 0; i < 100; i++ {
					val, ok := snapshot.Get([]byte(strconv.Itoa(i)))
					assertTrue(t, ok)
//line ctrie_test.go2:218
  instantiate୦୦assertEqual୦interface୮4୮5(t, interface{}(i), val)
//line ctrie_test.go2:220
 }

//line ctrie_test.go2:223
 ctrie = instantiate୦୦NewWithFuncs୦୮6୮7byte୦interface୮4୮5(nil, nil)
	for i := 0; i < 100; i++ {
		ctrie.Set([]byte(strconv.Itoa(i)), i)
	}
				snapshot = ctrie.Clone()

//line ctrie_test.go2:230
 for i := 0; i < 100; i++ {
		snapshot.Delete([]byte(strconv.Itoa(i)))
	}
	snapshot.Set([]byte("bat"), "man")

	for i := 0; i < 100; i++ {
		_, ok := snapshot.Get([]byte(strconv.Itoa(i)))
		assertFalse(t, ok)
	}
				val, ok := snapshot.Get([]byte("bat"))
				assertTrue(t, ok)
//line ctrie_test.go2:240
 instantiate୦୦assertEqual୦interface୮4୮5(t, "man", val)

//line ctrie_test.go2:244
 for i := 0; i < 100; i++ {
					val, ok := ctrie.Get([]byte(strconv.Itoa(i)))
					assertTrue(t, ok)
//line ctrie_test.go2:246
  instantiate୦୦assertEqual୦interface୮4୮5(t, interface{}(i), val)
//line ctrie_test.go2:248
 }
				_, ok = ctrie.Get([]byte("bat"))
				assertFalse(t, ok)

//line ctrie_test.go2:253
 snapshot2 := snapshot.Clone()
	for i := 0; i < 100; i++ {
		_, ok := snapshot2.Get([]byte(strconv.Itoa(i)))
		assertFalse(t, ok)
	}
				val, ok = snapshot2.Get([]byte("bat"))
				assertTrue(t, ok)
//line ctrie_test.go2:259
 instantiate୦୦assertEqual୦interface୮4୮5(t, "man", val)

//line ctrie_test.go2:262
 snapshot2.Delete([]byte("bat"))
				_, ok = snapshot2.Get([]byte("bat"))
				assertFalse(t, ok)
				val, ok = snapshot.Get([]byte("bat"))
				assertTrue(t, ok)
//line ctrie_test.go2:266
 instantiate୦୦assertEqual୦interface୮4୮5(t, "man", val)
//line ctrie_test.go2:268
}

func TestRClone(t *testing.T) {
	ctrie := instantiate୦୦NewWithFuncs୦୮6୮7byte୦int(nil, nil)
	for i := 0; i < 100; i++ {
		ctrie.Set([]byte(strconv.Itoa(i)), i)
	}

				snapshot := ctrie.RClone()

//line ctrie_test.go2:279
 for i := 0; i < 100; i++ {
					val, ok := snapshot.Get([]byte(strconv.Itoa(i)))
					assertTrue(t, ok)
//line ctrie_test.go2:281
  instantiate୦୦assertEqual୦int(t, i, val)
//line ctrie_test.go2:283
 }

	for i := 0; i < 50; i++ {
		ctrie.Delete([]byte(strconv.Itoa(i)))
	}

//line ctrie_test.go2:290
 for i := 0; i < 100; i++ {
					val, ok := snapshot.Get([]byte(strconv.Itoa(i)))
					assertTrue(t, ok)
//line ctrie_test.go2:292
  instantiate୦୦assertEqual୦int(t, i, val)
//line ctrie_test.go2:294
 }

//line ctrie_test.go2:297
 func() {
		defer func() {
			assertNotNil(t, recover())
		}()
		snapshot.Delete([]byte("blah"))
	}()

//line ctrie_test.go2:305
 snapshot2 := snapshot.Clone()
	for i := 50; i < 100; i++ {
		ctrie.Delete([]byte(strconv.Itoa(i)))
	}
	for i := 0; i < 100; i++ {
					val, ok := snapshot2.Get([]byte(strconv.Itoa(i)))
					assertTrue(t, ok)
//line ctrie_test.go2:311
  instantiate୦୦assertEqual୦int(t, i, val)
//line ctrie_test.go2:313
 }

//line ctrie_test.go2:316
 func() {
		defer func() {
			assertNotNil(t, recover())
		}()
		snapshot2.Delete([]byte("blah"))
	}()
}

func TestIterator(t *testing.T) {
	ctrie := instantiate୦୦NewWithFuncs୦୮6୮7byte୦int(nil, nil)
	for i := 0; i < 10; i++ {
		ctrie.Set([]byte(strconv.Itoa(i)), i)
	}
	expected := map[string]int{
		"0": 0,
		"1": 1,
		"2": 2,
		"3": 3,
		"4": 4,
		"5": 5,
		"6": 6,
		"7": 7,
		"8": 8,
		"9": 9,
	}

	count := 0
	for iter := ctrie.Iterator(); iter.Next(); {
		exp, ok := expected[string(iter.Key())]
		if assertTrue(t, ok) {
//line ctrie_test.go2:345
   instantiate୦୦assertEqual୦int(t, exp, iter.Value())
//line ctrie_test.go2:347
  }
		count++
	}
//line ctrie_test.go2:349
 instantiate୦୦assertEqual୦int(t, len(expected), count)
//line ctrie_test.go2:351
}

//line ctrie_test.go2:354
func TestIteratorCoversTNodes(t *testing.T) {
				ctrie := instantiate୦୦NewWithFuncs୦୮6୮7byte୦bool(nil, func([]byte) uint64 { return 0 })

				ctrie.Set([]byte("a"), true)
				ctrie.Set([]byte("b"), true)

//line ctrie_test.go2:361
 ctrie.Delete([]byte("b"))
	seenKeys := map[string]bool{}
	for iter := ctrie.Iterator(); iter.Next(); {
		seenKeys[string(iter.Key())] = true
	}
	if !seenKeys["a"] {
		t.Errorf("Iterator did not return 'a'.")
	}
	if len(seenKeys) != 1 {
		t.Errorf("want 1 key got %d", len(seenKeys))
	}
}

func TestLen(t *testing.T) {
	ctrie := instantiate୦୦NewWithFuncs୦୮6୮7byte୦int(bytes.Equal, BytesHash)
	for i := 0; i < 10; i++ {
		ctrie.Set([]byte(strconv.Itoa(i)), i)
	}
//line ctrie_test.go2:378
 instantiate୦୦assertEqual୦int(t, 10, ctrie.Len())
//line ctrie_test.go2:380
}

func TestClear(t *testing.T) {
	ctrie := instantiate୦୦NewWithFuncs୦୮6୮7byte୦int(bytes.Equal, BytesHash)
	for i := 0; i < 10; i++ {
		ctrie.Set([]byte(strconv.Itoa(i)), i)
	}
//line ctrie_test.go2:386
 instantiate୦୦assertEqual୦int(t, 10, ctrie.Len())
//line ctrie_test.go2:388
 snapshot := ctrie.Clone()

				ctrie.Clear()
//line ctrie_test.go2:390
 instantiate୦୦assertEqual୦int(t, 0, ctrie.Len())
//line ctrie_test.go2:392
 instantiate୦୦assertEqual୦int(t, 10, snapshot.Len())
//line ctrie_test.go2:394
}

func TestHashCollision(t *testing.T) {
	trie := instantiate୦୦NewWithFuncs୦୮6୮7byte୦int(bytes.Equal, func([]byte) uint64 {
		return 42
	})
				trie.Set([]byte("foobar"), 1)
				trie.Set([]byte("zogzog"), 2)
				trie.Set([]byte("foobar"), 3)
				val, exists := trie.Get([]byte("foobar"))
				assertTrue(t, exists)
//line ctrie_test.go2:404
 instantiate୦୦assertEqual୦int(t, 3, val)

//line ctrie_test.go2:407
 trie.Delete([]byte("foobar"))

	_, exists = trie.Get([]byte("foobar"))
	assertFalse(t, exists)
}

func BenchmarkSet(b *testing.B) {
	ctrie := instantiate୦୦NewWithFuncs୦୮6୮7byte୦int(bytes.Equal, BytesHash)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		ctrie.Set([]byte("foo"), 0)
	}
}

func BenchmarkGet(b *testing.B) {
	numItems := 1000
	ctrie := instantiate୦୦NewWithFuncs୦୮6୮7byte୦int(bytes.Equal, BytesHash)
	for i := 0; i < numItems; i++ {
		ctrie.Set([]byte(strconv.Itoa(i)), i)
	}
	key := []byte(strconv.Itoa(numItems / 2))
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ctrie.Get(key)
	}
}

func BenchmarkDelete(b *testing.B) {
	numItems := 1000
	ctrie := instantiate୦୦NewWithFuncs୦୮6୮7byte୦int(bytes.Equal, BytesHash)
	for i := 0; i < numItems; i++ {
		ctrie.Set([]byte(strconv.Itoa(i)), i)
	}
	key := []byte(strconv.Itoa(numItems / 2))
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ctrie.Delete(key)
	}
}

func BenchmarkClone(b *testing.B) {
	numItems := 1000
	ctrie := instantiate୦୦NewWithFuncs୦୮6୮7byte୦int(bytes.Equal, BytesHash)
	for i := 0; i < numItems; i++ {
		ctrie.Set([]byte(strconv.Itoa(i)), i)
	}
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ctrie.Clone()
	}
}

func BenchmarkRClone(b *testing.B) {
	numItems := 1000
	ctrie := instantiate୦୦NewWithFuncs୦୮6୮7byte୦int(bytes.Equal, BytesHash)
	for i := 0; i < numItems; i++ {
		ctrie.Set([]byte(strconv.Itoa(i)), i)
	}
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ctrie.RClone()
	}
}

func assertTrue(t *testing.T, x bool) bool {
	t.Helper()
	if !x {
		t.Errorf("not true")
		return false
	}
	return true
}

func assertFalse(t *testing.T, x bool) {
	t.Helper()
	if x {
		t.Errorf("not false")
	}
}

//line ctrie_test.go2:498
func assertNotNil(t *testing.T, x interface{}) {
	t.Helper()
	if x == nil {
		t.Errorf("want non-nil, got nil")
	}
}
//line ctrie.go2:94
func instantiate୦୦NewWithFuncs୦୮6୮7byte୦string(
	eqFunc func(k1, k2 []byte,

//line ctrie.go2:95
 ) bool,
	hashFunc func([]byte,

//line ctrie.go2:96
 ) uint64,
) *instantiate୦୦Map୦୮6୮7byte୦string {
	if eqFunc == nil {
				var k []byte

//line ctrie.go2:100
  switch (interface{}(k)).(type) {
		case string:
			eqFunc = interface{}(func(k1, k2 string) bool {
				return k1 == k2
			}).(func([]byte, []byte,

//line ctrie.go2:104
   ) bool)
		case []byte:
			eqFunc = interface{}(bytes.Equal).(func([]byte, []byte,

//line ctrie.go2:106
   ) bool)
		default:
			panic(fmt.Errorf("no equality type known for %T", k))
		}
	}
	if hashFunc == nil {
				var k []byte

//line ctrie.go2:113
  switch (interface{}(k)).(type) {
		case string:
			hashFunc = interface{}(StringHash).(func([]byte,

//line ctrie.go2:115
   ) uint64)
		case []byte:
			hashFunc = interface{}(BytesHash).(func([]byte,

//line ctrie.go2:117
   ) uint64)
		default:
			panic(fmt.Errorf("no hash type known for %T", k))
		}
	}
	root := &instantiate୦୦iNode୦୮6୮7byte୦string{
		main: &instantiate୦୦mainNode୦୮6୮7byte୦string{
			cNode: &instantiate୦୦cNode୦୮6୮7byte୦string{},
		},
	}
	return instantiate୦୦newMap୦୮6୮7byte୦string(root, eqFunc, hashFunc, false)
}

//line ctrie_test.go2:491
func instantiate୦୦assertEqual୦string(t *testing.T, x, y string,) {
	t.Helper()
	if x != y {
		t.Errorf("not equal, got %#v want %#v", y, x)
	}
}
//line ctrie.go2:94
func instantiate୦୦NewWithFuncs୦୮6୮7byte୦int(
	eqFunc func(k1, k2 []byte,

//line ctrie.go2:95
 ) bool,
	hashFunc func([]byte,

//line ctrie.go2:96
 ) uint64,
) *instantiate୦୦Map୦୮6୮7byte୦int {
	if eqFunc == nil {
				var k []byte

//line ctrie.go2:100
  switch (interface{}(k)).(type) {
		case string:
			eqFunc = interface{}(func(k1, k2 string) bool {
				return k1 == k2
			}).(func([]byte, []byte,

//line ctrie.go2:104
   ) bool)
		case []byte:
			eqFunc = interface{}(bytes.Equal).(func([]byte, []byte,

//line ctrie.go2:106
   ) bool)
		default:
			panic(fmt.Errorf("no equality type known for %T", k))
		}
	}
	if hashFunc == nil {
				var k []byte

//line ctrie.go2:113
  switch (interface{}(k)).(type) {
		case string:
			hashFunc = interface{}(StringHash).(func([]byte,

//line ctrie.go2:115
   ) uint64)
		case []byte:
			hashFunc = interface{}(BytesHash).(func([]byte,

//line ctrie.go2:117
   ) uint64)
		default:
			panic(fmt.Errorf("no hash type known for %T", k))
		}
	}
	root := &instantiate୦୦iNode୦୮6୮7byte୦int{
		main: &instantiate୦୦mainNode୦୮6୮7byte୦int{
			cNode: &instantiate୦୦cNode୦୮6୮7byte୦int{},
		},
	}
	return instantiate୦୦newMap୦୮6୮7byte୦int(root, eqFunc, hashFunc, false)
}

//line ctrie_test.go2:491
func instantiate୦୦assertEqual୦int(t *testing.T, x, y int,) {
	t.Helper()
	if x != y {
		t.Errorf("not equal, got %#v want %#v", y, x)
	}
}
//line ctrie.go2:94
func instantiate୦୦NewWithFuncs୦୮6୮7byte୦interface୮4୮5(
	eqFunc func(k1, k2 []byte) bool,
	hashFunc func(

//line ctrie_test.go2:196
  []byte) uint64,
//line ctrie.go2:97
) *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5 {
	if eqFunc == nil {
		var k []byte
		switch (interface{}(k)).(type) {
		case string:
			eqFunc = interface{}(func(k1, k2 string) bool {
				return k1 == k2
			}).(func(

//line ctrie_test.go2:196
    []byte, []byte) bool)
//line ctrie.go2:105
  case []byte:
			eqFunc = interface{}(bytes.Equal).(func(

//line ctrie_test.go2:196
    []byte, []byte) bool)
//line ctrie.go2:107
  default:
			panic(fmt.Errorf("no equality type known for %T", k))
		}
	}
	if hashFunc == nil {
		var k []byte
		switch (interface{}(k)).(type) {
		case string:
			hashFunc = interface{}(StringHash).(func(

//line ctrie_test.go2:196
    []byte) uint64)
//line ctrie.go2:116
  case []byte:
			hashFunc = interface{}(BytesHash).(func(

//line ctrie_test.go2:196
    []byte) uint64)
//line ctrie.go2:118
  default:
			panic(fmt.Errorf("no hash type known for %T", k))
		}
	}
	root := &instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5{
		main: &instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5{
			cNode: &instantiate୦୦cNode୦୮6୮7byte୦interface୮4୮5{},
		},
	}
	return instantiate୦୦newMap୦୮6୮7byte୦interface୮4୮5(root, eqFunc, hashFunc, false)
}

//line ctrie_test.go2:491
func instantiate୦୦assertEqual୦interface୮4୮5(t *testing.T, x, y interface {
//line ctrie_test.go2:491
}) {
	t.Helper()
	if x != y {
		t.Errorf("not equal, got %#v want %#v", y, x)
	}
}
//line ctrie.go2:94
func instantiate୦୦NewWithFuncs୦୮6୮7byte୦bool(
	eqFunc func(k1, k2 []byte) bool,
	hashFunc func(

//line ctrie_test.go2:355
  []byte) uint64,
//line ctrie.go2:97
) *instantiate୦୦Map୦୮6୮7byte୦bool {
	if eqFunc == nil {
		var k []byte
		switch (interface{}(k)).(type) {
		case string:
			eqFunc = interface{}(func(k1, k2 string) bool {
				return k1 == k2
			}).(func(

//line ctrie_test.go2:355
    []byte, []byte) bool)
//line ctrie.go2:105
  case []byte:
			eqFunc = interface{}(bytes.Equal).(func(

//line ctrie_test.go2:355
    []byte, []byte) bool)
//line ctrie.go2:107
  default:
			panic(fmt.Errorf("no equality type known for %T", k))
		}
	}
	if hashFunc == nil {
		var k []byte
		switch (interface{}(k)).(type) {
		case string:
			hashFunc = interface{}(StringHash).(func(

//line ctrie_test.go2:355
    []byte) uint64)
//line ctrie.go2:116
  case []byte:
			hashFunc = interface{}(BytesHash).(func(

//line ctrie_test.go2:355
    []byte) uint64)
//line ctrie.go2:118
  default:
			panic(fmt.Errorf("no hash type known for %T", k))
		}
	}
	root := &instantiate୦୦iNode୦୮6୮7byte୦bool{
		main: &instantiate୦୦mainNode୦୮6୮7byte୦bool{
			cNode: &instantiate୦୦cNode୦୮6୮7byte୦bool{},
		},
	}
	return instantiate୦୦newMap୦୮6୮7byte୦bool(root, eqFunc, hashFunc, false)
}

//line ctrie.go2:128
type instantiate୦୦Map୦୮6୮7byte୦string struct {
//line ctrie.go2:68
 root     *instantiate୦୦iNode୦୮6୮7byte୦string
			readOnly bool
			hashFunc func([]byte,

//line ctrie.go2:70
 ) uint64
			eqFunc func([]byte, []byte,

//line ctrie.go2:71
 ) bool
}

//line ctrie.go2:146
func (c *instantiate୦୦Map୦୮6୮7byte୦string,) Set(key []byte,

//line ctrie.go2:146
 value string,

//line ctrie.go2:146
) {
	c.assertReadWrite()
	c.insert(&instantiate୦୦mapEntry୦୮6୮7byte୦string{
		key:   key,
		value: value,
		hash:  uint32(c.hashFunc(key)),
	})
}

//line ctrie.go2:157
func (c *instantiate୦୦Map୦୮6୮7byte୦string,) Get(key []byte,

//line ctrie.go2:157
) (string,

//line ctrie.go2:157
 bool) {
	return c.lookup(&instantiate୦୦mapEntry୦୮6୮7byte୦string{
		key:  key,
		hash: uint32(c.hashFunc(key)),
	})
}

//line ctrie.go2:166
func (c *instantiate୦୦Map୦୮6୮7byte୦string,) Delete(key []byte,

//line ctrie.go2:166
) (string,

//line ctrie.go2:166
 bool) {
	c.assertReadWrite()
	return c.remove(&instantiate୦୦mapEntry୦୮6୮7byte୦string{
		key:  key,
		hash: uint32(c.hashFunc(key)),
	})
}

//line ctrie.go2:176
func (c *instantiate୦୦Map୦୮6୮7byte୦string,) Clone() *instantiate୦୦Map୦୮6୮7byte୦string {
	return c.clone(c.readOnly)
}

//line ctrie.go2:182
func (c *instantiate୦୦Map୦୮6୮7byte୦string,) RClone() *instantiate୦୦Map୦୮6୮7byte୦string {
	return c.clone(true)
}

//line ctrie.go2:187
func (c *instantiate୦୦Map୦୮6୮7byte୦string,) clone(readOnly bool) *instantiate୦୦Map୦୮6୮7byte୦string {
	if readOnly && c.readOnly {
		return c
	}
	for {
		root := c.readRoot()
		main := instantiate୦୦gcasRead୦୮6୮7byte୦string(root, c)
		if c.rdcssRoot(root, main, root.copyToGen(&generation{}, c)) {
			if readOnly {

				return instantiate୦୦newMap୦୮6୮7byte୦string(root, c.eqFunc, c.hashFunc, readOnly)
			}

			return instantiate୦୦newMap୦୮6୮7byte୦string(c.readRoot().copyToGen(&generation{}, c), c.eqFunc, c.hashFunc, readOnly)
		}
	}
}

//line ctrie.go2:206
func (c *instantiate୦୦Map୦୮6୮7byte୦string,) Clear() {
	c.assertReadWrite()
	for {
		root := c.readRoot()
		gen := &generation{}
		newRoot := &instantiate୦୦iNode୦୮6୮7byte୦string{
			main: &instantiate୦୦mainNode୦୮6୮7byte୦string{cNode: &instantiate୦୦cNode୦୮6୮7byte୦string{gen: gen}},
			gen:  gen,
		}
		if c.rdcssRoot(root, instantiate୦୦gcasRead୦୮6୮7byte୦string(root, c), newRoot) {
			return
		}
	}
}

//line ctrie.go2:223
func (c *instantiate୦୦Map୦୮6୮7byte୦string,) Len() int {

//line ctrie.go2:229
 size := 0
	for iter := c.Iterator(); iter.Next(); {
		size++
	}
	return size
}

//line ctrie.go2:237
func (c *instantiate୦୦Map୦୮6୮7byte୦string,) Iterator() *instantiate୦୦Iter୦୮6୮7byte୦string {
	iter := &instantiate୦୦Iter୦୮6୮7byte୦string{
		c: c,
	}
	iter.push((*instantiate୦୦Iter୦୮6୮7byte୦string).mainIter).iNode = c.RClone().readRoot()
	return iter
}

//line ctrie.go2:355
func (c *instantiate୦୦Map୦୮6୮7byte୦string,) assertReadWrite() {
	if c.readOnly {
		panic("Cannot modify read-only clone")
	}
}

func (c *instantiate୦୦Map୦୮6୮7byte୦string,) insert(entry *instantiate୦୦mapEntry୦୮6୮7byte୦string,) {
	root := c.readRoot()
	if !c.iinsert(root, entry, 0, nil, root.gen) {
		c.insert(entry)
	}
}

func (c *instantiate୦୦Map୦୮6୮7byte୦string,) lookup(entry *instantiate୦୦mapEntry୦୮6୮7byte୦string,) (string,

//line ctrie.go2:368
 bool) {
	root := c.readRoot()
	result, exists, ok := c.ilookup(root, entry, 0, nil, root.gen)
	for !ok {
		return c.lookup(entry)
	}
	return result, exists
}

func (c *instantiate୦୦Map୦୮6୮7byte୦string,) remove(entry *instantiate୦୦mapEntry୦୮6୮7byte୦string,) (string,

//line ctrie.go2:377
 bool) {
	root := c.readRoot()
	result, exists, ok := c.iremove(root, entry, 0, nil, root.gen)
	for !ok {
		return c.remove(entry)
	}
	return result, exists
}

//line ctrie.go2:388
func (c *instantiate୦୦Map୦୮6୮7byte୦string,) iinsert(i *instantiate୦୦iNode୦୮6୮7byte୦string, entry *instantiate୦୦mapEntry୦୮6୮7byte୦string, lev uint, parent *instantiate୦୦iNode୦୮6୮7byte୦string, startGen *generation) bool {

	main := instantiate୦୦gcasRead୦୮6୮7byte୦string(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:399
   rn := cn
			if cn.gen != i.gen {
				rn = cn.renewed(i.gen, c)
			}
			ncn := &instantiate୦୦mainNode୦୮6୮7byte୦string{
				cNode: rn.inserted(pos, flag, &instantiate୦୦sNode୦୮6୮7byte୦string{entry}, i.gen),
			}
			return instantiate୦୦gcas୦୮6୮7byte୦string(i, main, ncn, c)
		}

//line ctrie.go2:410
  branch := cn.slice[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦୮6୮7byte୦string:

			if startGen == branch.gen {
				return c.iinsert(branch, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦୮6୮7byte୦string(i, main, &instantiate୦୦mainNode୦୮6୮7byte୦string{cNode: cn.renewed(startGen, c)}, c) {
				return c.iinsert(i, entry, lev, parent, startGen)
			}
			return false
		case *instantiate୦୦sNode୦୮6୮7byte୦string:
			sn := branch
			if !c.eqFunc(sn.entry.key, entry.key) {

//line ctrie.go2:431
    rn := cn
				if cn.gen != i.gen {
					rn = cn.renewed(i.gen, c)
				}
				nsn := &instantiate୦୦sNode୦୮6୮7byte୦string{entry}
				nin := &instantiate୦୦iNode୦୮6୮7byte୦string{main: instantiate୦୦newMainNode୦୮6୮7byte୦string(sn, sn.entry.hash, nsn, nsn.entry.hash, lev+w, i.gen), gen: i.gen}
				ncn := &instantiate୦୦mainNode୦୮6୮7byte୦string{cNode: rn.updated(pos, nin, i.gen)}
				return instantiate୦୦gcas୦୮6୮7byte୦string(i, main, ncn, c)
			}

//line ctrie.go2:443
   ncn := &instantiate୦୦mainNode୦୮6୮7byte୦string{cNode: cn.updated(pos, &instantiate୦୦sNode୦୮6୮7byte୦string{entry}, i.gen)}
			return instantiate୦୦gcas୦୮6୮7byte୦string(i, main, ncn, c)
		default:
			panic("Map is in an invalid state")
		}
	case main.tNode != nil:
//line ctrie.go2:448
  instantiate୦୦clean୦୮6୮7byte୦string(parent, lev-w, c)
//line ctrie.go2:450
  return false
	case main.lNode != nil:
		nln := &instantiate୦୦mainNode୦୮6୮7byte୦string{lNode: main.lNode.inserted(entry, c.eqFunc)}
		return instantiate୦୦gcas୦୮6୮7byte୦string(i, main, nln, c)
	default:
		panic("Map is in an invalid state")
	}
}

//line ctrie.go2:463
func (c *instantiate୦୦Map୦୮6୮7byte୦string,) ilookup(i *instantiate୦୦iNode୦୮6୮7byte୦string, entry *instantiate୦୦mapEntry୦୮6୮7byte୦string, lev uint, parent *instantiate୦୦iNode୦୮6୮7byte୦string, startGen *generation) (string,

//line ctrie.go2:463
 bool, bool) {

	main := instantiate୦୦gcasRead୦୮6୮7byte୦string(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:473
   return instantiate୦୦z୦string(), false, true
		}

		branch := cn.slice[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦୮6୮7byte୦string:

//line ctrie.go2:481
   in := branch
			if c.readOnly || startGen == in.gen {
				return c.ilookup(in, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦୮6୮7byte୦string(i, main, &instantiate୦୦mainNode୦୮6୮7byte୦string{cNode: cn.renewed(startGen, c)}, c) {
				return c.ilookup(i, entry, lev, parent, startGen)
			}
			return instantiate୦୦z୦string(), false, false
		case *instantiate୦୦sNode୦୮6୮7byte୦string:

//line ctrie.go2:495
   sn := branch
			if c.eqFunc(sn.entry.key, entry.key) {
				return sn.entry.value, true, true
			}
			return instantiate୦୦z୦string(), false, true
		default:
			panic("Map is in an invalid state")
		}
	case main.tNode != nil:
		return instantiate୦୦cleanReadOnly୦୮6୮7byte୦string(main.tNode, lev, parent, c, entry)
	case main.lNode != nil:

//line ctrie.go2:508
  val, ok := main.lNode.lookup(entry, c.eqFunc)
		return val, ok, true
	default:
		panic("Map is in an invalid state")
	}
}

//line ctrie.go2:519
func (c *instantiate୦୦Map୦୮6୮7byte୦string,) iremove(i *instantiate୦୦iNode୦୮6୮7byte୦string, entry *instantiate୦୦mapEntry୦୮6୮7byte୦string, lev uint, parent *instantiate୦୦iNode୦୮6୮7byte୦string, startGen *generation) (string,

//line ctrie.go2:519
 bool, bool) {

	main := instantiate୦୦gcasRead୦୮6୮7byte୦string(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:529
   return instantiate୦୦z୦string(), false, true
		}

		branch := cn.slice[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦୮6୮7byte୦string:

//line ctrie.go2:537
   in := branch
			if startGen == in.gen {
				return c.iremove(in, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦୮6୮7byte୦string(i, main, &instantiate୦୦mainNode୦୮6୮7byte୦string{cNode: cn.renewed(startGen, c)}, c) {
				return c.iremove(i, entry, lev, parent, startGen)
			}
			return instantiate୦୦z୦string(), false, false
		case *instantiate୦୦sNode୦୮6୮7byte୦string:

//line ctrie.go2:548
   sn := branch
			if !c.eqFunc(sn.entry.key, entry.key) {

				return instantiate୦୦z୦string(), false, true
			}

//line ctrie.go2:559
   ncn := cn.removed(pos, flag, i.gen)
			cntr := instantiate୦୦toContracted୦୮6୮7byte୦string(ncn, lev)
			if instantiate୦୦gcas୦୮6୮7byte୦string(i, main, cntr, c) {
				if parent != nil {
					main = instantiate୦୦gcasRead୦୮6୮7byte୦string(i, c)
					if main.tNode != nil {
//line ctrie.go2:564
      instantiate୦୦cleanParent୦୮6୮7byte୦string(parent, i, entry.hash, lev-w, c, startGen)
//line ctrie.go2:566
     }
				}
				return sn.entry.value, true, true
			}
			return instantiate୦୦z୦string(), false, false
		default:
			panic("Map is in an invalid state")
		}
	case main.tNode != nil:
//line ctrie.go2:574
  instantiate୦୦clean୦୮6୮7byte୦string(parent, lev-w, c)
//line ctrie.go2:576
  return instantiate୦୦z୦string(), false, false
	case main.lNode != nil:
		nln := &instantiate୦୦mainNode୦୮6୮7byte୦string{
			lNode: main.lNode.removed(entry, c.eqFunc),
		}
		if nln.lNode != nil && nln.lNode.tail == nil {

			nln = instantiate୦୦entomb୦୮6୮7byte୦string(nln.lNode.head)
		}
		if instantiate୦୦gcas୦୮6୮7byte୦string(i, main, nln, c) {
			val, ok := main.lNode.lookup(entry, c.eqFunc)
			return val, ok, true
		}
		return instantiate୦୦z୦string(), false, true
	default:
		panic("Map is in an invalid state")
	}
}

//line ctrie.go2:976
func (c *instantiate୦୦Map୦୮6୮7byte୦string,) readRoot() *instantiate୦୦iNode୦୮6୮7byte୦string {
	return c.rdcssReadRoot(false)
}

//line ctrie.go2:982
func (c *instantiate୦୦Map୦୮6୮7byte୦string,) rdcssReadRoot(abort bool) *instantiate୦୦iNode୦୮6୮7byte୦string {
	r := instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8୮6୮7byte୮3୮0string୮9(&c.root)
	if r.rdcss != nil {
		return c.rdcssComplete(abort)
	}
	return r
}

//line ctrie.go2:993
func (c *instantiate୦୦Map୦୮6୮7byte୦string,) rdcssRoot(old *instantiate୦୦iNode୦୮6୮7byte୦string, expected *instantiate୦୦mainNode୦୮6୮7byte୦string, nv *instantiate୦୦iNode୦୮6୮7byte୦string,) bool {
	desc := &instantiate୦୦iNode୦୮6୮7byte୦string{
		rdcss: &instantiate୦୦rdcssDescriptor୦୮6୮7byte୦string{
			old:      old,
			expected: expected,
			nv:       nv,
		},
	}
	if c.casRoot(old, desc) {
		c.rdcssComplete(false)
		return gatomic.LoadInt32(&desc.rdcss.committed) == 1
	}
	return false
}

//line ctrie.go2:1009
func (c *instantiate୦୦Map୦୮6୮7byte୦string,) rdcssComplete(abort bool) *instantiate୦୦iNode୦୮6୮7byte୦string {
	for {
		r := instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8୮6୮7byte୮3୮0string୮9(&c.root)
		if r.rdcss == nil {
			return r
		}
		desc := r.rdcss
		ov := desc.old
		exp := desc.expected
		nv := desc.nv
		if abort {
			if c.casRoot(r, ov) {
				return ov
			}
			continue
		}
		oldeMain := instantiate୦୦gcasRead୦୮6୮7byte୦string(ov, c)
		if oldeMain == exp {

			if c.casRoot(r, nv) {
				gatomic.StoreInt32(&desc.committed, 1)
				return nv
			}
			continue
		}
		if c.casRoot(r, ov) {
			return ov
		}
	}
}

//line ctrie.go2:1041
func (c *instantiate୦୦Map୦୮6୮7byte୦string,) casRoot(ov, nv *instantiate୦୦iNode୦୮6୮7byte୦string,) bool {
	c.assertReadWrite()
	return instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮aiNode୮8୮6୮7byte୮3୮0string୮9(&c.root, ov, nv)
}

//line ctrie.go2:1044
type instantiate୦୦iNode୦୮6୮7byte୦string struct {
//line ctrie.go2:600
 main *instantiate୦୦mainNode୦୮6୮7byte୦string
			gen  *generation

//line ctrie.go2:606
 rdcss *instantiate୦୦rdcssDescriptor୦୮6୮7byte୦string
}

//line ctrie.go2:610
func (i *instantiate୦୦iNode୦୮6୮7byte୦string,) copyToGen(gen *generation, ctrie *instantiate୦୦Map୦୮6୮7byte୦string,) *instantiate୦୦iNode୦୮6୮7byte୦string {
			nin := &instantiate୦୦iNode୦୮6୮7byte୦string{gen: gen}
			main := instantiate୦୦gcasRead୦୮6୮7byte୦string(i, ctrie)
//line ctrie.go2:612
 instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0string୮9(&nin.main, main)
//line ctrie.go2:614
 return nin
}

//line ctrie.go2:615
type instantiate୦୦mainNode୦୮6୮7byte୦string struct {
//line ctrie.go2:620
 cNode *instantiate୦୦cNode୦୮6୮7byte୦string
			tNode  *instantiate୦୦tNode୦୮6୮7byte୦string
			lNode  *instantiate୦୦lNode୦୮6୮7byte୦string
			failed *instantiate୦୦mainNode୦୮6୮7byte୦string

//line ctrie.go2:629
 prev *instantiate୦୦mainNode୦୮6୮7byte୦string
}
//line ctrie.go2:630
type instantiate୦୦cNode୦୮6୮7byte୦string struct {
//line ctrie.go2:636
 bmp uint32
	slice []branch
	gen   *generation
}

//line ctrie.go2:674
func (c *instantiate୦୦cNode୦୮6୮7byte୦string,) inserted(pos int, flag uint32, br branch, gen *generation) *instantiate୦୦cNode୦୮6୮7byte୦string {
	slice := make([]branch, len(c.slice)+1)
	copy(slice, c.slice[:pos])
	slice[pos] = br
	copy(slice[pos+1:], c.slice[pos:])
	return &instantiate୦୦cNode୦୮6୮7byte୦string{
		bmp:   c.bmp | flag,
		slice: slice,
		gen:   gen,
	}
}

//line ctrie.go2:687
func (c *instantiate୦୦cNode୦୮6୮7byte୦string,) updated(pos int, br branch, gen *generation) *instantiate୦୦cNode୦୮6୮7byte୦string {
	slice := make([]branch, len(c.slice))
	copy(slice, c.slice)
	slice[pos] = br
	return &instantiate୦୦cNode୦୮6୮7byte୦string{
		bmp:   c.bmp,
		slice: slice,
		gen:   gen,
	}
}

//line ctrie.go2:700
func (c *instantiate୦୦cNode୦୮6୮7byte୦string,) removed(pos int, flag uint32, gen *generation) *instantiate୦୦cNode୦୮6୮7byte୦string {
	slice := make([]branch, len(c.slice)-1)
	copy(slice, c.slice[0:pos])
	copy(slice[pos:], c.slice[pos+1:])
	return &instantiate୦୦cNode୦୮6୮7byte୦string{
		bmp:   c.bmp ^ flag,
		slice: slice,
		gen:   gen,
	}
}

//line ctrie.go2:713
func (c *instantiate୦୦cNode୦୮6୮7byte୦string,) renewed(gen *generation, ctrie *instantiate୦୦Map୦୮6୮7byte୦string,) *instantiate୦୦cNode୦୮6୮7byte୦string {
	slice := make([]branch, len(c.slice))
	for i, br := range c.slice {
		switch t := br.(type) {
		case *instantiate୦୦iNode୦୮6୮7byte୦string:
			slice[i] = t.copyToGen(gen, ctrie)
		default:
			slice[i] = br
		}
	}
	return &instantiate୦୦cNode୦୮6୮7byte୦string{
		bmp:   c.bmp,
		slice: slice,
		gen:   gen,
	}
}
//line ctrie.go2:130
func instantiate୦୦newMap୦୮6୮7byte୦string(
	root *instantiate୦୦iNode୦୮6୮7byte୦string,
	eqFunc func([]byte, []byte,

//line ctrie.go2:132
 ) bool,
	hashFunc func([]byte,

//line ctrie.go2:133
 ) uint64,
	readOnly bool,
) *instantiate୦୦Map୦୮6୮7byte୦string {
	return &instantiate୦୦Map୦୮6୮7byte୦string{
		root:     root,
		eqFunc:   eqFunc,
		hashFunc: hashFunc,
		readOnly: readOnly,
	}
}

//line ctrie.go2:142
type instantiate୦୦Map୦୮6୮7byte୦int struct {
//line ctrie.go2:68
 root     *instantiate୦୦iNode୦୮6୮7byte୦int
			readOnly bool
			hashFunc func(

//line ctrie_test.go2:82
  []byte) uint64
//line ctrie.go2:71
 eqFunc func(

//line ctrie_test.go2:82
  []byte, []byte) bool
//line ctrie.go2:72
}

//line ctrie.go2:146
func (c *instantiate୦୦Map୦୮6୮7byte୦int,) Set(key []byte,

//line ctrie.go2:146
 value int,

//line ctrie.go2:146
) {
	c.assertReadWrite()
	c.insert(&instantiate୦୦mapEntry୦୮6୮7byte୦int{
		key:   key,
		value: value,
		hash:  uint32(c.hashFunc(key)),
	})
}

//line ctrie.go2:157
func (c *instantiate୦୦Map୦୮6୮7byte୦int,) Get(key []byte,

//line ctrie.go2:157
) (int,

//line ctrie.go2:157
 bool) {
	return c.lookup(&instantiate୦୦mapEntry୦୮6୮7byte୦int{
		key:  key,
		hash: uint32(c.hashFunc(key)),
	})
}

//line ctrie.go2:166
func (c *instantiate୦୦Map୦୮6୮7byte୦int,) Delete(key []byte,

//line ctrie.go2:166
) (int,

//line ctrie.go2:166
 bool) {
	c.assertReadWrite()
	return c.remove(&instantiate୦୦mapEntry୦୮6୮7byte୦int{
		key:  key,
		hash: uint32(c.hashFunc(key)),
	})
}

//line ctrie.go2:176
func (c *instantiate୦୦Map୦୮6୮7byte୦int,) Clone() *instantiate୦୦Map୦୮6୮7byte୦int {
	return c.clone(c.readOnly)
}

//line ctrie.go2:182
func (c *instantiate୦୦Map୦୮6୮7byte୦int,) RClone() *instantiate୦୦Map୦୮6୮7byte୦int {
	return c.clone(true)
}

//line ctrie.go2:187
func (c *instantiate୦୦Map୦୮6୮7byte୦int,) clone(readOnly bool) *instantiate୦୦Map୦୮6୮7byte୦int {
	if readOnly && c.readOnly {
		return c
	}
	for {
		root := c.readRoot()
		main := instantiate୦୦gcasRead୦୮6୮7byte୦int(root, c)
		if c.rdcssRoot(root, main, root.copyToGen(&generation{}, c)) {
			if readOnly {

				return instantiate୦୦newMap୦୮6୮7byte୦int(root, c.eqFunc, c.hashFunc, readOnly)
			}

			return instantiate୦୦newMap୦୮6୮7byte୦int(c.readRoot().copyToGen(&generation{}, c), c.eqFunc, c.hashFunc, readOnly)
		}
	}
}

//line ctrie.go2:206
func (c *instantiate୦୦Map୦୮6୮7byte୦int,) Clear() {
	c.assertReadWrite()
	for {
		root := c.readRoot()
		gen := &generation{}
		newRoot := &instantiate୦୦iNode୦୮6୮7byte୦int{
			main: &instantiate୦୦mainNode୦୮6୮7byte୦int{cNode: &instantiate୦୦cNode୦୮6୮7byte୦int{gen: gen}},
			gen:  gen,
		}
		if c.rdcssRoot(root, instantiate୦୦gcasRead୦୮6୮7byte୦int(root, c), newRoot) {
			return
		}
	}
}

//line ctrie.go2:223
func (c *instantiate୦୦Map୦୮6୮7byte୦int,) Len() int {

//line ctrie.go2:229
 size := 0
	for iter := c.Iterator(); iter.Next(); {
		size++
	}
	return size
}

//line ctrie.go2:237
func (c *instantiate୦୦Map୦୮6୮7byte୦int,) Iterator() *instantiate୦୦Iter୦୮6୮7byte୦int {
	iter := &instantiate୦୦Iter୦୮6୮7byte୦int{
		c: c,
	}
	iter.push((*instantiate୦୦Iter୦୮6୮7byte୦int).mainIter).iNode = c.RClone().readRoot()
	return iter
}

//line ctrie.go2:355
func (c *instantiate୦୦Map୦୮6୮7byte୦int,) assertReadWrite() {
	if c.readOnly {
		panic("Cannot modify read-only clone")
	}
}

func (c *instantiate୦୦Map୦୮6୮7byte୦int,) insert(entry *instantiate୦୦mapEntry୦୮6୮7byte୦int,) {
	root := c.readRoot()
	if !c.iinsert(root, entry, 0, nil, root.gen) {
		c.insert(entry)
	}
}

func (c *instantiate୦୦Map୦୮6୮7byte୦int,) lookup(entry *instantiate୦୦mapEntry୦୮6୮7byte୦int,) (int,

//line ctrie.go2:368
 bool) {
	root := c.readRoot()
	result, exists, ok := c.ilookup(root, entry, 0, nil, root.gen)
	for !ok {
		return c.lookup(entry)
	}
	return result, exists
}

func (c *instantiate୦୦Map୦୮6୮7byte୦int,) remove(entry *instantiate୦୦mapEntry୦୮6୮7byte୦int,) (int,

//line ctrie.go2:377
 bool) {
	root := c.readRoot()
	result, exists, ok := c.iremove(root, entry, 0, nil, root.gen)
	for !ok {
		return c.remove(entry)
	}
	return result, exists
}

//line ctrie.go2:388
func (c *instantiate୦୦Map୦୮6୮7byte୦int,) iinsert(i *instantiate୦୦iNode୦୮6୮7byte୦int, entry *instantiate୦୦mapEntry୦୮6୮7byte୦int, lev uint, parent *instantiate୦୦iNode୦୮6୮7byte୦int, startGen *generation) bool {

	main := instantiate୦୦gcasRead୦୮6୮7byte୦int(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:399
   rn := cn
			if cn.gen != i.gen {
				rn = cn.renewed(i.gen, c)
			}
			ncn := &instantiate୦୦mainNode୦୮6୮7byte୦int{
				cNode: rn.inserted(pos, flag, &instantiate୦୦sNode୦୮6୮7byte୦int{entry}, i.gen),
			}
			return instantiate୦୦gcas୦୮6୮7byte୦int(i, main, ncn, c)
		}

//line ctrie.go2:410
  branch := cn.slice[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦୮6୮7byte୦int:

			if startGen == branch.gen {
				return c.iinsert(branch, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦୮6୮7byte୦int(i, main, &instantiate୦୦mainNode୦୮6୮7byte୦int{cNode: cn.renewed(startGen, c)}, c) {
				return c.iinsert(i, entry, lev, parent, startGen)
			}
			return false
		case *instantiate୦୦sNode୦୮6୮7byte୦int:
			sn := branch
			if !c.eqFunc(sn.entry.key, entry.key) {

//line ctrie.go2:431
    rn := cn
				if cn.gen != i.gen {
					rn = cn.renewed(i.gen, c)
				}
				nsn := &instantiate୦୦sNode୦୮6୮7byte୦int{entry}
				nin := &instantiate୦୦iNode୦୮6୮7byte୦int{main: instantiate୦୦newMainNode୦୮6୮7byte୦int(sn, sn.entry.hash, nsn, nsn.entry.hash, lev+w, i.gen), gen: i.gen}
				ncn := &instantiate୦୦mainNode୦୮6୮7byte୦int{cNode: rn.updated(pos, nin, i.gen)}
				return instantiate୦୦gcas୦୮6୮7byte୦int(i, main, ncn, c)
			}

//line ctrie.go2:443
   ncn := &instantiate୦୦mainNode୦୮6୮7byte୦int{cNode: cn.updated(pos, &instantiate୦୦sNode୦୮6୮7byte୦int{entry}, i.gen)}
			return instantiate୦୦gcas୦୮6୮7byte୦int(i, main, ncn, c)
		default:
			panic("Map is in an invalid state")
		}
	case main.tNode != nil:
//line ctrie.go2:448
  instantiate୦୦clean୦୮6୮7byte୦int(parent, lev-w, c)
//line ctrie.go2:450
  return false
	case main.lNode != nil:
		nln := &instantiate୦୦mainNode୦୮6୮7byte୦int{lNode: main.lNode.inserted(entry, c.eqFunc)}
		return instantiate୦୦gcas୦୮6୮7byte୦int(i, main, nln, c)
	default:
		panic("Map is in an invalid state")
	}
}

//line ctrie.go2:463
func (c *instantiate୦୦Map୦୮6୮7byte୦int,) ilookup(i *instantiate୦୦iNode୦୮6୮7byte୦int, entry *instantiate୦୦mapEntry୦୮6୮7byte୦int, lev uint, parent *instantiate୦୦iNode୦୮6୮7byte୦int, startGen *generation) (int,

//line ctrie.go2:463
 bool, bool) {

	main := instantiate୦୦gcasRead୦୮6୮7byte୦int(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:473
   return instantiate୦୦z୦int(), false, true
		}

		branch := cn.slice[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦୮6୮7byte୦int:

//line ctrie.go2:481
   in := branch
			if c.readOnly || startGen == in.gen {
				return c.ilookup(in, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦୮6୮7byte୦int(i, main, &instantiate୦୦mainNode୦୮6୮7byte୦int{cNode: cn.renewed(startGen, c)}, c) {
				return c.ilookup(i, entry, lev, parent, startGen)
			}
			return instantiate୦୦z୦int(), false, false
		case *instantiate୦୦sNode୦୮6୮7byte୦int:

//line ctrie.go2:495
   sn := branch
			if c.eqFunc(sn.entry.key, entry.key) {
				return sn.entry.value, true, true
			}
			return instantiate୦୦z୦int(), false, true
		default:
			panic("Map is in an invalid state")
		}
	case main.tNode != nil:
		return instantiate୦୦cleanReadOnly୦୮6୮7byte୦int(main.tNode, lev, parent, c, entry)
	case main.lNode != nil:

//line ctrie.go2:508
  val, ok := main.lNode.lookup(entry, c.eqFunc)
		return val, ok, true
	default:
		panic("Map is in an invalid state")
	}
}

//line ctrie.go2:519
func (c *instantiate୦୦Map୦୮6୮7byte୦int,) iremove(i *instantiate୦୦iNode୦୮6୮7byte୦int, entry *instantiate୦୦mapEntry୦୮6୮7byte୦int, lev uint, parent *instantiate୦୦iNode୦୮6୮7byte୦int, startGen *generation) (int,

//line ctrie.go2:519
 bool, bool) {

	main := instantiate୦୦gcasRead୦୮6୮7byte୦int(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:529
   return instantiate୦୦z୦int(), false, true
		}

		branch := cn.slice[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦୮6୮7byte୦int:

//line ctrie.go2:537
   in := branch
			if startGen == in.gen {
				return c.iremove(in, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦୮6୮7byte୦int(i, main, &instantiate୦୦mainNode୦୮6୮7byte୦int{cNode: cn.renewed(startGen, c)}, c) {
				return c.iremove(i, entry, lev, parent, startGen)
			}
			return instantiate୦୦z୦int(), false, false
		case *instantiate୦୦sNode୦୮6୮7byte୦int:

//line ctrie.go2:548
   sn := branch
			if !c.eqFunc(sn.entry.key, entry.key) {

				return instantiate୦୦z୦int(), false, true
			}

//line ctrie.go2:559
   ncn := cn.removed(pos, flag, i.gen)
			cntr := instantiate୦୦toContracted୦୮6୮7byte୦int(ncn, lev)
			if instantiate୦୦gcas୦୮6୮7byte୦int(i, main, cntr, c) {
				if parent != nil {
					main = instantiate୦୦gcasRead୦୮6୮7byte୦int(i, c)
					if main.tNode != nil {
//line ctrie.go2:564
      instantiate୦୦cleanParent୦୮6୮7byte୦int(parent, i, entry.hash, lev-w, c, startGen)
//line ctrie.go2:566
     }
				}
				return sn.entry.value, true, true
			}
			return instantiate୦୦z୦int(), false, false
		default:
			panic("Map is in an invalid state")
		}
	case main.tNode != nil:
//line ctrie.go2:574
  instantiate୦୦clean୦୮6୮7byte୦int(parent, lev-w, c)
//line ctrie.go2:576
  return instantiate୦୦z୦int(), false, false
	case main.lNode != nil:
		nln := &instantiate୦୦mainNode୦୮6୮7byte୦int{
			lNode: main.lNode.removed(entry, c.eqFunc),
		}
		if nln.lNode != nil && nln.lNode.tail == nil {

			nln = instantiate୦୦entomb୦୮6୮7byte୦int(nln.lNode.head)
		}
		if instantiate୦୦gcas୦୮6୮7byte୦int(i, main, nln, c) {
			val, ok := main.lNode.lookup(entry, c.eqFunc)
			return val, ok, true
		}
		return instantiate୦୦z୦int(), false, true
	default:
		panic("Map is in an invalid state")
	}
}

//line ctrie.go2:976
func (c *instantiate୦୦Map୦୮6୮7byte୦int,) readRoot() *instantiate୦୦iNode୦୮6୮7byte୦int {
	return c.rdcssReadRoot(false)
}

//line ctrie.go2:982
func (c *instantiate୦୦Map୦୮6୮7byte୦int,) rdcssReadRoot(abort bool) *instantiate୦୦iNode୦୮6୮7byte୦int {
	r := instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8୮6୮7byte୮3୮0int୮9(&c.root)
	if r.rdcss != nil {
		return c.rdcssComplete(abort)
	}
	return r
}

//line ctrie.go2:993
func (c *instantiate୦୦Map୦୮6୮7byte୦int,) rdcssRoot(old *instantiate୦୦iNode୦୮6୮7byte୦int, expected *instantiate୦୦mainNode୦୮6୮7byte୦int, nv *instantiate୦୦iNode୦୮6୮7byte୦int,) bool {
	desc := &instantiate୦୦iNode୦୮6୮7byte୦int{
		rdcss: &instantiate୦୦rdcssDescriptor୦୮6୮7byte୦int{
			old:      old,
			expected: expected,
			nv:       nv,
		},
	}
	if c.casRoot(old, desc) {
		c.rdcssComplete(false)
		return gatomic.LoadInt32(&desc.rdcss.committed) == 1
	}
	return false
}

//line ctrie.go2:1009
func (c *instantiate୦୦Map୦୮6୮7byte୦int,) rdcssComplete(abort bool) *instantiate୦୦iNode୦୮6୮7byte୦int {
	for {
		r := instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8୮6୮7byte୮3୮0int୮9(&c.root)
		if r.rdcss == nil {
			return r
		}
		desc := r.rdcss
		ov := desc.old
		exp := desc.expected
		nv := desc.nv
		if abort {
			if c.casRoot(r, ov) {
				return ov
			}
			continue
		}
		oldeMain := instantiate୦୦gcasRead୦୮6୮7byte୦int(ov, c)
		if oldeMain == exp {

			if c.casRoot(r, nv) {
				gatomic.StoreInt32(&desc.committed, 1)
				return nv
			}
			continue
		}
		if c.casRoot(r, ov) {
			return ov
		}
	}
}

//line ctrie.go2:1041
func (c *instantiate୦୦Map୦୮6୮7byte୦int,) casRoot(ov, nv *instantiate୦୦iNode୦୮6୮7byte୦int,) bool {
	c.assertReadWrite()
	return instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮aiNode୮8୮6୮7byte୮3୮0int୮9(&c.root, ov, nv)
}

//line ctrie.go2:1044
type instantiate୦୦iNode୦୮6୮7byte୦int struct {
//line ctrie.go2:600
 main *instantiate୦୦mainNode୦୮6୮7byte୦int
			gen  *generation

//line ctrie.go2:606
 rdcss *instantiate୦୦rdcssDescriptor୦୮6୮7byte୦int
}

//line ctrie.go2:610
func (i *instantiate୦୦iNode୦୮6୮7byte୦int,) copyToGen(gen *generation, ctrie *instantiate୦୦Map୦୮6୮7byte୦int,) *instantiate୦୦iNode୦୮6୮7byte୦int {
			nin := &instantiate୦୦iNode୦୮6୮7byte୦int{gen: gen}
			main := instantiate୦୦gcasRead୦୮6୮7byte୦int(i, ctrie)
//line ctrie.go2:612
 instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0int୮9(&nin.main, main)
//line ctrie.go2:614
 return nin
}

//line ctrie.go2:615
type instantiate୦୦mainNode୦୮6୮7byte୦int struct {
//line ctrie.go2:620
 cNode *instantiate୦୦cNode୦୮6୮7byte୦int
			tNode  *instantiate୦୦tNode୦୮6୮7byte୦int
			lNode  *instantiate୦୦lNode୦୮6୮7byte୦int
			failed *instantiate୦୦mainNode୦୮6୮7byte୦int

//line ctrie.go2:629
 prev *instantiate୦୦mainNode୦୮6୮7byte୦int
}
//line ctrie.go2:630
type instantiate୦୦cNode୦୮6୮7byte୦int struct {
//line ctrie.go2:636
 bmp uint32
	slice []branch
	gen   *generation
}

//line ctrie.go2:674
func (c *instantiate୦୦cNode୦୮6୮7byte୦int,) inserted(pos int, flag uint32, br branch, gen *generation) *instantiate୦୦cNode୦୮6୮7byte୦int {
	slice := make([]branch, len(c.slice)+1)
	copy(slice, c.slice[:pos])
	slice[pos] = br
	copy(slice[pos+1:], c.slice[pos:])
	return &instantiate୦୦cNode୦୮6୮7byte୦int{
		bmp:   c.bmp | flag,
		slice: slice,
		gen:   gen,
	}
}

//line ctrie.go2:687
func (c *instantiate୦୦cNode୦୮6୮7byte୦int,) updated(pos int, br branch, gen *generation) *instantiate୦୦cNode୦୮6୮7byte୦int {
	slice := make([]branch, len(c.slice))
	copy(slice, c.slice)
	slice[pos] = br
	return &instantiate୦୦cNode୦୮6୮7byte୦int{
		bmp:   c.bmp,
		slice: slice,
		gen:   gen,
	}
}

//line ctrie.go2:700
func (c *instantiate୦୦cNode୦୮6୮7byte୦int,) removed(pos int, flag uint32, gen *generation) *instantiate୦୦cNode୦୮6୮7byte୦int {
	slice := make([]branch, len(c.slice)-1)
	copy(slice, c.slice[0:pos])
	copy(slice[pos:], c.slice[pos+1:])
	return &instantiate୦୦cNode୦୮6୮7byte୦int{
		bmp:   c.bmp ^ flag,
		slice: slice,
		gen:   gen,
	}
}

//line ctrie.go2:713
func (c *instantiate୦୦cNode୦୮6୮7byte୦int,) renewed(gen *generation, ctrie *instantiate୦୦Map୦୮6୮7byte୦int,) *instantiate୦୦cNode୦୮6୮7byte୦int {
	slice := make([]branch, len(c.slice))
	for i, br := range c.slice {
		switch t := br.(type) {
		case *instantiate୦୦iNode୦୮6୮7byte୦int:
			slice[i] = t.copyToGen(gen, ctrie)
		default:
			slice[i] = br
		}
	}
	return &instantiate୦୦cNode୦୮6୮7byte୦int{
		bmp:   c.bmp,
		slice: slice,
		gen:   gen,
	}
}
//line ctrie.go2:130
func instantiate୦୦newMap୦୮6୮7byte୦int(
	root *instantiate୦୦iNode୦୮6୮7byte୦int,
	eqFunc func([]byte, []byte,

//line ctrie.go2:132
 ) bool,
	hashFunc func([]byte,

//line ctrie.go2:133
 ) uint64,
	readOnly bool,
) *instantiate୦୦Map୦୮6୮7byte୦int {
	return &instantiate୦୦Map୦୮6୮7byte୦int{
		root:     root,
		eqFunc:   eqFunc,
		hashFunc: hashFunc,
		readOnly: readOnly,
	}
}

//line ctrie.go2:142
type instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5 struct {
//line ctrie.go2:68
 root     *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5
			readOnly bool
			hashFunc func(

//line ctrie_test.go2:196
  []byte) uint64
//line ctrie.go2:71
 eqFunc func(

//line ctrie_test.go2:196
  []byte, []byte) bool
//line ctrie.go2:72
}

//line ctrie.go2:146
func (c *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) Set(key []byte, value interface{}) {
	c.assertReadWrite()
	c.insert(&instantiate୦୦mapEntry୦୮6୮7byte୦interface୮4୮5{
		key:   key,
		value: value,
		hash:  uint32(c.hashFunc(key)),
	})
}

//line ctrie.go2:157
func (c *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) Get(key []byte) (

//line ctrie_test.go2:196
 interface{}, bool) {
//line ctrie.go2:158
 return c.lookup(&instantiate୦୦mapEntry୦୮6୮7byte୦interface୮4୮5{
		key:  key,
		hash: uint32(c.hashFunc(key)),
	})
}

//line ctrie.go2:166
func (c *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) Delete(key []byte) (

//line ctrie_test.go2:196
 interface{}, bool) {
//line ctrie.go2:167
 c.assertReadWrite()
			return c.remove(&instantiate୦୦mapEntry୦୮6୮7byte୦interface୮4୮5{
		key:  key,
		hash: uint32(c.hashFunc(key)),
	})
}

//line ctrie.go2:176
func (c *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) Clone() *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5 {
	return c.clone(c.readOnly)
}

//line ctrie.go2:182
func (c *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) RClone() *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5 {
	return c.clone(true)
}

//line ctrie.go2:187
func (c *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) clone(readOnly bool) *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5 {
	if readOnly && c.readOnly {
		return c
	}
	for {
		root := c.readRoot()
		main := instantiate୦୦gcasRead୦୮6୮7byte୦interface୮4୮5(root, c)
		if c.rdcssRoot(root, main, root.copyToGen(&generation{}, c)) {
			if readOnly {

				return instantiate୦୦newMap୦୮6୮7byte୦interface୮4୮5(root, c.eqFunc, c.hashFunc, readOnly)
			}

			return instantiate୦୦newMap୦୮6୮7byte୦interface୮4୮5(c.readRoot().copyToGen(&generation{}, c), c.eqFunc, c.hashFunc, readOnly)
		}
	}
}

//line ctrie.go2:206
func (c *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) Clear() {
	c.assertReadWrite()
	for {
		root := c.readRoot()
		gen := &generation{}
		newRoot := &instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5{
			main: &instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5{cNode: &instantiate୦୦cNode୦୮6୮7byte୦interface୮4୮5{gen: gen}},
			gen:  gen,
		}
		if c.rdcssRoot(root, instantiate୦୦gcasRead୦୮6୮7byte୦interface୮4୮5(root, c), newRoot) {
			return
		}
	}
}

//line ctrie.go2:223
func (c *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) Len() int {

//line ctrie.go2:229
 size := 0
	for iter := c.Iterator(); iter.Next(); {
		size++
	}
	return size
}

//line ctrie.go2:237
func (c *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) Iterator() *instantiate୦୦Iter୦୮6୮7byte୦interface୮4୮5 {
	iter := &instantiate୦୦Iter୦୮6୮7byte୦interface୮4୮5{
		c: c,
	}
	iter.push((*instantiate୦୦Iter୦୮6୮7byte୦interface୮4୮5).mainIter).iNode = c.RClone().readRoot()
	return iter
}

//line ctrie.go2:355
func (c *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) assertReadWrite() {
	if c.readOnly {
		panic("Cannot modify read-only clone")
	}
}

func (c *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) insert(entry *instantiate୦୦mapEntry୦୮6୮7byte୦interface୮4୮5,) {
	root := c.readRoot()
	if !c.iinsert(root, entry, 0, nil, root.gen) {
		c.insert(entry)
	}
}

func (c *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) lookup(entry *instantiate୦୦mapEntry୦୮6୮7byte୦interface୮4୮5,) (interface{},

//line ctrie.go2:368
 bool) {
	root := c.readRoot()
	result, exists, ok := c.ilookup(root, entry, 0, nil, root.gen)
	for !ok {
		return c.lookup(entry)
	}
	return result, exists
}

func (c *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) remove(entry *instantiate୦୦mapEntry୦୮6୮7byte୦interface୮4୮5,) (interface{},

//line ctrie.go2:377
 bool) {
	root := c.readRoot()
	result, exists, ok := c.iremove(root, entry, 0, nil, root.gen)
	for !ok {
		return c.remove(entry)
	}
	return result, exists
}

//line ctrie.go2:388
func (c *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) iinsert(i *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5, entry *instantiate୦୦mapEntry୦୮6୮7byte୦interface୮4୮5, lev uint, parent *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5, startGen *generation) bool {

	main := instantiate୦୦gcasRead୦୮6୮7byte୦interface୮4୮5(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:399
   rn := cn
			if cn.gen != i.gen {
				rn = cn.renewed(i.gen, c)
			}
			ncn := &instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5{
				cNode: rn.inserted(pos, flag, &instantiate୦୦sNode୦୮6୮7byte୦interface୮4୮5{entry}, i.gen),
			}
			return instantiate୦୦gcas୦୮6୮7byte୦interface୮4୮5(i, main, ncn, c)
		}

//line ctrie.go2:410
  branch := cn.slice[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5:

			if startGen == branch.gen {
				return c.iinsert(branch, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦୮6୮7byte୦interface୮4୮5(i, main, &instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5{cNode: cn.renewed(startGen, c)}, c) {
				return c.iinsert(i, entry, lev, parent, startGen)
			}
			return false
		case *instantiate୦୦sNode୦୮6୮7byte୦interface୮4୮5:
			sn := branch
			if !c.eqFunc(sn.entry.key, entry.key) {

//line ctrie.go2:431
    rn := cn
				if cn.gen != i.gen {
					rn = cn.renewed(i.gen, c)
				}
				nsn := &instantiate୦୦sNode୦୮6୮7byte୦interface୮4୮5{entry}
				nin := &instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5{main: instantiate୦୦newMainNode୦୮6୮7byte୦interface୮4୮5(sn, sn.entry.hash, nsn, nsn.entry.hash, lev+w, i.gen), gen: i.gen}
				ncn := &instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5{cNode: rn.updated(pos, nin, i.gen)}
				return instantiate୦୦gcas୦୮6୮7byte୦interface୮4୮5(i, main, ncn, c)
			}

//line ctrie.go2:443
   ncn := &instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5{cNode: cn.updated(pos, &instantiate୦୦sNode୦୮6୮7byte୦interface୮4୮5{entry}, i.gen)}
			return instantiate୦୦gcas୦୮6୮7byte୦interface୮4୮5(i, main, ncn, c)
		default:
			panic("Map is in an invalid state")
		}
	case main.tNode != nil:
//line ctrie.go2:448
  instantiate୦୦clean୦୮6୮7byte୦interface୮4୮5(parent, lev-w, c)
//line ctrie.go2:450
  return false
	case main.lNode != nil:
		nln := &instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5{lNode: main.lNode.inserted(entry, c.eqFunc)}
		return instantiate୦୦gcas୦୮6୮7byte୦interface୮4୮5(i, main, nln, c)
	default:
		panic("Map is in an invalid state")
	}
}

//line ctrie.go2:463
func (c *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) ilookup(i *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5, entry *instantiate୦୦mapEntry୦୮6୮7byte୦interface୮4୮5, lev uint, parent *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5, startGen *generation) (interface{},

//line ctrie.go2:463
 bool, bool) {

	main := instantiate୦୦gcasRead୦୮6୮7byte୦interface୮4୮5(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:473
   return instantiate୦୦z୦interface୮4୮5(), false, true
		}

		branch := cn.slice[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5:

//line ctrie.go2:481
   in := branch
			if c.readOnly || startGen == in.gen {
				return c.ilookup(in, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦୮6୮7byte୦interface୮4୮5(i, main, &instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5{cNode: cn.renewed(startGen, c)}, c) {
				return c.ilookup(i, entry, lev, parent, startGen)
			}
			return instantiate୦୦z୦interface୮4୮5(), false, false
		case *instantiate୦୦sNode୦୮6୮7byte୦interface୮4୮5:

//line ctrie.go2:495
   sn := branch
			if c.eqFunc(sn.entry.key, entry.key) {
				return sn.entry.value, true, true
			}
			return instantiate୦୦z୦interface୮4୮5(), false, true
		default:
			panic("Map is in an invalid state")
		}
	case main.tNode != nil:
		return instantiate୦୦cleanReadOnly୦୮6୮7byte୦interface୮4୮5(main.tNode, lev, parent, c, entry)
	case main.lNode != nil:

//line ctrie.go2:508
  val, ok := main.lNode.lookup(entry, c.eqFunc)
		return val, ok, true
	default:
		panic("Map is in an invalid state")
	}
}

//line ctrie.go2:519
func (c *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) iremove(i *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5, entry *instantiate୦୦mapEntry୦୮6୮7byte୦interface୮4୮5, lev uint, parent *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5, startGen *generation) (interface{},

//line ctrie.go2:519
 bool, bool) {

	main := instantiate୦୦gcasRead୦୮6୮7byte୦interface୮4୮5(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:529
   return instantiate୦୦z୦interface୮4୮5(), false, true
		}

		branch := cn.slice[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5:

//line ctrie.go2:537
   in := branch
			if startGen == in.gen {
				return c.iremove(in, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦୮6୮7byte୦interface୮4୮5(i, main, &instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5{cNode: cn.renewed(startGen, c)}, c) {
				return c.iremove(i, entry, lev, parent, startGen)
			}
			return instantiate୦୦z୦interface୮4୮5(), false, false
		case *instantiate୦୦sNode୦୮6୮7byte୦interface୮4୮5:

//line ctrie.go2:548
   sn := branch
			if !c.eqFunc(sn.entry.key, entry.key) {

				return instantiate୦୦z୦interface୮4୮5(), false, true
			}

//line ctrie.go2:559
   ncn := cn.removed(pos, flag, i.gen)
			cntr := instantiate୦୦toContracted୦୮6୮7byte୦interface୮4୮5(ncn, lev)
			if instantiate୦୦gcas୦୮6୮7byte୦interface୮4୮5(i, main, cntr, c) {
				if parent != nil {
					main = instantiate୦୦gcasRead୦୮6୮7byte୦interface୮4୮5(i, c)
					if main.tNode != nil {
//line ctrie.go2:564
      instantiate୦୦cleanParent୦୮6୮7byte୦interface୮4୮5(parent, i, entry.hash, lev-w, c, startGen)
//line ctrie.go2:566
     }
				}
				return sn.entry.value, true, true
			}
			return instantiate୦୦z୦interface୮4୮5(), false, false
		default:
			panic("Map is in an invalid state")
		}
	case main.tNode != nil:
//line ctrie.go2:574
  instantiate୦୦clean୦୮6୮7byte୦interface୮4୮5(parent, lev-w, c)
//line ctrie.go2:576
  return instantiate୦୦z୦interface୮4୮5(), false, false
	case main.lNode != nil:
		nln := &instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5{
			lNode: main.lNode.removed(entry, c.eqFunc),
		}
		if nln.lNode != nil && nln.lNode.tail == nil {

			nln = instantiate୦୦entomb୦୮6୮7byte୦interface୮4୮5(nln.lNode.head)
		}
		if instantiate୦୦gcas୦୮6୮7byte୦interface୮4୮5(i, main, nln, c) {
			val, ok := main.lNode.lookup(entry, c.eqFunc)
			return val, ok, true
		}
		return instantiate୦୦z୦interface୮4୮5(), false, true
	default:
		panic("Map is in an invalid state")
	}
}

//line ctrie.go2:976
func (c *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) readRoot() *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5 {
	return c.rdcssReadRoot(false)
}

//line ctrie.go2:982
func (c *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) rdcssReadRoot(abort bool) *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5 {
	r := instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8୮6୮7byte୮3୮0interface୮4୮5୮9(&c.root)
	if r.rdcss != nil {
		return c.rdcssComplete(abort)
	}
	return r
}

//line ctrie.go2:993
func (c *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) rdcssRoot(old *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5, expected *instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5, nv *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5,) bool {
	desc := &instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5{
		rdcss: &instantiate୦୦rdcssDescriptor୦୮6୮7byte୦interface୮4୮5{
			old:      old,
			expected: expected,
			nv:       nv,
		},
	}
	if c.casRoot(old, desc) {
		c.rdcssComplete(false)
		return gatomic.LoadInt32(&desc.rdcss.committed) == 1
	}
	return false
}

//line ctrie.go2:1009
func (c *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) rdcssComplete(abort bool) *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5 {
	for {
		r := instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8୮6୮7byte୮3୮0interface୮4୮5୮9(&c.root)
		if r.rdcss == nil {
			return r
		}
		desc := r.rdcss
		ov := desc.old
		exp := desc.expected
		nv := desc.nv
		if abort {
			if c.casRoot(r, ov) {
				return ov
			}
			continue
		}
		oldeMain := instantiate୦୦gcasRead୦୮6୮7byte୦interface୮4୮5(ov, c)
		if oldeMain == exp {

			if c.casRoot(r, nv) {
				gatomic.StoreInt32(&desc.committed, 1)
				return nv
			}
			continue
		}
		if c.casRoot(r, ov) {
			return ov
		}
	}
}

//line ctrie.go2:1041
func (c *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) casRoot(ov, nv *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5,) bool {
	c.assertReadWrite()
	return instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮aiNode୮8୮6୮7byte୮3୮0interface୮4୮5୮9(&c.root, ov, nv)
}

//line ctrie.go2:1044
type instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5 struct {
//line ctrie.go2:600
 main *instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5
			gen  *generation

//line ctrie.go2:606
 rdcss *instantiate୦୦rdcssDescriptor୦୮6୮7byte୦interface୮4୮5
}

//line ctrie.go2:610
func (i *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5,) copyToGen(gen *generation, ctrie *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5 {
			nin := &instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5{gen: gen}
			main := instantiate୦୦gcasRead୦୮6୮7byte୦interface୮4୮5(i, ctrie)
//line ctrie.go2:612
 instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0interface୮4୮5୮9(&nin.main, main)
//line ctrie.go2:614
 return nin
}

//line ctrie.go2:615
type instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5 struct {
//line ctrie.go2:620
 cNode *instantiate୦୦cNode୦୮6୮7byte୦interface୮4୮5
			tNode  *instantiate୦୦tNode୦୮6୮7byte୦interface୮4୮5
			lNode  *instantiate୦୦lNode୦୮6୮7byte୦interface୮4୮5
			failed *instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5

//line ctrie.go2:629
 prev *instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5
}
//line ctrie.go2:630
type instantiate୦୦cNode୦୮6୮7byte୦interface୮4୮5 struct {
//line ctrie.go2:636
 bmp uint32
	slice []branch
	gen   *generation
}

//line ctrie.go2:674
func (c *instantiate୦୦cNode୦୮6୮7byte୦interface୮4୮5,) inserted(pos int, flag uint32, br branch, gen *generation) *instantiate୦୦cNode୦୮6୮7byte୦interface୮4୮5 {
	slice := make([]branch, len(c.slice)+1)
	copy(slice, c.slice[:pos])
	slice[pos] = br
	copy(slice[pos+1:], c.slice[pos:])
	return &instantiate୦୦cNode୦୮6୮7byte୦interface୮4୮5{
		bmp:   c.bmp | flag,
		slice: slice,
		gen:   gen,
	}
}

//line ctrie.go2:687
func (c *instantiate୦୦cNode୦୮6୮7byte୦interface୮4୮5,) updated(pos int, br branch, gen *generation) *instantiate୦୦cNode୦୮6୮7byte୦interface୮4୮5 {
	slice := make([]branch, len(c.slice))
	copy(slice, c.slice)
	slice[pos] = br
	return &instantiate୦୦cNode୦୮6୮7byte୦interface୮4୮5{
		bmp:   c.bmp,
		slice: slice,
		gen:   gen,
	}
}

//line ctrie.go2:700
func (c *instantiate୦୦cNode୦୮6୮7byte୦interface୮4୮5,) removed(pos int, flag uint32, gen *generation) *instantiate୦୦cNode୦୮6୮7byte୦interface୮4୮5 {
	slice := make([]branch, len(c.slice)-1)
	copy(slice, c.slice[0:pos])
	copy(slice[pos:], c.slice[pos+1:])
	return &instantiate୦୦cNode୦୮6୮7byte୦interface୮4୮5{
		bmp:   c.bmp ^ flag,
		slice: slice,
		gen:   gen,
	}
}

//line ctrie.go2:713
func (c *instantiate୦୦cNode୦୮6୮7byte୦interface୮4୮5,) renewed(gen *generation, ctrie *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) *instantiate୦୦cNode୦୮6୮7byte୦interface୮4୮5 {
	slice := make([]branch, len(c.slice))
	for i, br := range c.slice {
		switch t := br.(type) {
		case *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5:
			slice[i] = t.copyToGen(gen, ctrie)
		default:
			slice[i] = br
		}
	}
	return &instantiate୦୦cNode୦୮6୮7byte୦interface୮4୮5{
		bmp:   c.bmp,
		slice: slice,
		gen:   gen,
	}
}
//line ctrie.go2:130
func instantiate୦୦newMap୦୮6୮7byte୦interface୮4୮5(
	root *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5,
	eqFunc func(

//line ctrie_test.go2:196
  []byte, []byte) bool,
//line ctrie.go2:133
 hashFunc func(

//line ctrie_test.go2:196
  []byte) uint64,
//line ctrie.go2:134
 readOnly bool,
) *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5 {
	return &instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5{
		root:     root,
		eqFunc:   eqFunc,
		hashFunc: hashFunc,
		readOnly: readOnly,
	}
}

//line ctrie.go2:142
type instantiate୦୦Map୦୮6୮7byte୦bool struct {
//line ctrie.go2:68
 root     *instantiate୦୦iNode୦୮6୮7byte୦bool
			readOnly bool
			hashFunc func(

//line ctrie_test.go2:355
  []byte) uint64
//line ctrie.go2:71
 eqFunc func(

//line ctrie_test.go2:355
  []byte, []byte) bool
//line ctrie.go2:72
}

//line ctrie.go2:146
func (c *instantiate୦୦Map୦୮6୮7byte୦bool,) Set(key []byte, value bool) {
	c.assertReadWrite()
	c.insert(&instantiate୦୦mapEntry୦୮6୮7byte୦bool{
		key:   key,
		value: value,
		hash:  uint32(c.hashFunc(key)),
	})
}

//line ctrie.go2:157
func (c *instantiate୦୦Map୦୮6୮7byte୦bool,) Get(key []byte) (

//line ctrie_test.go2:355
 bool, bool) {
//line ctrie.go2:158
 return c.lookup(&instantiate୦୦mapEntry୦୮6୮7byte୦bool{
		key:  key,
		hash: uint32(c.hashFunc(key)),
	})
}

//line ctrie.go2:166
func (c *instantiate୦୦Map୦୮6୮7byte୦bool,) Delete(key []byte) (

//line ctrie_test.go2:355
 bool, bool) {
//line ctrie.go2:167
 c.assertReadWrite()
			return c.remove(&instantiate୦୦mapEntry୦୮6୮7byte୦bool{
		key:  key,
		hash: uint32(c.hashFunc(key)),
	})
}

//line ctrie.go2:176
func (c *instantiate୦୦Map୦୮6୮7byte୦bool,) Clone() *instantiate୦୦Map୦୮6୮7byte୦bool {
	return c.clone(c.readOnly)
}

//line ctrie.go2:182
func (c *instantiate୦୦Map୦୮6୮7byte୦bool,) RClone() *instantiate୦୦Map୦୮6୮7byte୦bool {
	return c.clone(true)
}

//line ctrie.go2:187
func (c *instantiate୦୦Map୦୮6୮7byte୦bool,) clone(readOnly bool) *instantiate୦୦Map୦୮6୮7byte୦bool {
	if readOnly && c.readOnly {
		return c
	}
	for {
		root := c.readRoot()
		main := instantiate୦୦gcasRead୦୮6୮7byte୦bool(root, c)
		if c.rdcssRoot(root, main, root.copyToGen(&generation{}, c)) {
			if readOnly {

				return instantiate୦୦newMap୦୮6୮7byte୦bool(root, c.eqFunc, c.hashFunc, readOnly)
			}

			return instantiate୦୦newMap୦୮6୮7byte୦bool(c.readRoot().copyToGen(&generation{}, c), c.eqFunc, c.hashFunc, readOnly)
		}
	}
}

//line ctrie.go2:206
func (c *instantiate୦୦Map୦୮6୮7byte୦bool,) Clear() {
	c.assertReadWrite()
	for {
		root := c.readRoot()
		gen := &generation{}
		newRoot := &instantiate୦୦iNode୦୮6୮7byte୦bool{
			main: &instantiate୦୦mainNode୦୮6୮7byte୦bool{cNode: &instantiate୦୦cNode୦୮6୮7byte୦bool{gen: gen}},
			gen:  gen,
		}
		if c.rdcssRoot(root, instantiate୦୦gcasRead୦୮6୮7byte୦bool(root, c), newRoot) {
			return
		}
	}
}

//line ctrie.go2:223
func (c *instantiate୦୦Map୦୮6୮7byte୦bool,) Len() int {

//line ctrie.go2:229
 size := 0
	for iter := c.Iterator(); iter.Next(); {
		size++
	}
	return size
}

//line ctrie.go2:237
func (c *instantiate୦୦Map୦୮6୮7byte୦bool,) Iterator() *instantiate୦୦Iter୦୮6୮7byte୦bool {
	iter := &instantiate୦୦Iter୦୮6୮7byte୦bool{
		c: c,
	}
	iter.push((*instantiate୦୦Iter୦୮6୮7byte୦bool).mainIter).iNode = c.RClone().readRoot()
	return iter
}

//line ctrie.go2:355
func (c *instantiate୦୦Map୦୮6୮7byte୦bool,) assertReadWrite() {
	if c.readOnly {
		panic("Cannot modify read-only clone")
	}
}

func (c *instantiate୦୦Map୦୮6୮7byte୦bool,) insert(entry *instantiate୦୦mapEntry୦୮6୮7byte୦bool,) {
	root := c.readRoot()
	if !c.iinsert(root, entry, 0, nil, root.gen) {
		c.insert(entry)
	}
}

func (c *instantiate୦୦Map୦୮6୮7byte୦bool,) lookup(entry *instantiate୦୦mapEntry୦୮6୮7byte୦bool,) (bool,

//line ctrie.go2:368
 bool) {
	root := c.readRoot()
	result, exists, ok := c.ilookup(root, entry, 0, nil, root.gen)
	for !ok {
		return c.lookup(entry)
	}
	return result, exists
}

func (c *instantiate୦୦Map୦୮6୮7byte୦bool,) remove(entry *instantiate୦୦mapEntry୦୮6୮7byte୦bool,) (bool,

//line ctrie.go2:377
 bool) {
	root := c.readRoot()
	result, exists, ok := c.iremove(root, entry, 0, nil, root.gen)
	for !ok {
		return c.remove(entry)
	}
	return result, exists
}

//line ctrie.go2:388
func (c *instantiate୦୦Map୦୮6୮7byte୦bool,) iinsert(i *instantiate୦୦iNode୦୮6୮7byte୦bool, entry *instantiate୦୦mapEntry୦୮6୮7byte୦bool, lev uint, parent *instantiate୦୦iNode୦୮6୮7byte୦bool, startGen *generation) bool {

	main := instantiate୦୦gcasRead୦୮6୮7byte୦bool(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:399
   rn := cn
			if cn.gen != i.gen {
				rn = cn.renewed(i.gen, c)
			}
			ncn := &instantiate୦୦mainNode୦୮6୮7byte୦bool{
				cNode: rn.inserted(pos, flag, &instantiate୦୦sNode୦୮6୮7byte୦bool{entry}, i.gen),
			}
			return instantiate୦୦gcas୦୮6୮7byte୦bool(i, main, ncn, c)
		}

//line ctrie.go2:410
  branch := cn.slice[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦୮6୮7byte୦bool:

			if startGen == branch.gen {
				return c.iinsert(branch, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦୮6୮7byte୦bool(i, main, &instantiate୦୦mainNode୦୮6୮7byte୦bool{cNode: cn.renewed(startGen, c)}, c) {
				return c.iinsert(i, entry, lev, parent, startGen)
			}
			return false
		case *instantiate୦୦sNode୦୮6୮7byte୦bool:
			sn := branch
			if !c.eqFunc(sn.entry.key, entry.key) {

//line ctrie.go2:431
    rn := cn
				if cn.gen != i.gen {
					rn = cn.renewed(i.gen, c)
				}
				nsn := &instantiate୦୦sNode୦୮6୮7byte୦bool{entry}
				nin := &instantiate୦୦iNode୦୮6୮7byte୦bool{main: instantiate୦୦newMainNode୦୮6୮7byte୦bool(sn, sn.entry.hash, nsn, nsn.entry.hash, lev+w, i.gen), gen: i.gen}
				ncn := &instantiate୦୦mainNode୦୮6୮7byte୦bool{cNode: rn.updated(pos, nin, i.gen)}
				return instantiate୦୦gcas୦୮6୮7byte୦bool(i, main, ncn, c)
			}

//line ctrie.go2:443
   ncn := &instantiate୦୦mainNode୦୮6୮7byte୦bool{cNode: cn.updated(pos, &instantiate୦୦sNode୦୮6୮7byte୦bool{entry}, i.gen)}
			return instantiate୦୦gcas୦୮6୮7byte୦bool(i, main, ncn, c)
		default:
			panic("Map is in an invalid state")
		}
	case main.tNode != nil:
//line ctrie.go2:448
  instantiate୦୦clean୦୮6୮7byte୦bool(parent, lev-w, c)
//line ctrie.go2:450
  return false
	case main.lNode != nil:
		nln := &instantiate୦୦mainNode୦୮6୮7byte୦bool{lNode: main.lNode.inserted(entry, c.eqFunc)}
		return instantiate୦୦gcas୦୮6୮7byte୦bool(i, main, nln, c)
	default:
		panic("Map is in an invalid state")
	}
}

//line ctrie.go2:463
func (c *instantiate୦୦Map୦୮6୮7byte୦bool,) ilookup(i *instantiate୦୦iNode୦୮6୮7byte୦bool, entry *instantiate୦୦mapEntry୦୮6୮7byte୦bool, lev uint, parent *instantiate୦୦iNode୦୮6୮7byte୦bool, startGen *generation) (bool,

//line ctrie.go2:463
 bool, bool) {

	main := instantiate୦୦gcasRead୦୮6୮7byte୦bool(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:473
   return instantiate୦୦z୦bool(), false, true
		}

		branch := cn.slice[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦୮6୮7byte୦bool:

//line ctrie.go2:481
   in := branch
			if c.readOnly || startGen == in.gen {
				return c.ilookup(in, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦୮6୮7byte୦bool(i, main, &instantiate୦୦mainNode୦୮6୮7byte୦bool{cNode: cn.renewed(startGen, c)}, c) {
				return c.ilookup(i, entry, lev, parent, startGen)
			}
			return instantiate୦୦z୦bool(), false, false
		case *instantiate୦୦sNode୦୮6୮7byte୦bool:

//line ctrie.go2:495
   sn := branch
			if c.eqFunc(sn.entry.key, entry.key) {
				return sn.entry.value, true, true
			}
			return instantiate୦୦z୦bool(), false, true
		default:
			panic("Map is in an invalid state")
		}
	case main.tNode != nil:
		return instantiate୦୦cleanReadOnly୦୮6୮7byte୦bool(main.tNode, lev, parent, c, entry)
	case main.lNode != nil:

//line ctrie.go2:508
  val, ok := main.lNode.lookup(entry, c.eqFunc)
		return val, ok, true
	default:
		panic("Map is in an invalid state")
	}
}

//line ctrie.go2:519
func (c *instantiate୦୦Map୦୮6୮7byte୦bool,) iremove(i *instantiate୦୦iNode୦୮6୮7byte୦bool, entry *instantiate୦୦mapEntry୦୮6୮7byte୦bool, lev uint, parent *instantiate୦୦iNode୦୮6୮7byte୦bool, startGen *generation) (bool,

//line ctrie.go2:519
 bool, bool) {

	main := instantiate୦୦gcasRead୦୮6୮7byte୦bool(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:529
   return instantiate୦୦z୦bool(), false, true
		}

		branch := cn.slice[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦୮6୮7byte୦bool:

//line ctrie.go2:537
   in := branch
			if startGen == in.gen {
				return c.iremove(in, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦୮6୮7byte୦bool(i, main, &instantiate୦୦mainNode୦୮6୮7byte୦bool{cNode: cn.renewed(startGen, c)}, c) {
				return c.iremove(i, entry, lev, parent, startGen)
			}
			return instantiate୦୦z୦bool(), false, false
		case *instantiate୦୦sNode୦୮6୮7byte୦bool:

//line ctrie.go2:548
   sn := branch
			if !c.eqFunc(sn.entry.key, entry.key) {

				return instantiate୦୦z୦bool(), false, true
			}

//line ctrie.go2:559
   ncn := cn.removed(pos, flag, i.gen)
			cntr := instantiate୦୦toContracted୦୮6୮7byte୦bool(ncn, lev)
			if instantiate୦୦gcas୦୮6୮7byte୦bool(i, main, cntr, c) {
				if parent != nil {
					main = instantiate୦୦gcasRead୦୮6୮7byte୦bool(i, c)
					if main.tNode != nil {
//line ctrie.go2:564
      instantiate୦୦cleanParent୦୮6୮7byte୦bool(parent, i, entry.hash, lev-w, c, startGen)
//line ctrie.go2:566
     }
				}
				return sn.entry.value, true, true
			}
			return instantiate୦୦z୦bool(), false, false
		default:
			panic("Map is in an invalid state")
		}
	case main.tNode != nil:
//line ctrie.go2:574
  instantiate୦୦clean୦୮6୮7byte୦bool(parent, lev-w, c)
//line ctrie.go2:576
  return instantiate୦୦z୦bool(), false, false
	case main.lNode != nil:
		nln := &instantiate୦୦mainNode୦୮6୮7byte୦bool{
			lNode: main.lNode.removed(entry, c.eqFunc),
		}
		if nln.lNode != nil && nln.lNode.tail == nil {

			nln = instantiate୦୦entomb୦୮6୮7byte୦bool(nln.lNode.head)
		}
		if instantiate୦୦gcas୦୮6୮7byte୦bool(i, main, nln, c) {
			val, ok := main.lNode.lookup(entry, c.eqFunc)
			return val, ok, true
		}
		return instantiate୦୦z୦bool(), false, true
	default:
		panic("Map is in an invalid state")
	}
}

//line ctrie.go2:976
func (c *instantiate୦୦Map୦୮6୮7byte୦bool,) readRoot() *instantiate୦୦iNode୦୮6୮7byte୦bool {
	return c.rdcssReadRoot(false)
}

//line ctrie.go2:982
func (c *instantiate୦୦Map୦୮6୮7byte୦bool,) rdcssReadRoot(abort bool) *instantiate୦୦iNode୦୮6୮7byte୦bool {
	r := instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8୮6୮7byte୮3୮0bool୮9(&c.root)
	if r.rdcss != nil {
		return c.rdcssComplete(abort)
	}
	return r
}

//line ctrie.go2:993
func (c *instantiate୦୦Map୦୮6୮7byte୦bool,) rdcssRoot(old *instantiate୦୦iNode୦୮6୮7byte୦bool, expected *instantiate୦୦mainNode୦୮6୮7byte୦bool, nv *instantiate୦୦iNode୦୮6୮7byte୦bool,) bool {
	desc := &instantiate୦୦iNode୦୮6୮7byte୦bool{
		rdcss: &instantiate୦୦rdcssDescriptor୦୮6୮7byte୦bool{
			old:      old,
			expected: expected,
			nv:       nv,
		},
	}
	if c.casRoot(old, desc) {
		c.rdcssComplete(false)
		return gatomic.LoadInt32(&desc.rdcss.committed) == 1
	}
	return false
}

//line ctrie.go2:1009
func (c *instantiate୦୦Map୦୮6୮7byte୦bool,) rdcssComplete(abort bool) *instantiate୦୦iNode୦୮6୮7byte୦bool {
	for {
		r := instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8୮6୮7byte୮3୮0bool୮9(&c.root)
		if r.rdcss == nil {
			return r
		}
		desc := r.rdcss
		ov := desc.old
		exp := desc.expected
		nv := desc.nv
		if abort {
			if c.casRoot(r, ov) {
				return ov
			}
			continue
		}
		oldeMain := instantiate୦୦gcasRead୦୮6୮7byte୦bool(ov, c)
		if oldeMain == exp {

			if c.casRoot(r, nv) {
				gatomic.StoreInt32(&desc.committed, 1)
				return nv
			}
			continue
		}
		if c.casRoot(r, ov) {
			return ov
		}
	}
}

//line ctrie.go2:1041
func (c *instantiate୦୦Map୦୮6୮7byte୦bool,) casRoot(ov, nv *instantiate୦୦iNode୦୮6୮7byte୦bool,) bool {
	c.assertReadWrite()
	return instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮aiNode୮8୮6୮7byte୮3୮0bool୮9(&c.root, ov, nv)
}

//line ctrie.go2:1044
type instantiate୦୦iNode୦୮6୮7byte୦bool struct {
//line ctrie.go2:600
 main *instantiate୦୦mainNode୦୮6୮7byte୦bool
			gen  *generation

//line ctrie.go2:606
 rdcss *instantiate୦୦rdcssDescriptor୦୮6୮7byte୦bool
}

//line ctrie.go2:610
func (i *instantiate୦୦iNode୦୮6୮7byte୦bool,) copyToGen(gen *generation, ctrie *instantiate୦୦Map୦୮6୮7byte୦bool,) *instantiate୦୦iNode୦୮6୮7byte୦bool {
			nin := &instantiate୦୦iNode୦୮6୮7byte୦bool{gen: gen}
			main := instantiate୦୦gcasRead୦୮6୮7byte୦bool(i, ctrie)
//line ctrie.go2:612
 instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0bool୮9(&nin.main, main)
//line ctrie.go2:614
 return nin
}

//line ctrie.go2:615
type instantiate୦୦mainNode୦୮6୮7byte୦bool struct {
//line ctrie.go2:620
 cNode *instantiate୦୦cNode୦୮6୮7byte୦bool
			tNode  *instantiate୦୦tNode୦୮6୮7byte୦bool
			lNode  *instantiate୦୦lNode୦୮6୮7byte୦bool
			failed *instantiate୦୦mainNode୦୮6୮7byte୦bool

//line ctrie.go2:629
 prev *instantiate୦୦mainNode୦୮6୮7byte୦bool
}
//line ctrie.go2:630
type instantiate୦୦cNode୦୮6୮7byte୦bool struct {
//line ctrie.go2:636
 bmp uint32
	slice []branch
	gen   *generation
}

//line ctrie.go2:674
func (c *instantiate୦୦cNode୦୮6୮7byte୦bool,) inserted(pos int, flag uint32, br branch, gen *generation) *instantiate୦୦cNode୦୮6୮7byte୦bool {
	slice := make([]branch, len(c.slice)+1)
	copy(slice, c.slice[:pos])
	slice[pos] = br
	copy(slice[pos+1:], c.slice[pos:])
	return &instantiate୦୦cNode୦୮6୮7byte୦bool{
		bmp:   c.bmp | flag,
		slice: slice,
		gen:   gen,
	}
}

//line ctrie.go2:687
func (c *instantiate୦୦cNode୦୮6୮7byte୦bool,) updated(pos int, br branch, gen *generation) *instantiate୦୦cNode୦୮6୮7byte୦bool {
	slice := make([]branch, len(c.slice))
	copy(slice, c.slice)
	slice[pos] = br
	return &instantiate୦୦cNode୦୮6୮7byte୦bool{
		bmp:   c.bmp,
		slice: slice,
		gen:   gen,
	}
}

//line ctrie.go2:700
func (c *instantiate୦୦cNode୦୮6୮7byte୦bool,) removed(pos int, flag uint32, gen *generation) *instantiate୦୦cNode୦୮6୮7byte୦bool {
	slice := make([]branch, len(c.slice)-1)
	copy(slice, c.slice[0:pos])
	copy(slice[pos:], c.slice[pos+1:])
	return &instantiate୦୦cNode୦୮6୮7byte୦bool{
		bmp:   c.bmp ^ flag,
		slice: slice,
		gen:   gen,
	}
}

//line ctrie.go2:713
func (c *instantiate୦୦cNode୦୮6୮7byte୦bool,) renewed(gen *generation, ctrie *instantiate୦୦Map୦୮6୮7byte୦bool,) *instantiate୦୦cNode୦୮6୮7byte୦bool {
	slice := make([]branch, len(c.slice))
	for i, br := range c.slice {
		switch t := br.(type) {
		case *instantiate୦୦iNode୦୮6୮7byte୦bool:
			slice[i] = t.copyToGen(gen, ctrie)
		default:
			slice[i] = br
		}
	}
	return &instantiate୦୦cNode୦୮6୮7byte୦bool{
		bmp:   c.bmp,
		slice: slice,
		gen:   gen,
	}
}
//line ctrie.go2:130
func instantiate୦୦newMap୦୮6୮7byte୦bool(
	root *instantiate୦୦iNode୦୮6୮7byte୦bool,
	eqFunc func(

//line ctrie_test.go2:355
  []byte, []byte) bool,
//line ctrie.go2:133
 hashFunc func(

//line ctrie_test.go2:355
  []byte) uint64,
//line ctrie.go2:134
 readOnly bool,
) *instantiate୦୦Map୦୮6୮7byte୦bool {
	return &instantiate୦୦Map୦୮6୮7byte୦bool{
		root:     root,
		eqFunc:   eqFunc,
		hashFunc: hashFunc,
		readOnly: readOnly,
	}
}

//line ctrie.go2:142
type instantiate୦୦mapEntry୦୮6୮7byte୦string struct {
//line ctrie.go2:796
 key []byte

//line ctrie.go2:797
 value string

//line ctrie.go2:798
 hash uint32
}

//line ctrie.go2:917
func instantiate୦୦gcasRead୦୮6୮7byte୦string(in *instantiate୦୦iNode୦୮6୮7byte୦string, ctrie *instantiate୦୦Map୦୮6୮7byte୦string,) *instantiate୦୦mainNode୦୮6୮7byte୦string {
	m := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0string୮9(&in.main)
	if instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0string୮9(&m.prev) == nil {
		return m
	}
	return instantiate୦୦gcasComplete୦୮6୮7byte୦string(in, m, ctrie)
}

//line ctrie.go2:923
type instantiate୦୦Iter୦୮6୮7byte୦string struct {
//line ctrie.go2:247
 c *instantiate୦୦Map୦୮6୮7byte୦string

//line ctrie.go2:251
 stack []instantiate୦୦iterFrame୦୮6୮7byte୦string
	curr *instantiate୦୦mapEntry୦୮6୮7byte୦string
}

//line ctrie.go2:265
func (i *instantiate୦୦Iter୦୮6୮7byte୦string,) Next() bool {
	i.curr = nil
	for i.curr == nil && len(i.stack) > 0 {
		if f := &i.stack[len(i.stack)-1]; !f.iter(i, f) {
			i.pop()
		}
	}
	return i.curr != nil
}

func (i *instantiate୦୦Iter୦୮6୮7byte୦string,) Value() string {
	if i.curr == nil {
		return instantiate୦୦z୦string()
	}
	return i.curr.value
}

func (i *instantiate୦୦Iter୦୮6୮7byte୦string,) Key() []byte {
	if i.curr == nil {
		return instantiate୦୦z୦୮6୮7byte()
	}
	return i.curr.key
}

//line ctrie.go2:290
func (i *instantiate୦୦Iter୦୮6୮7byte୦string,) mainIter(f *instantiate୦୦iterFrame୦୮6୮7byte୦string,) bool {
	if f.iNode == nil {
		return false
	}
	main := instantiate୦୦gcasRead୦୮6୮7byte୦string(f.iNode, i.c)
	f.iNode = nil
	switch {
	case main.cNode != nil:
		i.push((*instantiate୦୦Iter୦୮6୮7byte୦string).sliceIter).slice = main.cNode.slice
		return true
	case main.lNode != nil:
		i.push((*instantiate୦୦Iter୦୮6୮7byte୦string).listIter).lNode = main.lNode
		return true
	case main.tNode != nil:
		i.curr = main.tNode.sNode.entry
		return true
	}
	panic("unreachable")
}

//line ctrie.go2:311
func (i *instantiate୦୦Iter୦୮6୮7byte୦string,) sliceIter(f *instantiate୦୦iterFrame୦୮6୮7byte୦string,) bool {
	a := f.slice
	if len(a) == 0 {
		return false
	}
	f.slice = a[1:]
	switch b := a[0].(type) {
	case *instantiate୦୦iNode୦୮6୮7byte୦string:
		i.push((*instantiate୦୦Iter୦୮6୮7byte୦string).mainIter).iNode = b
		return true
	case *instantiate୦୦sNode୦୮6୮7byte୦string:
		i.curr = b.entry
		return true
	}
	panic("unreachable")
}

//line ctrie.go2:329
func (i *instantiate୦୦Iter୦୮6୮7byte୦string,) listIter(f *instantiate୦୦iterFrame୦୮6୮7byte୦string,) bool {
	l := f.lNode
	if l == nil {
		return false
	}
	f.lNode = f.lNode.tail
	i.curr = l.head.entry
	return true
}

//line ctrie.go2:340
func (i *instantiate୦୦Iter୦୮6୮7byte୦string,) pop() {
	i.stack = i.stack[0 : len(i.stack)-1]
}

//line ctrie.go2:348
func (i *instantiate୦୦Iter୦୮6୮7byte୦string,) push(f func(*instantiate୦୦Iter୦୮6୮7byte୦string, *instantiate୦୦iterFrame୦୮6୮7byte୦string,) bool) *instantiate୦୦iterFrame୦୮6୮7byte୦string {
	i.stack = append(i.stack, instantiate୦୦iterFrame୦୮6୮7byte୦string{})
	elem := &i.stack[len(i.stack)-1]
	elem.iter = f
	return elem
}

//line ctrie.go2:353
type instantiate୦୦sNode୦୮6୮7byte୦string struct {
//line ctrie.go2:803
 entry *instantiate୦୦mapEntry୦୮6୮7byte୦string
}

//line ctrie.go2:907
func instantiate୦୦gcas୦୮6୮7byte୦string(in *instantiate୦୦iNode୦୮6୮7byte୦string, old, n *instantiate୦୦mainNode୦୮6୮7byte୦string, ct *instantiate୦୦Map୦୮6୮7byte୦string,) bool {
//line ctrie.go2:907
 instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0string୮9(&n.prev, old)
//line ctrie.go2:909
 if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0string୮9(&in.main, old, n) {
//line ctrie.go2:909
  instantiate୦୦gcasComplete୦୮6୮7byte୦string(in, n, ct)
//line ctrie.go2:911
  return instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0string୮9(&n.prev) == nil
	}
	return false
}
//line ctrie.go2:645
func instantiate୦୦newMainNode୦୮6୮7byte୦string(x *instantiate୦୦sNode୦୮6୮7byte୦string, xhc uint32, y *instantiate୦୦sNode୦୮6୮7byte୦string, yhc uint32, lev uint, gen *generation) *instantiate୦୦mainNode୦୮6୮7byte୦string {
	if lev >= exp2 {
		return &instantiate୦୦mainNode୦୮6୮7byte୦string{
			lNode: &instantiate୦୦lNode୦୮6୮7byte୦string{
				head: y,
				tail: &instantiate୦୦lNode୦୮6୮7byte୦string{
					head: x,
				},
			},
		}
	}
	xidx := (xhc >> lev) & 0x1f
	yidx := (yhc >> lev) & 0x1f
	bmp := uint32((1 << xidx) | (1 << yidx))

	switch {
	case xidx == yidx:

		main := instantiate୦୦newMainNode୦୮6୮7byte୦string(x, xhc, y, yhc, lev+w, gen)
		iNode := &instantiate୦୦iNode୦୮6୮7byte୦string{main: main, gen: gen}
		return &instantiate୦୦mainNode୦୮6୮7byte୦string{cNode: &instantiate୦୦cNode୦୮6୮7byte୦string{bmp, []branch{iNode}, gen}}
	case xidx < yidx:
		return &instantiate୦୦mainNode୦୮6୮7byte୦string{cNode: &instantiate୦୦cNode୦୮6୮7byte୦string{bmp, []branch{x, y}, gen}}
	default:
		return &instantiate୦୦mainNode୦୮6୮7byte୦string{cNode: &instantiate୦୦cNode୦୮6୮7byte୦string{bmp, []branch{y, x}, gen}}
	}
}

//line ctrie.go2:855
func instantiate୦୦clean୦୮6୮7byte୦string(i *instantiate୦୦iNode୦୮6୮7byte୦string, lev uint, ctrie *instantiate୦୦Map୦୮6୮7byte୦string,) bool {
	main := instantiate୦୦gcasRead୦୮6୮7byte୦string(i, ctrie)
	if main.cNode != nil {
		return instantiate୦୦gcas୦୮6୮7byte୦string(i, main, instantiate୦୦toCompressed୦୮6୮7byte୦string(main.cNode, lev), ctrie)
	}
	return true
}

//line ctrie.go2:1047
func instantiate୦୦z୦string() string {
			var v string

//line ctrie.go2:1049
 return v
}
//line ctrie.go2:863
func instantiate୦୦cleanReadOnly୦୮6୮7byte୦string(tn *instantiate୦୦tNode୦୮6୮7byte୦string, lev uint, p *instantiate୦୦iNode୦୮6୮7byte୦string, ctrie *instantiate୦୦Map୦୮6୮7byte୦string, entry *instantiate୦୦mapEntry୦୮6୮7byte୦string,) (val string, exists bool, ok bool) {
	if !ctrie.readOnly {
//line ctrie.go2:864
  instantiate୦୦clean୦୮6୮7byte୦string(p, lev-5, ctrie)
//line ctrie.go2:866
  return instantiate୦୦z୦string(), false, false
	}
	if tn.sNode.entry.hash == entry.hash && ctrie.eqFunc(tn.sNode.entry.key, entry.key) {
		return tn.sNode.entry.value, true, true
	}
	return instantiate୦୦z୦string(), false, true
}
//line ctrie.go2:810
func instantiate୦୦toContracted୦୮6୮7byte୦string(cn *instantiate୦୦cNode୦୮6୮7byte୦string, lev uint) *instantiate୦୦mainNode୦୮6୮7byte୦string {
	if lev > 0 && len(cn.slice) == 1 {
		switch branch := cn.slice[0].(type) {
		case *instantiate୦୦sNode୦୮6୮7byte୦string:
			return instantiate୦୦entomb୦୮6୮7byte୦string(branch)
		default:
			return &instantiate୦୦mainNode୦୮6୮7byte୦string{cNode: cn}
		}
	}
	return &instantiate୦୦mainNode୦୮6୮7byte୦string{cNode: cn}
}

//line ctrie.go2:874
func instantiate୦୦cleanParent୦୮6୮7byte୦string(p, i *instantiate୦୦iNode୦୮6୮7byte୦string, hc uint32, lev uint, ctrie *instantiate୦୦Map୦୮6୮7byte୦string, startGen *generation) {
	main := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0string୮9(&i.main)
	pMain := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0string୮9(&p.main)
	if pMain.cNode == nil {
		return
	}
	flag, pos := flagPos(hc, lev, pMain.cNode.bmp)
	if pMain.cNode.bmp&flag == 0 {
		return
	}
	sub := pMain.cNode.slice[pos]
	if sub != i || main.tNode == nil {
		return
	}
	ncn := pMain.cNode.updated(pos, instantiate୦୦resurrect୦୮6୮7byte୦string(i, main), i.gen)
	if instantiate୦୦gcas୦୮6୮7byte୦string(p, pMain, instantiate୦୦toContracted୦୮6୮7byte୦string(ncn, lev), ctrie) || ctrie.readRoot().gen != startGen {
		return
	}
//line ctrie.go2:891
 instantiate୦୦cleanParent୦୮6୮7byte୦string(p, i, hc, lev, ctrie, startGen)
//line ctrie.go2:893
}
//line ctrie.go2:844
func instantiate୦୦entomb୦୮6୮7byte୦string(m *instantiate୦୦sNode୦୮6୮7byte୦string,) *instantiate୦୦mainNode୦୮6୮7byte୦string {
	return &instantiate୦୦mainNode୦୮6୮7byte୦string{tNode: &instantiate୦୦tNode୦୮6୮7byte୦string{m}}
}
//line ctrie_test.go2:4
func instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8୮6୮7byte୮3୮0string୮9(addr **instantiate୦୦iNode୦୮6୮7byte୦string) *instantiate୦୦iNode୦୮6୮7byte୦string {
//line ctrie_test.go2:4
 return (*instantiate୦୦iNode୦୮6୮7byte୦string)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:6
 ))))
//line ctrie_test.go2:6
}

//line ctrie_test.go2:6
type instantiate୦୦rdcssDescriptor୦୮6୮7byte୦string struct {
//line ctrie.go2:967
 old *instantiate୦୦iNode୦୮6୮7byte୦string
	expected  *instantiate୦୦mainNode୦୮6୮7byte୦string
	nv        *instantiate୦୦iNode୦୮6୮7byte୦string
	committed int32
}

//line ctrie_test.go2:10
func instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮aiNode୮8୮6୮7byte୮3୮0string୮9(addr **instantiate୦୦iNode୦୮6୮7byte୦string, old, new *instantiate୦୦iNode୦୮6୮7byte୦string,) (swapped bool) {
	return atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(addr)),
//line ctrie_test.go2:13
  unsafe.Pointer(old), unsafe.Pointer(new))
//line ctrie_test.go2:13
}
//line ctrie_test.go2:6
func instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0string୮9(addr **instantiate୦୦mainNode୦୮6୮7byte୦string,
//line ctrie_test.go2:8
 val *instantiate୦୦mainNode୦୮6୮7byte୦string,) {
//line ctrie_test.go2:8
 atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(addr)), unsafe.Pointer(val))
//line ctrie_test.go2:10
}

//line ctrie_test.go2:10
type instantiate୦୦tNode୦୮6୮7byte୦string struct {
//line ctrie.go2:733
 sNode *instantiate୦୦sNode୦୮6୮7byte୦string
}

//line ctrie.go2:737
func (t *instantiate୦୦tNode୦୮6୮7byte୦string,) untombed() *instantiate୦୦sNode୦୮6୮7byte୦string {
	return &instantiate୦୦sNode୦୮6୮7byte୦string{&instantiate୦୦mapEntry୦୮6୮7byte୦string{
		key:   t.sNode.entry.key,
		value: t.sNode.entry.value,
		hash:  t.sNode.entry.hash,
	}}
}

//line ctrie.go2:743
type instantiate୦୦lNode୦୮6୮7byte୦string struct {
//line ctrie.go2:748
 head *instantiate୦୦sNode୦୮6୮7byte୦string
	tail *instantiate୦୦lNode୦୮6୮7byte୦string
}

//line ctrie.go2:754
func (l *instantiate୦୦lNode୦୮6୮7byte୦string,) lookup(e *instantiate୦୦mapEntry୦୮6୮7byte୦string, eq func([]byte, []byte,

//line ctrie.go2:754
) bool) (string,

//line ctrie.go2:754
 bool) {
	for ; l != nil; l = l.tail {
		if eq(e.key, l.head.entry.key) {
			return l.head.entry.value, true
		}
	}
	return instantiate୦୦z୦string(), false
}

//line ctrie.go2:764
func (l *instantiate୦୦lNode୦୮6୮7byte୦string,) inserted(entry *instantiate୦୦mapEntry୦୮6୮7byte୦string, eq func([]byte, []byte,

//line ctrie.go2:764
) bool) *instantiate୦୦lNode୦୮6୮7byte୦string {
	return &instantiate୦୦lNode୦୮6୮7byte୦string{
		head: &instantiate୦୦sNode୦୮6୮7byte୦string{entry},
		tail: l.removed(entry, eq),
	}
}

//line ctrie.go2:772
func (l *instantiate୦୦lNode୦୮6୮7byte୦string,) removed(e *instantiate୦୦mapEntry୦୮6୮7byte୦string, eq func([]byte, []byte,

//line ctrie.go2:772
) bool) *instantiate୦୦lNode୦୮6୮7byte୦string {
	for l1 := l; l1 != nil; l1 = l1.tail {
		if eq(e.key, l1.head.entry.key) {
			return l.remove(l1)
		}
	}
	return l
}

func (l *instantiate୦୦lNode୦୮6୮7byte୦string,) remove(l1 *instantiate୦୦lNode୦୮6୮7byte୦string,) *instantiate୦୦lNode୦୮6୮7byte୦string {
	if l == l1 {
		return l.tail
	}
	return &instantiate୦୦lNode୦୮6୮7byte୦string{
		head: l.head,
		tail: l.tail.remove(l1),
	}
}

//line ctrie.go2:789
type instantiate୦୦mapEntry୦୮6୮7byte୦int struct {
//line ctrie.go2:796
 key []byte

//line ctrie.go2:797
 value int

//line ctrie.go2:798
 hash uint32
}

//line ctrie.go2:917
func instantiate୦୦gcasRead୦୮6୮7byte୦int(in *instantiate୦୦iNode୦୮6୮7byte୦int, ctrie *instantiate୦୦Map୦୮6୮7byte୦int,) *instantiate୦୦mainNode୦୮6୮7byte୦int {
	m := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0int୮9(&in.main)
	if instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0int୮9(&m.prev) == nil {
		return m
	}
	return instantiate୦୦gcasComplete୦୮6୮7byte୦int(in, m, ctrie)
}

//line ctrie.go2:923
type instantiate୦୦Iter୦୮6୮7byte୦int struct {
//line ctrie.go2:247
 c *instantiate୦୦Map୦୮6୮7byte୦int

//line ctrie.go2:251
 stack []instantiate୦୦iterFrame୦୮6୮7byte୦int
	curr *instantiate୦୦mapEntry୦୮6୮7byte୦int
}

//line ctrie.go2:265
func (i *instantiate୦୦Iter୦୮6୮7byte୦int,) Next() bool {
	i.curr = nil
	for i.curr == nil && len(i.stack) > 0 {
		if f := &i.stack[len(i.stack)-1]; !f.iter(i, f) {
			i.pop()
		}
	}
	return i.curr != nil
}

func (i *instantiate୦୦Iter୦୮6୮7byte୦int,) Value() int {
	if i.curr == nil {
		return instantiate୦୦z୦int()
	}
	return i.curr.value
}

func (i *instantiate୦୦Iter୦୮6୮7byte୦int,) Key() []byte {
	if i.curr == nil {
		return instantiate୦୦z୦୮6୮7byte()
	}
	return i.curr.key
}

//line ctrie.go2:290
func (i *instantiate୦୦Iter୦୮6୮7byte୦int,) mainIter(f *instantiate୦୦iterFrame୦୮6୮7byte୦int,) bool {
	if f.iNode == nil {
		return false
	}
	main := instantiate୦୦gcasRead୦୮6୮7byte୦int(f.iNode, i.c)
	f.iNode = nil
	switch {
	case main.cNode != nil:
		i.push((*instantiate୦୦Iter୦୮6୮7byte୦int).sliceIter).slice = main.cNode.slice
		return true
	case main.lNode != nil:
		i.push((*instantiate୦୦Iter୦୮6୮7byte୦int).listIter).lNode = main.lNode
		return true
	case main.tNode != nil:
		i.curr = main.tNode.sNode.entry
		return true
	}
	panic("unreachable")
}

//line ctrie.go2:311
func (i *instantiate୦୦Iter୦୮6୮7byte୦int,) sliceIter(f *instantiate୦୦iterFrame୦୮6୮7byte୦int,) bool {
	a := f.slice
	if len(a) == 0 {
		return false
	}
	f.slice = a[1:]
	switch b := a[0].(type) {
	case *instantiate୦୦iNode୦୮6୮7byte୦int:
		i.push((*instantiate୦୦Iter୦୮6୮7byte୦int).mainIter).iNode = b
		return true
	case *instantiate୦୦sNode୦୮6୮7byte୦int:
		i.curr = b.entry
		return true
	}
	panic("unreachable")
}

//line ctrie.go2:329
func (i *instantiate୦୦Iter୦୮6୮7byte୦int,) listIter(f *instantiate୦୦iterFrame୦୮6୮7byte୦int,) bool {
	l := f.lNode
	if l == nil {
		return false
	}
	f.lNode = f.lNode.tail
	i.curr = l.head.entry
	return true
}

//line ctrie.go2:340
func (i *instantiate୦୦Iter୦୮6୮7byte୦int,) pop() {
	i.stack = i.stack[0 : len(i.stack)-1]
}

//line ctrie.go2:348
func (i *instantiate୦୦Iter୦୮6୮7byte୦int,) push(f func(*instantiate୦୦Iter୦୮6୮7byte୦int, *instantiate୦୦iterFrame୦୮6୮7byte୦int,) bool) *instantiate୦୦iterFrame୦୮6୮7byte୦int {
	i.stack = append(i.stack, instantiate୦୦iterFrame୦୮6୮7byte୦int{})
	elem := &i.stack[len(i.stack)-1]
	elem.iter = f
	return elem
}

//line ctrie.go2:353
type instantiate୦୦sNode୦୮6୮7byte୦int struct {
//line ctrie.go2:803
 entry *instantiate୦୦mapEntry୦୮6୮7byte୦int
}

//line ctrie.go2:907
func instantiate୦୦gcas୦୮6୮7byte୦int(in *instantiate୦୦iNode୦୮6୮7byte୦int, old, n *instantiate୦୦mainNode୦୮6୮7byte୦int, ct *instantiate୦୦Map୦୮6୮7byte୦int,) bool {
//line ctrie.go2:907
 instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0int୮9(&n.prev, old)
//line ctrie.go2:909
 if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0int୮9(&in.main, old, n) {
//line ctrie.go2:909
  instantiate୦୦gcasComplete୦୮6୮7byte୦int(in, n, ct)
//line ctrie.go2:911
  return instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0int୮9(&n.prev) == nil
	}
	return false
}
//line ctrie.go2:645
func instantiate୦୦newMainNode୦୮6୮7byte୦int(x *instantiate୦୦sNode୦୮6୮7byte୦int, xhc uint32, y *instantiate୦୦sNode୦୮6୮7byte୦int, yhc uint32, lev uint, gen *generation) *instantiate୦୦mainNode୦୮6୮7byte୦int {
	if lev >= exp2 {
		return &instantiate୦୦mainNode୦୮6୮7byte୦int{
			lNode: &instantiate୦୦lNode୦୮6୮7byte୦int{
				head: y,
				tail: &instantiate୦୦lNode୦୮6୮7byte୦int{
					head: x,
				},
			},
		}
	}
	xidx := (xhc >> lev) & 0x1f
	yidx := (yhc >> lev) & 0x1f
	bmp := uint32((1 << xidx) | (1 << yidx))

	switch {
	case xidx == yidx:

		main := instantiate୦୦newMainNode୦୮6୮7byte୦int(x, xhc, y, yhc, lev+w, gen)
		iNode := &instantiate୦୦iNode୦୮6୮7byte୦int{main: main, gen: gen}
		return &instantiate୦୦mainNode୦୮6୮7byte୦int{cNode: &instantiate୦୦cNode୦୮6୮7byte୦int{bmp, []branch{iNode}, gen}}
	case xidx < yidx:
		return &instantiate୦୦mainNode୦୮6୮7byte୦int{cNode: &instantiate୦୦cNode୦୮6୮7byte୦int{bmp, []branch{x, y}, gen}}
	default:
		return &instantiate୦୦mainNode୦୮6୮7byte୦int{cNode: &instantiate୦୦cNode୦୮6୮7byte୦int{bmp, []branch{y, x}, gen}}
	}
}

//line ctrie.go2:855
func instantiate୦୦clean୦୮6୮7byte୦int(i *instantiate୦୦iNode୦୮6୮7byte୦int, lev uint, ctrie *instantiate୦୦Map୦୮6୮7byte୦int,) bool {
	main := instantiate୦୦gcasRead୦୮6୮7byte୦int(i, ctrie)
	if main.cNode != nil {
		return instantiate୦୦gcas୦୮6୮7byte୦int(i, main, instantiate୦୦toCompressed୦୮6୮7byte୦int(main.cNode, lev), ctrie)
	}
	return true
}

//line ctrie.go2:1047
func instantiate୦୦z୦int() int {
			var v int

//line ctrie.go2:1049
 return v
}
//line ctrie.go2:863
func instantiate୦୦cleanReadOnly୦୮6୮7byte୦int(tn *instantiate୦୦tNode୦୮6୮7byte୦int, lev uint, p *instantiate୦୦iNode୦୮6୮7byte୦int, ctrie *instantiate୦୦Map୦୮6୮7byte୦int, entry *instantiate୦୦mapEntry୦୮6୮7byte୦int,) (val int, exists bool, ok bool) {
	if !ctrie.readOnly {
//line ctrie.go2:864
  instantiate୦୦clean୦୮6୮7byte୦int(p, lev-5, ctrie)
//line ctrie.go2:866
  return instantiate୦୦z୦int(), false, false
	}
	if tn.sNode.entry.hash == entry.hash && ctrie.eqFunc(tn.sNode.entry.key, entry.key) {
		return tn.sNode.entry.value, true, true
	}
	return instantiate୦୦z୦int(), false, true
}
//line ctrie.go2:810
func instantiate୦୦toContracted୦୮6୮7byte୦int(cn *instantiate୦୦cNode୦୮6୮7byte୦int, lev uint) *instantiate୦୦mainNode୦୮6୮7byte୦int {
	if lev > 0 && len(cn.slice) == 1 {
		switch branch := cn.slice[0].(type) {
		case *instantiate୦୦sNode୦୮6୮7byte୦int:
			return instantiate୦୦entomb୦୮6୮7byte୦int(branch)
		default:
			return &instantiate୦୦mainNode୦୮6୮7byte୦int{cNode: cn}
		}
	}
	return &instantiate୦୦mainNode୦୮6୮7byte୦int{cNode: cn}
}

//line ctrie.go2:874
func instantiate୦୦cleanParent୦୮6୮7byte୦int(p, i *instantiate୦୦iNode୦୮6୮7byte୦int, hc uint32, lev uint, ctrie *instantiate୦୦Map୦୮6୮7byte୦int, startGen *generation) {
	main := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0int୮9(&i.main)
	pMain := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0int୮9(&p.main)
	if pMain.cNode == nil {
		return
	}
	flag, pos := flagPos(hc, lev, pMain.cNode.bmp)
	if pMain.cNode.bmp&flag == 0 {
		return
	}
	sub := pMain.cNode.slice[pos]
	if sub != i || main.tNode == nil {
		return
	}
	ncn := pMain.cNode.updated(pos, instantiate୦୦resurrect୦୮6୮7byte୦int(i, main), i.gen)
	if instantiate୦୦gcas୦୮6୮7byte୦int(p, pMain, instantiate୦୦toContracted୦୮6୮7byte୦int(ncn, lev), ctrie) || ctrie.readRoot().gen != startGen {
		return
	}
//line ctrie.go2:891
 instantiate୦୦cleanParent୦୮6୮7byte୦int(p, i, hc, lev, ctrie, startGen)
//line ctrie.go2:893
}
//line ctrie.go2:844
func instantiate୦୦entomb୦୮6୮7byte୦int(m *instantiate୦୦sNode୦୮6୮7byte୦int,) *instantiate୦୦mainNode୦୮6୮7byte୦int {
	return &instantiate୦୦mainNode୦୮6୮7byte୦int{tNode: &instantiate୦୦tNode୦୮6୮7byte୦int{m}}
}
//line ctrie_test.go2:4
func instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8୮6୮7byte୮3୮0int୮9(addr **instantiate୦୦iNode୦୮6୮7byte୦int) *instantiate୦୦iNode୦୮6୮7byte୦int {
//line ctrie_test.go2:4
 return (*instantiate୦୦iNode୦୮6୮7byte୦int)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:6
 ))))
//line ctrie_test.go2:6
}

//line ctrie_test.go2:6
type instantiate୦୦rdcssDescriptor୦୮6୮7byte୦int struct {
//line ctrie.go2:967
 old *instantiate୦୦iNode୦୮6୮7byte୦int
	expected  *instantiate୦୦mainNode୦୮6୮7byte୦int
	nv        *instantiate୦୦iNode୦୮6୮7byte୦int
	committed int32
}

//line ctrie_test.go2:10
func instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮aiNode୮8୮6୮7byte୮3୮0int୮9(addr **instantiate୦୦iNode୦୮6୮7byte୦int, old, new *instantiate୦୦iNode୦୮6୮7byte୦int,) (swapped bool) {
	return atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(addr)),
//line ctrie_test.go2:13
  unsafe.Pointer(old), unsafe.Pointer(new))
//line ctrie_test.go2:13
}
//line ctrie_test.go2:6
func instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0int୮9(addr **instantiate୦୦mainNode୦୮6୮7byte୦int,
//line ctrie_test.go2:8
 val *instantiate୦୦mainNode୦୮6୮7byte୦int,) {
//line ctrie_test.go2:8
 atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(addr)), unsafe.Pointer(val))
//line ctrie_test.go2:10
}

//line ctrie_test.go2:10
type instantiate୦୦tNode୦୮6୮7byte୦int struct {
//line ctrie.go2:733
 sNode *instantiate୦୦sNode୦୮6୮7byte୦int
}

//line ctrie.go2:737
func (t *instantiate୦୦tNode୦୮6୮7byte୦int,) untombed() *instantiate୦୦sNode୦୮6୮7byte୦int {
	return &instantiate୦୦sNode୦୮6୮7byte୦int{&instantiate୦୦mapEntry୦୮6୮7byte୦int{
		key:   t.sNode.entry.key,
		value: t.sNode.entry.value,
		hash:  t.sNode.entry.hash,
	}}
}

//line ctrie.go2:743
type instantiate୦୦lNode୦୮6୮7byte୦int struct {
//line ctrie.go2:748
 head *instantiate୦୦sNode୦୮6୮7byte୦int
	tail *instantiate୦୦lNode୦୮6୮7byte୦int
}

//line ctrie.go2:754
func (l *instantiate୦୦lNode୦୮6୮7byte୦int,) lookup(e *instantiate୦୦mapEntry୦୮6୮7byte୦int, eq func([]byte, []byte,

//line ctrie.go2:754
) bool) (int,

//line ctrie.go2:754
 bool) {
	for ; l != nil; l = l.tail {
		if eq(e.key, l.head.entry.key) {
			return l.head.entry.value, true
		}
	}
	return instantiate୦୦z୦int(), false
}

//line ctrie.go2:764
func (l *instantiate୦୦lNode୦୮6୮7byte୦int,) inserted(entry *instantiate୦୦mapEntry୦୮6୮7byte୦int, eq func([]byte, []byte,

//line ctrie.go2:764
) bool) *instantiate୦୦lNode୦୮6୮7byte୦int {
	return &instantiate୦୦lNode୦୮6୮7byte୦int{
		head: &instantiate୦୦sNode୦୮6୮7byte୦int{entry},
		tail: l.removed(entry, eq),
	}
}

//line ctrie.go2:772
func (l *instantiate୦୦lNode୦୮6୮7byte୦int,) removed(e *instantiate୦୦mapEntry୦୮6୮7byte୦int, eq func([]byte, []byte,

//line ctrie.go2:772
) bool) *instantiate୦୦lNode୦୮6୮7byte୦int {
	for l1 := l; l1 != nil; l1 = l1.tail {
		if eq(e.key, l1.head.entry.key) {
			return l.remove(l1)
		}
	}
	return l
}

func (l *instantiate୦୦lNode୦୮6୮7byte୦int,) remove(l1 *instantiate୦୦lNode୦୮6୮7byte୦int,) *instantiate୦୦lNode୦୮6୮7byte୦int {
	if l == l1 {
		return l.tail
	}
	return &instantiate୦୦lNode୦୮6୮7byte୦int{
		head: l.head,
		tail: l.tail.remove(l1),
	}
}

//line ctrie.go2:789
type instantiate୦୦mapEntry୦୮6୮7byte୦interface୮4୮5 struct {
//line ctrie.go2:796
 key []byte

//line ctrie.go2:797
 value interface{}

//line ctrie.go2:798
 hash uint32
}

//line ctrie.go2:917
func instantiate୦୦gcasRead୦୮6୮7byte୦interface୮4୮5(in *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5, ctrie *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) *instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5 {
	m := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0interface୮4୮5୮9(&in.main)
	if instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0interface୮4୮5୮9(&m.prev) == nil {
		return m
	}
	return instantiate୦୦gcasComplete୦୮6୮7byte୦interface୮4୮5(in, m, ctrie)
}

//line ctrie.go2:923
type instantiate୦୦Iter୦୮6୮7byte୦interface୮4୮5 struct {
//line ctrie.go2:247
 c *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5

//line ctrie.go2:251
 stack []instantiate୦୦iterFrame୦୮6୮7byte୦interface୮4୮5
	curr *instantiate୦୦mapEntry୦୮6୮7byte୦interface୮4୮5
}

//line ctrie.go2:265
func (i *instantiate୦୦Iter୦୮6୮7byte୦interface୮4୮5,) Next() bool {
	i.curr = nil
	for i.curr == nil && len(i.stack) > 0 {
		if f := &i.stack[len(i.stack)-1]; !f.iter(i, f) {
			i.pop()
		}
	}
	return i.curr != nil
}

func (i *instantiate୦୦Iter୦୮6୮7byte୦interface୮4୮5,) Value() interface{} {
	if i.curr == nil {
		return instantiate୦୦z୦interface୮4୮5()
	}
	return i.curr.value
}

func (i *instantiate୦୦Iter୦୮6୮7byte୦interface୮4୮5,) Key() []byte {
	if i.curr == nil {
		return instantiate୦୦z୦୮6୮7byte()
	}
	return i.curr.key
}

//line ctrie.go2:290
func (i *instantiate୦୦Iter୦୮6୮7byte୦interface୮4୮5,) mainIter(f *instantiate୦୦iterFrame୦୮6୮7byte୦interface୮4୮5,) bool {
	if f.iNode == nil {
		return false
	}
	main := instantiate୦୦gcasRead୦୮6୮7byte୦interface୮4୮5(f.iNode, i.c)
	f.iNode = nil
	switch {
	case main.cNode != nil:
		i.push((*instantiate୦୦Iter୦୮6୮7byte୦interface୮4୮5).sliceIter).slice = main.cNode.slice
		return true
	case main.lNode != nil:
		i.push((*instantiate୦୦Iter୦୮6୮7byte୦interface୮4୮5).listIter).lNode = main.lNode
		return true
	case main.tNode != nil:
		i.curr = main.tNode.sNode.entry
		return true
	}
	panic("unreachable")
}

//line ctrie.go2:311
func (i *instantiate୦୦Iter୦୮6୮7byte୦interface୮4୮5,) sliceIter(f *instantiate୦୦iterFrame୦୮6୮7byte୦interface୮4୮5,) bool {
	a := f.slice
	if len(a) == 0 {
		return false
	}
	f.slice = a[1:]
	switch b := a[0].(type) {
	case *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5:
		i.push((*instantiate୦୦Iter୦୮6୮7byte୦interface୮4୮5).mainIter).iNode = b
		return true
	case *instantiate୦୦sNode୦୮6୮7byte୦interface୮4୮5:
		i.curr = b.entry
		return true
	}
	panic("unreachable")
}

//line ctrie.go2:329
func (i *instantiate୦୦Iter୦୮6୮7byte୦interface୮4୮5,) listIter(f *instantiate୦୦iterFrame୦୮6୮7byte୦interface୮4୮5,) bool {
	l := f.lNode
	if l == nil {
		return false
	}
	f.lNode = f.lNode.tail
	i.curr = l.head.entry
	return true
}

//line ctrie.go2:340
func (i *instantiate୦୦Iter୦୮6୮7byte୦interface୮4୮5,) pop() {
	i.stack = i.stack[0 : len(i.stack)-1]
}

//line ctrie.go2:348
func (i *instantiate୦୦Iter୦୮6୮7byte୦interface୮4୮5,) push(f func(*instantiate୦୦Iter୦୮6୮7byte୦interface୮4୮5, *instantiate୦୦iterFrame୦୮6୮7byte୦interface୮4୮5,) bool) *instantiate୦୦iterFrame୦୮6୮7byte୦interface୮4୮5 {
	i.stack = append(i.stack, instantiate୦୦iterFrame୦୮6୮7byte୦interface୮4୮5{})
	elem := &i.stack[len(i.stack)-1]
	elem.iter = f
	return elem
}

//line ctrie.go2:353
type instantiate୦୦sNode୦୮6୮7byte୦interface୮4୮5 struct {
//line ctrie.go2:803
 entry *instantiate୦୦mapEntry୦୮6୮7byte୦interface୮4୮5
}

//line ctrie.go2:907
func instantiate୦୦gcas୦୮6୮7byte୦interface୮4୮5(in *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5, old, n *instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5, ct *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) bool {
//line ctrie.go2:907
 instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0interface୮4୮5୮9(&n.prev, old)
//line ctrie.go2:909
 if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0interface୮4୮5୮9(&in.main, old, n) {
//line ctrie.go2:909
  instantiate୦୦gcasComplete୦୮6୮7byte୦interface୮4୮5(in, n, ct)
//line ctrie.go2:911
  return instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0interface୮4୮5୮9(&n.prev) == nil
	}
	return false
}
//line ctrie.go2:645
func instantiate୦୦newMainNode୦୮6୮7byte୦interface୮4୮5(x *instantiate୦୦sNode୦୮6୮7byte୦interface୮4୮5, xhc uint32, y *instantiate୦୦sNode୦୮6୮7byte୦interface୮4୮5, yhc uint32, lev uint, gen *generation) *instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5 {
	if lev >= exp2 {
		return &instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5{
			lNode: &instantiate୦୦lNode୦୮6୮7byte୦interface୮4୮5{
				head: y,
				tail: &instantiate୦୦lNode୦୮6୮7byte୦interface୮4୮5{
					head: x,
				},
			},
		}
	}
	xidx := (xhc >> lev) & 0x1f
	yidx := (yhc >> lev) & 0x1f
	bmp := uint32((1 << xidx) | (1 << yidx))

	switch {
	case xidx == yidx:

		main := instantiate୦୦newMainNode୦୮6୮7byte୦interface୮4୮5(x, xhc, y, yhc, lev+w, gen)
		iNode := &instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5{main: main, gen: gen}
		return &instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5{cNode: &instantiate୦୦cNode୦୮6୮7byte୦interface୮4୮5{bmp, []branch{iNode}, gen}}
	case xidx < yidx:
		return &instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5{cNode: &instantiate୦୦cNode୦୮6୮7byte୦interface୮4୮5{bmp, []branch{x, y}, gen}}
	default:
		return &instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5{cNode: &instantiate୦୦cNode୦୮6୮7byte୦interface୮4୮5{bmp, []branch{y, x}, gen}}
	}
}

//line ctrie.go2:855
func instantiate୦୦clean୦୮6୮7byte୦interface୮4୮5(i *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5, lev uint, ctrie *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) bool {
	main := instantiate୦୦gcasRead୦୮6୮7byte୦interface୮4୮5(i, ctrie)
	if main.cNode != nil {
		return instantiate୦୦gcas୦୮6୮7byte୦interface୮4୮5(i, main, instantiate୦୦toCompressed୦୮6୮7byte୦interface୮4୮5(main.cNode, lev), ctrie)
	}
	return true
}

//line ctrie.go2:1047
func instantiate୦୦z୦interface୮4୮5() interface{} {
			var v interface{}

//line ctrie.go2:1049
 return v
}
//line ctrie.go2:863
func instantiate୦୦cleanReadOnly୦୮6୮7byte୦interface୮4୮5(tn *instantiate୦୦tNode୦୮6୮7byte୦interface୮4୮5, lev uint, p *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5, ctrie *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5, entry *instantiate୦୦mapEntry୦୮6୮7byte୦interface୮4୮5,) (val interface {
//line ctrie.go2:863
}, exists bool, ok bool) {
	if !ctrie.readOnly {
//line ctrie.go2:864
  instantiate୦୦clean୦୮6୮7byte୦interface୮4୮5(p, lev-5, ctrie)
//line ctrie.go2:866
  return instantiate୦୦z୦interface୮4୮5(), false, false
	}
	if tn.sNode.entry.hash == entry.hash && ctrie.eqFunc(tn.sNode.entry.key, entry.key) {
		return tn.sNode.entry.value, true, true
	}
	return instantiate୦୦z୦interface୮4୮5(), false, true
}
//line ctrie.go2:810
func instantiate୦୦toContracted୦୮6୮7byte୦interface୮4୮5(cn *instantiate୦୦cNode୦୮6୮7byte୦interface୮4୮5, lev uint) *instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5 {
	if lev > 0 && len(cn.slice) == 1 {
		switch branch := cn.slice[0].(type) {
		case *instantiate୦୦sNode୦୮6୮7byte୦interface୮4୮5:
			return instantiate୦୦entomb୦୮6୮7byte୦interface୮4୮5(branch)
		default:
			return &instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5{cNode: cn}
		}
	}
	return &instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5{cNode: cn}
}

//line ctrie.go2:874
func instantiate୦୦cleanParent୦୮6୮7byte୦interface୮4୮5(p, i *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5, hc uint32, lev uint, ctrie *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5, startGen *generation) {
	main := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0interface୮4୮5୮9(&i.main)
	pMain := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0interface୮4୮5୮9(&p.main)
	if pMain.cNode == nil {
		return
	}
	flag, pos := flagPos(hc, lev, pMain.cNode.bmp)
	if pMain.cNode.bmp&flag == 0 {
		return
	}
	sub := pMain.cNode.slice[pos]
	if sub != i || main.tNode == nil {
		return
	}
	ncn := pMain.cNode.updated(pos, instantiate୦୦resurrect୦୮6୮7byte୦interface୮4୮5(i, main), i.gen)
	if instantiate୦୦gcas୦୮6୮7byte୦interface୮4୮5(p, pMain, instantiate୦୦toContracted୦୮6୮7byte୦interface୮4୮5(ncn, lev), ctrie) || ctrie.readRoot().gen != startGen {
		return
	}
//line ctrie.go2:891
 instantiate୦୦cleanParent୦୮6୮7byte୦interface୮4୮5(p, i, hc, lev, ctrie, startGen)
//line ctrie.go2:893
}
//line ctrie.go2:844
func instantiate୦୦entomb୦୮6୮7byte୦interface୮4୮5(m *instantiate୦୦sNode୦୮6୮7byte୦interface୮4୮5,) *instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5 {
	return &instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5{tNode: &instantiate୦୦tNode୦୮6୮7byte୦interface୮4୮5{m}}
}
//line ctrie_test.go2:4
func instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8୮6୮7byte୮3୮0interface୮4୮5୮9(addr **instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5) *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5 {
//line ctrie_test.go2:4
 return (*instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:6
 ))))
//line ctrie_test.go2:6
}

//line ctrie_test.go2:6
type instantiate୦୦rdcssDescriptor୦୮6୮7byte୦interface୮4୮5 struct {
//line ctrie.go2:967
 old *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5
	expected  *instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5
	nv        *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5
	committed int32
}

//line ctrie_test.go2:10
func instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮aiNode୮8୮6୮7byte୮3୮0interface୮4୮5୮9(addr **instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5, old, new *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5,) (swapped bool) {
	return atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(addr)),
//line ctrie_test.go2:13
  unsafe.Pointer(old), unsafe.Pointer(new))
//line ctrie_test.go2:13
}
//line ctrie_test.go2:6
func instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0interface୮4୮5୮9(addr **instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5,
//line ctrie_test.go2:8
 val *instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5,) {
//line ctrie_test.go2:8
 atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(addr)), unsafe.Pointer(val))
//line ctrie_test.go2:10
}

//line ctrie_test.go2:10
type instantiate୦୦tNode୦୮6୮7byte୦interface୮4୮5 struct {
//line ctrie.go2:733
 sNode *instantiate୦୦sNode୦୮6୮7byte୦interface୮4୮5
}

//line ctrie.go2:737
func (t *instantiate୦୦tNode୦୮6୮7byte୦interface୮4୮5,) untombed() *instantiate୦୦sNode୦୮6୮7byte୦interface୮4୮5 {
	return &instantiate୦୦sNode୦୮6୮7byte୦interface୮4୮5{&instantiate୦୦mapEntry୦୮6୮7byte୦interface୮4୮5{
		key:   t.sNode.entry.key,
		value: t.sNode.entry.value,
		hash:  t.sNode.entry.hash,
	}}
}

//line ctrie.go2:743
type instantiate୦୦lNode୦୮6୮7byte୦interface୮4୮5 struct {
//line ctrie.go2:748
 head *instantiate୦୦sNode୦୮6୮7byte୦interface୮4୮5
	tail *instantiate୦୦lNode୦୮6୮7byte୦interface୮4୮5
}

//line ctrie.go2:754
func (l *instantiate୦୦lNode୦୮6୮7byte୦interface୮4୮5,) lookup(e *instantiate୦୦mapEntry୦୮6୮7byte୦interface୮4୮5, eq func([]byte, []byte,

//line ctrie.go2:754
) bool) (interface{},

//line ctrie.go2:754
 bool) {
	for ; l != nil; l = l.tail {
		if eq(e.key, l.head.entry.key) {
			return l.head.entry.value, true
		}
	}
	return instantiate୦୦z୦interface୮4୮5(), false
}

//line ctrie.go2:764
func (l *instantiate୦୦lNode୦୮6୮7byte୦interface୮4୮5,) inserted(entry *instantiate୦୦mapEntry୦୮6୮7byte୦interface୮4୮5, eq func([]byte, []byte,

//line ctrie.go2:764
) bool) *instantiate୦୦lNode୦୮6୮7byte୦interface୮4୮5 {
	return &instantiate୦୦lNode୦୮6୮7byte୦interface୮4୮5{
		head: &instantiate୦୦sNode୦୮6୮7byte୦interface୮4୮5{entry},
		tail: l.removed(entry, eq),
	}
}

//line ctrie.go2:772
func (l *instantiate୦୦lNode୦୮6୮7byte୦interface୮4୮5,) removed(e *instantiate୦୦mapEntry୦୮6୮7byte୦interface୮4୮5, eq func([]byte, []byte,

//line ctrie.go2:772
) bool) *instantiate୦୦lNode୦୮6୮7byte୦interface୮4୮5 {
	for l1 := l; l1 != nil; l1 = l1.tail {
		if eq(e.key, l1.head.entry.key) {
			return l.remove(l1)
		}
	}
	return l
}

func (l *instantiate୦୦lNode୦୮6୮7byte୦interface୮4୮5,) remove(l1 *instantiate୦୦lNode୦୮6୮7byte୦interface୮4୮5,) *instantiate୦୦lNode୦୮6୮7byte୦interface୮4୮5 {
	if l == l1 {
		return l.tail
	}
	return &instantiate୦୦lNode୦୮6୮7byte୦interface୮4୮5{
		head: l.head,
		tail: l.tail.remove(l1),
	}
}

//line ctrie.go2:789
type instantiate୦୦mapEntry୦୮6୮7byte୦bool struct {
//line ctrie.go2:796
 key []byte

//line ctrie.go2:797
 value bool

//line ctrie.go2:798
 hash uint32
}

//line ctrie.go2:917
func instantiate୦୦gcasRead୦୮6୮7byte୦bool(in *instantiate୦୦iNode୦୮6୮7byte୦bool, ctrie *instantiate୦୦Map୦୮6୮7byte୦bool,) *instantiate୦୦mainNode୦୮6୮7byte୦bool {
	m := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0bool୮9(&in.main)
	if instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0bool୮9(&m.prev) == nil {
		return m
	}
	return instantiate୦୦gcasComplete୦୮6୮7byte୦bool(in, m, ctrie)
}

//line ctrie.go2:923
type instantiate୦୦Iter୦୮6୮7byte୦bool struct {
//line ctrie.go2:247
 c *instantiate୦୦Map୦୮6୮7byte୦bool

//line ctrie.go2:251
 stack []instantiate୦୦iterFrame୦୮6୮7byte୦bool
	curr *instantiate୦୦mapEntry୦୮6୮7byte୦bool
}

//line ctrie.go2:265
func (i *instantiate୦୦Iter୦୮6୮7byte୦bool,) Next() bool {
	i.curr = nil
	for i.curr == nil && len(i.stack) > 0 {
		if f := &i.stack[len(i.stack)-1]; !f.iter(i, f) {
			i.pop()
		}
	}
	return i.curr != nil
}

func (i *instantiate୦୦Iter୦୮6୮7byte୦bool,) Value() bool {
	if i.curr == nil {
		return instantiate୦୦z୦bool()
	}
	return i.curr.value
}

func (i *instantiate୦୦Iter୦୮6୮7byte୦bool,) Key() []byte {
	if i.curr == nil {
		return instantiate୦୦z୦୮6୮7byte()
	}
	return i.curr.key
}

//line ctrie.go2:290
func (i *instantiate୦୦Iter୦୮6୮7byte୦bool,) mainIter(f *instantiate୦୦iterFrame୦୮6୮7byte୦bool,) bool {
	if f.iNode == nil {
		return false
	}
	main := instantiate୦୦gcasRead୦୮6୮7byte୦bool(f.iNode, i.c)
	f.iNode = nil
	switch {
	case main.cNode != nil:
		i.push((*instantiate୦୦Iter୦୮6୮7byte୦bool).sliceIter).slice = main.cNode.slice
		return true
	case main.lNode != nil:
		i.push((*instantiate୦୦Iter୦୮6୮7byte୦bool).listIter).lNode = main.lNode
		return true
	case main.tNode != nil:
		i.curr = main.tNode.sNode.entry
		return true
	}
	panic("unreachable")
}

//line ctrie.go2:311
func (i *instantiate୦୦Iter୦୮6୮7byte୦bool,) sliceIter(f *instantiate୦୦iterFrame୦୮6୮7byte୦bool,) bool {
	a := f.slice
	if len(a) == 0 {
		return false
	}
	f.slice = a[1:]
	switch b := a[0].(type) {
	case *instantiate୦୦iNode୦୮6୮7byte୦bool:
		i.push((*instantiate୦୦Iter୦୮6୮7byte୦bool).mainIter).iNode = b
		return true
	case *instantiate୦୦sNode୦୮6୮7byte୦bool:
		i.curr = b.entry
		return true
	}
	panic("unreachable")
}

//line ctrie.go2:329
func (i *instantiate୦୦Iter୦୮6୮7byte୦bool,) listIter(f *instantiate୦୦iterFrame୦୮6୮7byte୦bool,) bool {
	l := f.lNode
	if l == nil {
		return false
	}
	f.lNode = f.lNode.tail
	i.curr = l.head.entry
	return true
}

//line ctrie.go2:340
func (i *instantiate୦୦Iter୦୮6୮7byte୦bool,) pop() {
	i.stack = i.stack[0 : len(i.stack)-1]
}

//line ctrie.go2:348
func (i *instantiate୦୦Iter୦୮6୮7byte୦bool,) push(f func(*instantiate୦୦Iter୦୮6୮7byte୦bool, *instantiate୦୦iterFrame୦୮6୮7byte୦bool,) bool) *instantiate୦୦iterFrame୦୮6୮7byte୦bool {
	i.stack = append(i.stack, instantiate୦୦iterFrame୦୮6୮7byte୦bool{})
	elem := &i.stack[len(i.stack)-1]
	elem.iter = f
	return elem
}

//line ctrie.go2:353
type instantiate୦୦sNode୦୮6୮7byte୦bool struct {
//line ctrie.go2:803
 entry *instantiate୦୦mapEntry୦୮6୮7byte୦bool
}

//line ctrie.go2:907
func instantiate୦୦gcas୦୮6୮7byte୦bool(in *instantiate୦୦iNode୦୮6୮7byte୦bool, old, n *instantiate୦୦mainNode୦୮6୮7byte୦bool, ct *instantiate୦୦Map୦୮6୮7byte୦bool,) bool {
//line ctrie.go2:907
 instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0bool୮9(&n.prev, old)
//line ctrie.go2:909
 if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0bool୮9(&in.main, old, n) {
//line ctrie.go2:909
  instantiate୦୦gcasComplete୦୮6୮7byte୦bool(in, n, ct)
//line ctrie.go2:911
  return instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0bool୮9(&n.prev) == nil
	}
	return false
}
//line ctrie.go2:645
func instantiate୦୦newMainNode୦୮6୮7byte୦bool(x *instantiate୦୦sNode୦୮6୮7byte୦bool, xhc uint32, y *instantiate୦୦sNode୦୮6୮7byte୦bool, yhc uint32, lev uint, gen *generation) *instantiate୦୦mainNode୦୮6୮7byte୦bool {
	if lev >= exp2 {
		return &instantiate୦୦mainNode୦୮6୮7byte୦bool{
			lNode: &instantiate୦୦lNode୦୮6୮7byte୦bool{
				head: y,
				tail: &instantiate୦୦lNode୦୮6୮7byte୦bool{
					head: x,
				},
			},
		}
	}
	xidx := (xhc >> lev) & 0x1f
	yidx := (yhc >> lev) & 0x1f
	bmp := uint32((1 << xidx) | (1 << yidx))

	switch {
	case xidx == yidx:

		main := instantiate୦୦newMainNode୦୮6୮7byte୦bool(x, xhc, y, yhc, lev+w, gen)
		iNode := &instantiate୦୦iNode୦୮6୮7byte୦bool{main: main, gen: gen}
		return &instantiate୦୦mainNode୦୮6୮7byte୦bool{cNode: &instantiate୦୦cNode୦୮6୮7byte୦bool{bmp, []branch{iNode}, gen}}
	case xidx < yidx:
		return &instantiate୦୦mainNode୦୮6୮7byte୦bool{cNode: &instantiate୦୦cNode୦୮6୮7byte୦bool{bmp, []branch{x, y}, gen}}
	default:
		return &instantiate୦୦mainNode୦୮6୮7byte୦bool{cNode: &instantiate୦୦cNode୦୮6୮7byte୦bool{bmp, []branch{y, x}, gen}}
	}
}

//line ctrie.go2:855
func instantiate୦୦clean୦୮6୮7byte୦bool(i *instantiate୦୦iNode୦୮6୮7byte୦bool, lev uint, ctrie *instantiate୦୦Map୦୮6୮7byte୦bool,) bool {
	main := instantiate୦୦gcasRead୦୮6୮7byte୦bool(i, ctrie)
	if main.cNode != nil {
		return instantiate୦୦gcas୦୮6୮7byte୦bool(i, main, instantiate୦୦toCompressed୦୮6୮7byte୦bool(main.cNode, lev), ctrie)
	}
	return true
}

//line ctrie.go2:1047
func instantiate୦୦z୦bool() bool {
			var v bool

//line ctrie.go2:1049
 return v
}
//line ctrie.go2:863
func instantiate୦୦cleanReadOnly୦୮6୮7byte୦bool(tn *instantiate୦୦tNode୦୮6୮7byte୦bool, lev uint, p *instantiate୦୦iNode୦୮6୮7byte୦bool, ctrie *instantiate୦୦Map୦୮6୮7byte୦bool, entry *instantiate୦୦mapEntry୦୮6୮7byte୦bool,) (val bool, exists bool, ok bool) {
	if !ctrie.readOnly {
//line ctrie.go2:864
  instantiate୦୦clean୦୮6୮7byte୦bool(p, lev-5, ctrie)
//line ctrie.go2:866
  return instantiate୦୦z୦bool(), false, false
	}
	if tn.sNode.entry.hash == entry.hash && ctrie.eqFunc(tn.sNode.entry.key, entry.key) {
		return tn.sNode.entry.value, true, true
	}
	return instantiate୦୦z୦bool(), false, true
}
//line ctrie.go2:810
func instantiate୦୦toContracted୦୮6୮7byte୦bool(cn *instantiate୦୦cNode୦୮6୮7byte୦bool, lev uint) *instantiate୦୦mainNode୦୮6୮7byte୦bool {
	if lev > 0 && len(cn.slice) == 1 {
		switch branch := cn.slice[0].(type) {
		case *instantiate୦୦sNode୦୮6୮7byte୦bool:
			return instantiate୦୦entomb୦୮6୮7byte୦bool(branch)
		default:
			return &instantiate୦୦mainNode୦୮6୮7byte୦bool{cNode: cn}
		}
	}
	return &instantiate୦୦mainNode୦୮6୮7byte୦bool{cNode: cn}
}

//line ctrie.go2:874
func instantiate୦୦cleanParent୦୮6୮7byte୦bool(p, i *instantiate୦୦iNode୦୮6୮7byte୦bool, hc uint32, lev uint, ctrie *instantiate୦୦Map୦୮6୮7byte୦bool, startGen *generation) {
	main := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0bool୮9(&i.main)
	pMain := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0bool୮9(&p.main)
	if pMain.cNode == nil {
		return
	}
	flag, pos := flagPos(hc, lev, pMain.cNode.bmp)
	if pMain.cNode.bmp&flag == 0 {
		return
	}
	sub := pMain.cNode.slice[pos]
	if sub != i || main.tNode == nil {
		return
	}
	ncn := pMain.cNode.updated(pos, instantiate୦୦resurrect୦୮6୮7byte୦bool(i, main), i.gen)
	if instantiate୦୦gcas୦୮6୮7byte୦bool(p, pMain, instantiate୦୦toContracted୦୮6୮7byte୦bool(ncn, lev), ctrie) || ctrie.readRoot().gen != startGen {
		return
	}
//line ctrie.go2:891
 instantiate୦୦cleanParent୦୮6୮7byte୦bool(p, i, hc, lev, ctrie, startGen)
//line ctrie.go2:893
}
//line ctrie.go2:844
func instantiate୦୦entomb୦୮6୮7byte୦bool(m *instantiate୦୦sNode୦୮6୮7byte୦bool,) *instantiate୦୦mainNode୦୮6୮7byte୦bool {
	return &instantiate୦୦mainNode୦୮6୮7byte୦bool{tNode: &instantiate୦୦tNode୦୮6୮7byte୦bool{m}}
}
//line ctrie_test.go2:4
func instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8୮6୮7byte୮3୮0bool୮9(addr **instantiate୦୦iNode୦୮6୮7byte୦bool) *instantiate୦୦iNode୦୮6୮7byte୦bool {
//line ctrie_test.go2:4
 return (*instantiate୦୦iNode୦୮6୮7byte୦bool)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:6
 ))))
//line ctrie_test.go2:6
}

//line ctrie_test.go2:6
type instantiate୦୦rdcssDescriptor୦୮6୮7byte୦bool struct {
//line ctrie.go2:967
 old *instantiate୦୦iNode୦୮6୮7byte୦bool
	expected  *instantiate୦୦mainNode୦୮6୮7byte୦bool
	nv        *instantiate୦୦iNode୦୮6୮7byte୦bool
	committed int32
}

//line ctrie_test.go2:10
func instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮aiNode୮8୮6୮7byte୮3୮0bool୮9(addr **instantiate୦୦iNode୦୮6୮7byte୦bool, old, new *instantiate୦୦iNode୦୮6୮7byte୦bool,) (swapped bool) {
	return atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(addr)),
//line ctrie_test.go2:13
  unsafe.Pointer(old), unsafe.Pointer(new))
//line ctrie_test.go2:13
}
//line ctrie_test.go2:6
func instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0bool୮9(addr **instantiate୦୦mainNode୦୮6୮7byte୦bool,
//line ctrie_test.go2:8
 val *instantiate୦୦mainNode୦୮6୮7byte୦bool,) {
//line ctrie_test.go2:8
 atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(addr)), unsafe.Pointer(val))
//line ctrie_test.go2:10
}

//line ctrie_test.go2:10
type instantiate୦୦tNode୦୮6୮7byte୦bool struct {
//line ctrie.go2:733
 sNode *instantiate୦୦sNode୦୮6୮7byte୦bool
}

//line ctrie.go2:737
func (t *instantiate୦୦tNode୦୮6୮7byte୦bool,) untombed() *instantiate୦୦sNode୦୮6୮7byte୦bool {
	return &instantiate୦୦sNode୦୮6୮7byte୦bool{&instantiate୦୦mapEntry୦୮6୮7byte୦bool{
		key:   t.sNode.entry.key,
		value: t.sNode.entry.value,
		hash:  t.sNode.entry.hash,
	}}
}

//line ctrie.go2:743
type instantiate୦୦lNode୦୮6୮7byte୦bool struct {
//line ctrie.go2:748
 head *instantiate୦୦sNode୦୮6୮7byte୦bool
	tail *instantiate୦୦lNode୦୮6୮7byte୦bool
}

//line ctrie.go2:754
func (l *instantiate୦୦lNode୦୮6୮7byte୦bool,) lookup(e *instantiate୦୦mapEntry୦୮6୮7byte୦bool, eq func([]byte, []byte,

//line ctrie.go2:754
) bool) (bool,

//line ctrie.go2:754
 bool) {
	for ; l != nil; l = l.tail {
		if eq(e.key, l.head.entry.key) {
			return l.head.entry.value, true
		}
	}
	return instantiate୦୦z୦bool(), false
}

//line ctrie.go2:764
func (l *instantiate୦୦lNode୦୮6୮7byte୦bool,) inserted(entry *instantiate୦୦mapEntry୦୮6୮7byte୦bool, eq func([]byte, []byte,

//line ctrie.go2:764
) bool) *instantiate୦୦lNode୦୮6୮7byte୦bool {
	return &instantiate୦୦lNode୦୮6୮7byte୦bool{
		head: &instantiate୦୦sNode୦୮6୮7byte୦bool{entry},
		tail: l.removed(entry, eq),
	}
}

//line ctrie.go2:772
func (l *instantiate୦୦lNode୦୮6୮7byte୦bool,) removed(e *instantiate୦୦mapEntry୦୮6୮7byte୦bool, eq func([]byte, []byte,

//line ctrie.go2:772
) bool) *instantiate୦୦lNode୦୮6୮7byte୦bool {
	for l1 := l; l1 != nil; l1 = l1.tail {
		if eq(e.key, l1.head.entry.key) {
			return l.remove(l1)
		}
	}
	return l
}

func (l *instantiate୦୦lNode୦୮6୮7byte୦bool,) remove(l1 *instantiate୦୦lNode୦୮6୮7byte୦bool,) *instantiate୦୦lNode୦୮6୮7byte୦bool {
	if l == l1 {
		return l.tail
	}
	return &instantiate୦୦lNode୦୮6୮7byte୦bool{
		head: l.head,
		tail: l.tail.remove(l1),
	}
}
//line ctrie_test.go2:4
func instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0string୮9(addr **instantiate୦୦mainNode୦୮6୮7byte୦string) *instantiate୦୦mainNode୦୮6୮7byte୦string {
//line ctrie_test.go2:4
 return (*instantiate୦୦mainNode୦୮6୮7byte୦string)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:6
 ))))
//line ctrie_test.go2:6
}

//line ctrie.go2:926
func instantiate୦୦gcasComplete୦୮6୮7byte୦string(i *instantiate୦୦iNode୦୮6୮7byte୦string, m *instantiate୦୦mainNode୦୮6୮7byte୦string, ctrie *instantiate୦୦Map୦୮6୮7byte୦string,) *instantiate୦୦mainNode୦୮6୮7byte୦string {
	for {
		if m == nil {
			return nil
		}
		prev := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0string୮9(&m.prev)
		root := ctrie.rdcssReadRoot(true)
		if prev == nil {
			return m
		}

		if prev.failed != nil {

			fn := prev.failed
			if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0string୮9(&i.main, m, fn) {
				return fn
			}
			m = instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0string୮9(&i.main)
			continue
		}

		if root.gen == i.gen && !ctrie.readOnly {

			if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0string୮9(&m.prev, prev, nil) {
				return m
			}
			continue
		}
//line ctrie.go2:953
  instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0string୮9(&m.prev, prev, &instantiate୦୦mainNode୦୮6୮7byte୦string{failed: prev})
//line ctrie.go2:958
  m = instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0string୮9(&i.main)
		return instantiate୦୦gcasComplete୦୮6୮7byte୦string(i, m, ctrie)
	}
}

//line ctrie.go2:961
type instantiate୦୦iterFrame୦୮6୮7byte୦string struct {
//line ctrie.go2:256
 iter  func(*instantiate୦୦Iter୦୮6୮7byte୦string, *instantiate୦୦iterFrame୦୮6୮7byte୦string,) bool
			iNode *instantiate୦୦iNode୦୮6୮7byte୦string
			slice []branch
			lNode *instantiate୦୦lNode୦୮6୮7byte୦string
}

//line ctrie.go2:1047
func instantiate୦୦z୦୮6୮7byte() []byte {
			var v []byte

//line ctrie.go2:1049
 return v
}
//line ctrie_test.go2:10
func instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0string୮9(addr **instantiate୦୦mainNode୦୮6୮7byte୦string, old, new *instantiate୦୦mainNode୦୮6୮7byte୦string,) (swapped bool) {
	return atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(addr)),
//line ctrie_test.go2:13
  unsafe.Pointer(old), unsafe.Pointer(new))
//line ctrie_test.go2:13
}

//line ctrie.go2:823
func instantiate୦୦toCompressed୦୮6୮7byte୦string(cn *instantiate୦୦cNode୦୮6୮7byte୦string, lev uint) *instantiate୦୦mainNode୦୮6୮7byte୦string {
	tmpSlice := make([]branch, len(cn.slice))
	for i, sub := range cn.slice {
		switch sub := sub.(type) {
		case *instantiate୦୦iNode୦୮6୮7byte୦string:
			inode := sub
			main := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0string୮9(&inode.main)
			tmpSlice[i] = instantiate୦୦resurrect୦୮6୮7byte୦string(inode, main)
		case *instantiate୦୦sNode୦୮6୮7byte୦string:
			tmpSlice[i] = sub
		default:
			panic("Map is in an invalid state")
		}
	}

	return instantiate୦୦toContracted୦୮6୮7byte୦string(&instantiate୦୦cNode୦୮6୮7byte୦string{
		bmp:   cn.bmp,
		slice: tmpSlice,
	}, lev)
}

//line ctrie.go2:848
func instantiate୦୦resurrect୦୮6୮7byte୦string(iNode *instantiate୦୦iNode୦୮6୮7byte୦string, main *instantiate୦୦mainNode୦୮6୮7byte୦string,) branch {
	if main.tNode != nil {
		return main.tNode.untombed()
	}
	return iNode
}
//line ctrie_test.go2:4
func instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0int୮9(addr **instantiate୦୦mainNode୦୮6୮7byte୦int) *instantiate୦୦mainNode୦୮6୮7byte୦int {
//line ctrie_test.go2:4
 return (*instantiate୦୦mainNode୦୮6୮7byte୦int)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:6
 ))))
//line ctrie_test.go2:6
}

//line ctrie.go2:926
func instantiate୦୦gcasComplete୦୮6୮7byte୦int(i *instantiate୦୦iNode୦୮6୮7byte୦int, m *instantiate୦୦mainNode୦୮6୮7byte୦int, ctrie *instantiate୦୦Map୦୮6୮7byte୦int,) *instantiate୦୦mainNode୦୮6୮7byte୦int {
	for {
		if m == nil {
			return nil
		}
		prev := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0int୮9(&m.prev)
		root := ctrie.rdcssReadRoot(true)
		if prev == nil {
			return m
		}

		if prev.failed != nil {

			fn := prev.failed
			if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0int୮9(&i.main, m, fn) {
				return fn
			}
			m = instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0int୮9(&i.main)
			continue
		}

		if root.gen == i.gen && !ctrie.readOnly {

			if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0int୮9(&m.prev, prev, nil) {
				return m
			}
			continue
		}
//line ctrie.go2:953
  instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0int୮9(&m.prev, prev, &instantiate୦୦mainNode୦୮6୮7byte୦int{failed: prev})
//line ctrie.go2:958
  m = instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0int୮9(&i.main)
		return instantiate୦୦gcasComplete୦୮6୮7byte୦int(i, m, ctrie)
	}
}

//line ctrie.go2:961
type instantiate୦୦iterFrame୦୮6୮7byte୦int struct {
//line ctrie.go2:256
 iter  func(*instantiate୦୦Iter୦୮6୮7byte୦int, *instantiate୦୦iterFrame୦୮6୮7byte୦int,) bool
			iNode *instantiate୦୦iNode୦୮6୮7byte୦int
			slice []branch
			lNode *instantiate୦୦lNode୦୮6୮7byte୦int
}

//line ctrie_test.go2:10
func instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0int୮9(addr **instantiate୦୦mainNode୦୮6୮7byte୦int, old, new *instantiate୦୦mainNode୦୮6୮7byte୦int,) (swapped bool) {
	return atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(addr)),
//line ctrie_test.go2:13
  unsafe.Pointer(old), unsafe.Pointer(new))
//line ctrie_test.go2:13
}

//line ctrie.go2:823
func instantiate୦୦toCompressed୦୮6୮7byte୦int(cn *instantiate୦୦cNode୦୮6୮7byte୦int, lev uint) *instantiate୦୦mainNode୦୮6୮7byte୦int {
	tmpSlice := make([]branch, len(cn.slice))
	for i, sub := range cn.slice {
		switch sub := sub.(type) {
		case *instantiate୦୦iNode୦୮6୮7byte୦int:
			inode := sub
			main := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0int୮9(&inode.main)
			tmpSlice[i] = instantiate୦୦resurrect୦୮6୮7byte୦int(inode, main)
		case *instantiate୦୦sNode୦୮6୮7byte୦int:
			tmpSlice[i] = sub
		default:
			panic("Map is in an invalid state")
		}
	}

	return instantiate୦୦toContracted୦୮6୮7byte୦int(&instantiate୦୦cNode୦୮6୮7byte୦int{
		bmp:   cn.bmp,
		slice: tmpSlice,
	}, lev)
}

//line ctrie.go2:848
func instantiate୦୦resurrect୦୮6୮7byte୦int(iNode *instantiate୦୦iNode୦୮6୮7byte୦int, main *instantiate୦୦mainNode୦୮6୮7byte୦int,) branch {
	if main.tNode != nil {
		return main.tNode.untombed()
	}
	return iNode
}
//line ctrie_test.go2:4
func instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0interface୮4୮5୮9(addr **instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5) *instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5 {
//line ctrie_test.go2:4
 return (*instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:6
 ))))
//line ctrie_test.go2:6
}

//line ctrie.go2:926
func instantiate୦୦gcasComplete୦୮6୮7byte୦interface୮4୮5(i *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5, m *instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5, ctrie *instantiate୦୦Map୦୮6୮7byte୦interface୮4୮5,) *instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5 {
	for {
		if m == nil {
			return nil
		}
		prev := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0interface୮4୮5୮9(&m.prev)
		root := ctrie.rdcssReadRoot(true)
		if prev == nil {
			return m
		}

		if prev.failed != nil {

			fn := prev.failed
			if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0interface୮4୮5୮9(&i.main, m, fn) {
				return fn
			}
			m = instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0interface୮4୮5୮9(&i.main)
			continue
		}

		if root.gen == i.gen && !ctrie.readOnly {

			if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0interface୮4୮5୮9(&m.prev, prev, nil) {
				return m
			}
			continue
		}
//line ctrie.go2:953
  instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0interface୮4୮5୮9(&m.prev, prev, &instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5{failed: prev})
//line ctrie.go2:958
  m = instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0interface୮4୮5୮9(&i.main)
		return instantiate୦୦gcasComplete୦୮6୮7byte୦interface୮4୮5(i, m, ctrie)
	}
}

//line ctrie.go2:961
type instantiate୦୦iterFrame୦୮6୮7byte୦interface୮4୮5 struct {
//line ctrie.go2:256
 iter  func(*instantiate୦୦Iter୦୮6୮7byte୦interface୮4୮5, *instantiate୦୦iterFrame୦୮6୮7byte୦interface୮4୮5,) bool
			iNode *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5
			slice []branch
			lNode *instantiate୦୦lNode୦୮6୮7byte୦interface୮4୮5
}

//line ctrie_test.go2:10
func instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0interface୮4୮5୮9(addr **instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5, old, new *instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5,) (swapped bool) {
	return atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(addr)),
//line ctrie_test.go2:13
  unsafe.Pointer(old), unsafe.Pointer(new))
//line ctrie_test.go2:13
}

//line ctrie.go2:823
func instantiate୦୦toCompressed୦୮6୮7byte୦interface୮4୮5(cn *instantiate୦୦cNode୦୮6୮7byte୦interface୮4୮5, lev uint) *instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5 {
	tmpSlice := make([]branch, len(cn.slice))
	for i, sub := range cn.slice {
		switch sub := sub.(type) {
		case *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5:
			inode := sub
			main := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0interface୮4୮5୮9(&inode.main)
			tmpSlice[i] = instantiate୦୦resurrect୦୮6୮7byte୦interface୮4୮5(inode, main)
		case *instantiate୦୦sNode୦୮6୮7byte୦interface୮4୮5:
			tmpSlice[i] = sub
		default:
			panic("Map is in an invalid state")
		}
	}

	return instantiate୦୦toContracted୦୮6୮7byte୦interface୮4୮5(&instantiate୦୦cNode୦୮6୮7byte୦interface୮4୮5{
		bmp:   cn.bmp,
		slice: tmpSlice,
	}, lev)
}

//line ctrie.go2:848
func instantiate୦୦resurrect୦୮6୮7byte୦interface୮4୮5(iNode *instantiate୦୦iNode୦୮6୮7byte୦interface୮4୮5, main *instantiate୦୦mainNode୦୮6୮7byte୦interface୮4୮5,) branch {
	if main.tNode != nil {
		return main.tNode.untombed()
	}
	return iNode
}
//line ctrie_test.go2:4
func instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0bool୮9(addr **instantiate୦୦mainNode୦୮6୮7byte୦bool) *instantiate୦୦mainNode୦୮6୮7byte୦bool {
//line ctrie_test.go2:4
 return (*instantiate୦୦mainNode୦୮6୮7byte୦bool)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:6
 ))))
//line ctrie_test.go2:6
}

//line ctrie.go2:926
func instantiate୦୦gcasComplete୦୮6୮7byte୦bool(i *instantiate୦୦iNode୦୮6୮7byte୦bool, m *instantiate୦୦mainNode୦୮6୮7byte୦bool, ctrie *instantiate୦୦Map୦୮6୮7byte୦bool,) *instantiate୦୦mainNode୦୮6୮7byte୦bool {
	for {
		if m == nil {
			return nil
		}
		prev := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0bool୮9(&m.prev)
		root := ctrie.rdcssReadRoot(true)
		if prev == nil {
			return m
		}

		if prev.failed != nil {

			fn := prev.failed
			if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0bool୮9(&i.main, m, fn) {
				return fn
			}
			m = instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0bool୮9(&i.main)
			continue
		}

		if root.gen == i.gen && !ctrie.readOnly {

			if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0bool୮9(&m.prev, prev, nil) {
				return m
			}
			continue
		}
//line ctrie.go2:953
  instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0bool୮9(&m.prev, prev, &instantiate୦୦mainNode୦୮6୮7byte୦bool{failed: prev})
//line ctrie.go2:958
  m = instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0bool୮9(&i.main)
		return instantiate୦୦gcasComplete୦୮6୮7byte୦bool(i, m, ctrie)
	}
}

//line ctrie.go2:961
type instantiate୦୦iterFrame୦୮6୮7byte୦bool struct {
//line ctrie.go2:256
 iter  func(*instantiate୦୦Iter୦୮6୮7byte୦bool, *instantiate୦୦iterFrame୦୮6୮7byte୦bool,) bool
			iNode *instantiate୦୦iNode୦୮6୮7byte୦bool
			slice []branch
			lNode *instantiate୦୦lNode୦୮6୮7byte୦bool
}

//line ctrie_test.go2:10
func instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0bool୮9(addr **instantiate୦୦mainNode୦୮6୮7byte୦bool, old, new *instantiate୦୦mainNode୦୮6୮7byte୦bool,) (swapped bool) {
	return atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(addr)),
//line ctrie_test.go2:13
  unsafe.Pointer(old), unsafe.Pointer(new))
//line ctrie_test.go2:13
}

//line ctrie.go2:823
func instantiate୦୦toCompressed୦୮6୮7byte୦bool(cn *instantiate୦୦cNode୦୮6୮7byte୦bool, lev uint) *instantiate୦୦mainNode୦୮6୮7byte୦bool {
	tmpSlice := make([]branch, len(cn.slice))
	for i, sub := range cn.slice {
		switch sub := sub.(type) {
		case *instantiate୦୦iNode୦୮6୮7byte୦bool:
			inode := sub
			main := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8୮6୮7byte୮3୮0bool୮9(&inode.main)
			tmpSlice[i] = instantiate୦୦resurrect୦୮6୮7byte୦bool(inode, main)
		case *instantiate୦୦sNode୦୮6୮7byte୦bool:
			tmpSlice[i] = sub
		default:
			panic("Map is in an invalid state")
		}
	}

	return instantiate୦୦toContracted୦୮6୮7byte୦bool(&instantiate୦୦cNode୦୮6୮7byte୦bool{
		bmp:   cn.bmp,
		slice: tmpSlice,
	}, lev)
}

//line ctrie.go2:848
func instantiate୦୦resurrect୦୮6୮7byte୦bool(iNode *instantiate୦୦iNode୦୮6୮7byte୦bool, main *instantiate୦୦mainNode୦୮6୮7byte୦bool,) branch {
	if main.tNode != nil {
		return main.tNode.untombed()
	}
	return iNode
}

//line ctrie.go2:853
type _ bytes.Buffer

//line ctrie.go2:853
var _ = fmt.Errorf

//line ctrie.go2:853
type _ gatomic.Importable୦
//line ctrie.go2:853
type _ maphash.Hash

//line ctrie.go2:853
var _ = bits.Add
//line ctrie.go2:853
var _ = strconv.AppendBool

//line ctrie.go2:853
type _ sync.Cond

//line ctrie.go2:853
var _ = atomic.AddInt32
//line ctrie.go2:853
var _ = testing.AllocsPerRun

//line ctrie.go2:853
const _ = time.ANSIC

//line ctrie.go2:853
type _ unsafe.Pointer
