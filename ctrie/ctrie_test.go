// Code generated by go2go; DO NOT EDIT.


//line ctrie_test.go2:17
package ctrie

//line ctrie_test.go2:17
import (
//line ctrie_test.go2:17
 "bytes"
//line ctrie_test.go2:17
 "errors"
//line ctrie_test.go2:17
 "github.com/rogpeppe/generic/gatomic"
//line ctrie_test.go2:17
 "hash"
//line ctrie_test.go2:17
 "hash/fnv"
//line ctrie_test.go2:17
 "strconv"
//line ctrie_test.go2:17
 "sync"
//line ctrie_test.go2:17
 "sync/atomic"
//line ctrie_test.go2:17
 "testing"
//line ctrie_test.go2:17
 "time"
//line ctrie_test.go2:17
 "unsafe"
//line ctrie_test.go2:17
)

//line ctrie_test.go2:28
func TestCtrie(t *testing.T) {
				ctrie := instantiate୦୦New୦string(nil)

				_, ok := ctrie.Lookup([]byte("foo"))
				assertFalse(t, ok)

				ctrie.Insert([]byte("foo"), "bar")
				val, ok := ctrie.Lookup([]byte("foo"))
				assertTrue(t, ok)
//line ctrie_test.go2:36
 instantiate୦୦assertEqual୦string(t, "bar", val)

//line ctrie_test.go2:39
 ctrie.Insert([]byte("fooooo"), "baz")
				val, ok = ctrie.Lookup([]byte("foo"))
				assertTrue(t, ok)
//line ctrie_test.go2:41
 instantiate୦୦assertEqual୦string(t, "bar", val)
//line ctrie_test.go2:43
 val, ok = ctrie.Lookup([]byte("fooooo"))
				assertTrue(t, ok)
//line ctrie_test.go2:44
 instantiate୦୦assertEqual୦string(t, "baz", val)

//line ctrie_test.go2:47
 for i := 0; i < 100; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), "blah")
	}
	for i := 0; i < 100; i++ {
					val, ok = ctrie.Lookup([]byte(strconv.Itoa(i)))
					assertTrue(t, ok)
//line ctrie_test.go2:52
  instantiate୦୦assertEqual୦string(t, "blah", val)
//line ctrie_test.go2:54
 }

				val, ok = ctrie.Lookup([]byte("foo"))
				assertTrue(t, ok)
//line ctrie_test.go2:57
 instantiate୦୦assertEqual୦string(t, "bar", val)
//line ctrie_test.go2:59
 ctrie.Insert([]byte("foo"), "qux")
				val, ok = ctrie.Lookup([]byte("foo"))
				assertTrue(t, ok)
//line ctrie_test.go2:61
 instantiate୦୦assertEqual୦string(t, "qux", val)

//line ctrie_test.go2:64
 val, ok = ctrie.Remove([]byte("foo"))
				assertTrue(t, ok)
//line ctrie_test.go2:65
 instantiate୦୦assertEqual୦string(t, "qux", val)

//line ctrie_test.go2:68
 _, ok = ctrie.Remove([]byte("foo"))
				assertFalse(t, ok)

				val, ok = ctrie.Remove([]byte("fooooo"))
				assertTrue(t, ok)
//line ctrie_test.go2:72
 instantiate୦୦assertEqual୦string(t, "baz", val)

//line ctrie_test.go2:75
 for i := 0; i < 100; i++ {
		ctrie.Remove([]byte(strconv.Itoa(i)))
	}
}

type mockHash32 struct {
	hash.Hash32
}

func (m *mockHash32) Sum32() uint32 {
	return 0
}

func mockHashFactory() hash.Hash32 {
	return &mockHash32{fnv.New32a()}
}

func TestInsertLNode(t *testing.T) {
	ctrie := instantiate୦୦New୦int(mockHashFactory)

	for i := 0; i < 10; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}

	for i := 0; i < 10; i++ {
					val, ok := ctrie.Lookup([]byte(strconv.Itoa(i)))
					assertTrue(t, ok)
//line ctrie_test.go2:101
  instantiate୦୦assertEqual୦int(t, i, val)
//line ctrie_test.go2:103
 }
	_, ok := ctrie.Lookup([]byte("11"))
	assertFalse(t, ok)

	for i := 0; i < 10; i++ {
					val, ok := ctrie.Remove([]byte(strconv.Itoa(i)))
					assertTrue(t, ok)
//line ctrie_test.go2:109
  instantiate୦୦assertEqual୦int(t, i, val)
//line ctrie_test.go2:111
 }
}

func TestInsertTNode(t *testing.T) {
	ctrie := instantiate୦୦New୦int(nil)

	for i := 0; i < 10000; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}

	for i := 0; i < 5000; i++ {
		ctrie.Remove([]byte(strconv.Itoa(i)))
	}

	for i := 0; i < 10000; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}

	for i := 0; i < 10000; i++ {
					val, ok := ctrie.Lookup([]byte(strconv.Itoa(i)))
					assertTrue(t, ok)
//line ctrie_test.go2:131
  instantiate୦୦assertEqual୦int(t, i, val)
//line ctrie_test.go2:133
 }
}

func TestConcurrency(t *testing.T) {
	ctrie := instantiate୦୦New୦int(nil)
	var wg sync.WaitGroup
	wg.Add(2)

	go func() {
		for i := 0; i < 10000; i++ {
			ctrie.Insert([]byte(strconv.Itoa(i)), i)
		}
		wg.Done()
	}()

	go func() {
		for i := 0; i < 10000; i++ {
			val, ok := ctrie.Lookup([]byte(strconv.Itoa(i)))
			if ok {
//line ctrie_test.go2:151
    instantiate୦୦assertEqual୦int(t, i, val)
//line ctrie_test.go2:153
   }
		}
		wg.Done()
	}()

	for i := 0; i < 10000; i++ {
		time.Sleep(5)
		ctrie.Remove([]byte(strconv.Itoa(i)))
	}

	wg.Wait()
}

func TestConcurrency2(t *testing.T) {
	ctrie := instantiate୦୦New୦int(nil)
	var wg sync.WaitGroup
	wg.Add(4)

	go func() {
		for i := 0; i < 10000; i++ {
			ctrie.Insert([]byte(strconv.Itoa(i)), i)
		}
		wg.Done()
	}()

	go func() {
		for i := 0; i < 10000; i++ {
			val, ok := ctrie.Lookup([]byte(strconv.Itoa(i)))
			if ok {
//line ctrie_test.go2:181
    instantiate୦୦assertEqual୦int(t, i, val)
//line ctrie_test.go2:183
   }
		}
		wg.Done()
	}()

	go func() {
		for i := 0; i < 10000; i++ {
			ctrie.Snapshot()
		}
		wg.Done()
	}()

	go func() {
		for i := 0; i < 10000; i++ {
			ctrie.ReadOnlySnapshot()
		}
		wg.Done()
	}()

				wg.Wait()
//line ctrie_test.go2:202
 instantiate୦୦assertEqual୦int(t, 10000, ctrie.Len())
//line ctrie_test.go2:204
}

func TestSnapshot(t *testing.T) {
	ctrie := instantiate୦୦New୦interface୮4୮5(nil)
	for i := 0; i < 100; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}

				snapshot := ctrie.Snapshot()

//line ctrie_test.go2:215
 for i := 0; i < 100; i++ {
					val, ok := snapshot.Lookup([]byte(strconv.Itoa(i)))
					assertTrue(t, ok)
//line ctrie_test.go2:217
  instantiate୦୦assertEqual୦interface୮4୮5(t, interface{}(i), val)
//line ctrie_test.go2:219
 }

//line ctrie_test.go2:222
 for i := 0; i < 100; i++ {
		ctrie.Remove([]byte(strconv.Itoa(i)))
	}

//line ctrie_test.go2:227
 for i := 0; i < 100; i++ {
					val, ok := snapshot.Lookup([]byte(strconv.Itoa(i)))
					assertTrue(t, ok)
//line ctrie_test.go2:229
  instantiate୦୦assertEqual୦interface୮4୮5(t, interface{}(i), val)
//line ctrie_test.go2:231
 }

//line ctrie_test.go2:234
 ctrie = instantiate୦୦New୦interface୮4୮5(nil)
	for i := 0; i < 100; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
				snapshot = ctrie.Snapshot()

//line ctrie_test.go2:241
 for i := 0; i < 100; i++ {
		snapshot.Remove([]byte(strconv.Itoa(i)))
	}
	snapshot.Insert([]byte("bat"), "man")

	for i := 0; i < 100; i++ {
		_, ok := snapshot.Lookup([]byte(strconv.Itoa(i)))
		assertFalse(t, ok)
	}
				val, ok := snapshot.Lookup([]byte("bat"))
				assertTrue(t, ok)
//line ctrie_test.go2:251
 instantiate୦୦assertEqual୦interface୮4୮5(t, "man", val)

//line ctrie_test.go2:255
 for i := 0; i < 100; i++ {
					val, ok := ctrie.Lookup([]byte(strconv.Itoa(i)))
					assertTrue(t, ok)
//line ctrie_test.go2:257
  instantiate୦୦assertEqual୦interface୮4୮5(t, interface{}(i), val)
//line ctrie_test.go2:259
 }
				_, ok = ctrie.Lookup([]byte("bat"))
				assertFalse(t, ok)

//line ctrie_test.go2:264
 snapshot2 := snapshot.Snapshot()
	for i := 0; i < 100; i++ {
		_, ok := snapshot2.Lookup([]byte(strconv.Itoa(i)))
		assertFalse(t, ok)
	}
				val, ok = snapshot2.Lookup([]byte("bat"))
				assertTrue(t, ok)
//line ctrie_test.go2:270
 instantiate୦୦assertEqual୦interface୮4୮5(t, "man", val)

//line ctrie_test.go2:273
 snapshot2.Remove([]byte("bat"))
				_, ok = snapshot2.Lookup([]byte("bat"))
				assertFalse(t, ok)
				val, ok = snapshot.Lookup([]byte("bat"))
				assertTrue(t, ok)
//line ctrie_test.go2:277
 instantiate୦୦assertEqual୦interface୮4୮5(t, "man", val)
//line ctrie_test.go2:279
}

func TestReadOnlySnapshot(t *testing.T) {
	ctrie := instantiate୦୦New୦int(nil)
	for i := 0; i < 100; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}

				snapshot := ctrie.ReadOnlySnapshot()

//line ctrie_test.go2:290
 for i := 0; i < 100; i++ {
					val, ok := snapshot.Lookup([]byte(strconv.Itoa(i)))
					assertTrue(t, ok)
//line ctrie_test.go2:292
  instantiate୦୦assertEqual୦int(t, i, val)
//line ctrie_test.go2:294
 }

	for i := 0; i < 50; i++ {
		ctrie.Remove([]byte(strconv.Itoa(i)))
	}

//line ctrie_test.go2:301
 for i := 0; i < 100; i++ {
					val, ok := snapshot.Lookup([]byte(strconv.Itoa(i)))
					assertTrue(t, ok)
//line ctrie_test.go2:303
  instantiate୦୦assertEqual୦int(t, i, val)
//line ctrie_test.go2:305
 }

//line ctrie_test.go2:308
 func() {
		defer func() {
			assertNotNil(t, recover())
		}()
		snapshot.Remove([]byte("blah"))
	}()

//line ctrie_test.go2:316
 snapshot2 := snapshot.Snapshot()
	for i := 50; i < 100; i++ {
		ctrie.Remove([]byte(strconv.Itoa(i)))
	}
	for i := 0; i < 100; i++ {
					val, ok := snapshot2.Lookup([]byte(strconv.Itoa(i)))
					assertTrue(t, ok)
//line ctrie_test.go2:322
  instantiate୦୦assertEqual୦int(t, i, val)
//line ctrie_test.go2:324
 }

//line ctrie_test.go2:327
 func() {
		defer func() {
			assertNotNil(t, recover())
		}()
		snapshot2.Remove([]byte("blah"))
	}()
}

func TestIterator(t *testing.T) {
	ctrie := instantiate୦୦New୦int(nil)
	for i := 0; i < 10; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
	expected := map[string]int{
		"0": 0,
		"1": 1,
		"2": 2,
		"3": 3,
		"4": 4,
		"5": 5,
		"6": 6,
		"7": 7,
		"8": 8,
		"9": 9,
	}

	count := 0
	for iter := ctrie.Iterator(); iter.Next(); {
		exp, ok := expected[string(iter.Key())]
		if assertTrue(t, ok) {
//line ctrie_test.go2:356
   instantiate୦୦assertEqual୦int(t, exp, iter.Value())
//line ctrie_test.go2:358
  }
		count++
	}
//line ctrie_test.go2:360
 instantiate୦୦assertEqual୦int(t, len(expected), count)
//line ctrie_test.go2:362
}

//line ctrie_test.go2:365
func TestIteratorCoversTNodes(t *testing.T) {
				ctrie := instantiate୦୦New୦bool(mockHashFactory)

				ctrie.Insert([]byte("a"), true)
				ctrie.Insert([]byte("b"), true)

//line ctrie_test.go2:372
 ctrie.Remove([]byte("b"))
	seenKeys := map[string]bool{}
	for iter := ctrie.Iterator(); iter.Next(); {
		seenKeys[string(iter.Key())] = true
	}
	if !seenKeys["a"] {
		t.Errorf("Iterator did not return 'a'.")
	}
	if len(seenKeys) != 1 {
		t.Errorf("want 1 key got %d", len(seenKeys))
	}
}

func TestLen(t *testing.T) {
	ctrie := instantiate୦୦New୦int(nil)
	for i := 0; i < 10; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
//line ctrie_test.go2:389
 instantiate୦୦assertEqual୦int(t, 10, ctrie.Len())
//line ctrie_test.go2:391
}

func TestClear(t *testing.T) {
	ctrie := instantiate୦୦New୦int(nil)
	for i := 0; i < 10; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
//line ctrie_test.go2:397
 instantiate୦୦assertEqual୦int(t, 10, ctrie.Len())
//line ctrie_test.go2:399
 snapshot := ctrie.Snapshot()

				ctrie.Clear()
//line ctrie_test.go2:401
 instantiate୦୦assertEqual୦int(t, 0, ctrie.Len())
//line ctrie_test.go2:403
 instantiate୦୦assertEqual୦int(t, 10, snapshot.Len())
//line ctrie_test.go2:405
}

type fakehash struct{}

func (h *fakehash) Sum32() uint32 {
	return 42
}

func (h *fakehash) Sum(b []byte) []byte {
	return nil
}

func (h *fakehash) Size() int {
	return 0
}

func (h *fakehash) BlockSize() int {
	return 0
}

func (h *fakehash) Reset() {

}

func (h *fakehash) Write(b []byte) (int, error) {
	return 0, nil
}

func factory() hash.Hash32 {
	return &fakehash{}
}

func TestHashCollision(t *testing.T) {
				trie := instantiate୦୦New୦int(factory)
				trie.Insert([]byte("foobar"), 1)
				trie.Insert([]byte("zogzog"), 2)
				trie.Insert([]byte("foobar"), 3)
				val, exists := trie.Lookup([]byte("foobar"))
				assertTrue(t, exists)
//line ctrie_test.go2:443
 instantiate୦୦assertEqual୦int(t, 3, val)

//line ctrie_test.go2:446
 trie.Remove([]byte("foobar"))

	_, exists = trie.Lookup([]byte("foobar"))
	assertFalse(t, exists)
}

func BenchmarkInsert(b *testing.B) {
	ctrie := instantiate୦୦New୦int(nil)
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		ctrie.Insert([]byte("foo"), 0)
	}
}

func BenchmarkLookup(b *testing.B) {
	numItems := 1000
	ctrie := instantiate୦୦New୦int(nil)
	for i := 0; i < numItems; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
	key := []byte(strconv.Itoa(numItems / 2))
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ctrie.Lookup(key)
	}
}

func BenchmarkRemove(b *testing.B) {
	numItems := 1000
	ctrie := instantiate୦୦New୦int(nil)
	for i := 0; i < numItems; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
	key := []byte(strconv.Itoa(numItems / 2))
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ctrie.Remove(key)
	}
}

func BenchmarkSnapshot(b *testing.B) {
	numItems := 1000
	ctrie := instantiate୦୦New୦int(nil)
	for i := 0; i < numItems; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ctrie.Snapshot()
	}
}

func BenchmarkReadOnlySnapshot(b *testing.B) {
	numItems := 1000
	ctrie := instantiate୦୦New୦int(nil)
	for i := 0; i < numItems; i++ {
		ctrie.Insert([]byte(strconv.Itoa(i)), i)
	}
	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		ctrie.ReadOnlySnapshot()
	}
}

func assertTrue(t *testing.T, x bool) bool {
	t.Helper()
	if !x {
		t.Errorf("not true")
		return false
	}
	return true
}

func assertFalse(t *testing.T, x bool) {
	t.Helper()
	if x {
		t.Errorf("not false")
	}
}

//line ctrie_test.go2:537
func assertNotNil(t *testing.T, x interface{}) {
	t.Helper()
	if x == nil {
		t.Errorf("want non-nil, got nil")
	}
}
//line ctrie.go2:270
func instantiate୦୦New୦string(hashFactory HashFactory) *instantiate୦୦Ctrie୦string {
	if hashFactory == nil {
		hashFactory = defaultHashFactory
	}
	root := &instantiate୦୦iNode୦string{main: &instantiate୦୦mainNode୦string{cNode: &instantiate୦୦cNode୦string{}}}
	return instantiate୦୦newCtrie୦string(root, hashFactory, false)
}

//line ctrie_test.go2:530
func instantiate୦୦assertEqual୦string(t *testing.T, x, y string,) {
	t.Helper()
	if x != y {
		t.Errorf("not equal, got %#v want %#v", y, x)
	}
}
//line ctrie.go2:270
func instantiate୦୦New୦int(hashFactory HashFactory) *instantiate୦୦Ctrie୦int {
	if hashFactory == nil {
		hashFactory = defaultHashFactory
	}
	root := &instantiate୦୦iNode୦int{main: &instantiate୦୦mainNode୦int{cNode: &instantiate୦୦cNode୦int{}}}
	return instantiate୦୦newCtrie୦int(root, hashFactory, false)
}

//line ctrie_test.go2:530
func instantiate୦୦assertEqual୦int(t *testing.T, x, y int,) {
	t.Helper()
	if x != y {
		t.Errorf("not equal, got %#v want %#v", y, x)
	}
}
//line ctrie.go2:270
func instantiate୦୦New୦interface୮4୮5(hashFactory HashFactory) *instantiate୦୦Ctrie୦interface୮4୮5 {
	if hashFactory == nil {
		hashFactory = defaultHashFactory
	}
	root := &instantiate୦୦iNode୦interface୮4୮5{main: &instantiate୦୦mainNode୦interface୮4୮5{cNode: &instantiate୦୦cNode୦interface୮4୮5{}}}
	return instantiate୦୦newCtrie୦interface୮4୮5(root, hashFactory, false)
}

//line ctrie_test.go2:530
func instantiate୦୦assertEqual୦interface୮4୮5(t *testing.T, x, y interface {
//line ctrie_test.go2:530
}) {
	t.Helper()
	if x != y {
		t.Errorf("not equal, got %#v want %#v", y, x)
	}
}
//line ctrie.go2:270
func instantiate୦୦New୦bool(hashFactory HashFactory) *instantiate୦୦Ctrie୦bool {
	if hashFactory == nil {
		hashFactory = defaultHashFactory
	}
	root := &instantiate୦୦iNode୦bool{main: &instantiate୦୦mainNode୦bool{cNode: &instantiate୦୦cNode୦bool{}}}
	return instantiate୦୦newCtrie୦bool(root, hashFactory, false)
}

//line ctrie.go2:276
type instantiate୦୦Ctrie୦string struct {
//line ctrie.go2:52
 root        *instantiate୦୦iNode୦string
			readOnly    bool
			hashFactory HashFactory
}

//line ctrie.go2:288
func (c *instantiate୦୦Ctrie୦string,) Insert(key []byte, value string,

//line ctrie.go2:288
) {
	c.assertReadWrite()
	c.insert(&instantiate୦୦Entry୦string{
		Key:   key,
		Value: value,
		hash:  c.hash(key),
	})
}

//line ctrie.go2:299
func (c *instantiate୦୦Ctrie୦string,) Lookup(key []byte) (string,

//line ctrie.go2:299
 bool) {
	return c.lookup(&instantiate୦୦Entry୦string{Key: key, hash: c.hash(key)})
}

//line ctrie.go2:305
func (c *instantiate୦୦Ctrie୦string,) Remove(key []byte) (string,

//line ctrie.go2:305
 bool) {
	c.assertReadWrite()
	return c.remove(&instantiate୦୦Entry୦string{Key: key, hash: c.hash(key)})
}

//line ctrie.go2:312
func (c *instantiate୦୦Ctrie୦string,) Snapshot() *instantiate୦୦Ctrie୦string {
	return c.snapshot(c.readOnly)
}

//line ctrie.go2:318
func (c *instantiate୦୦Ctrie୦string,) ReadOnlySnapshot() *instantiate୦୦Ctrie୦string {
	return c.snapshot(true)
}

//line ctrie.go2:323
func (c *instantiate୦୦Ctrie୦string,) snapshot(readOnly bool) *instantiate୦୦Ctrie୦string {
	if readOnly && c.readOnly {
		return c
	}
	for {
		root := c.readRoot()
		main := instantiate୦୦gcasRead୦string(root, c)
		if c.rdcssRoot(root, main, root.copyToGen(&generation{}, c)) {
			if readOnly {

//line ctrie.go2:334
    return instantiate୦୦newCtrie୦string(root, c.hashFactory, readOnly)
			}

//line ctrie.go2:338
   return instantiate୦୦newCtrie୦string(c.readRoot().copyToGen(&generation{}, c), c.hashFactory, readOnly)
		}
	}
}

//line ctrie.go2:344
func (c *instantiate୦୦Ctrie୦string,) Clear() {
	for {
		root := c.readRoot()
		gen := &generation{}
		newRoot := &instantiate୦୦iNode୦string{
			main: &instantiate୦୦mainNode୦string{cNode: &instantiate୦୦cNode୦string{array: make([]branch, 0), gen: gen}},
			gen:  gen,
		}
		if c.rdcssRoot(root, instantiate୦୦gcasRead୦string(root, c), newRoot) {
			return
		}
	}
}

//line ctrie.go2:359
func (c *instantiate୦୦Ctrie୦string,) Len() int {

//line ctrie.go2:365
 size := 0
	for iter := c.Iterator(); iter.Next(); {
		size++
	}
	return size
}

//line ctrie.go2:375
func (c *instantiate୦୦Ctrie୦string,) Iterator() *instantiate୦୦Iter୦string {
	iter := &instantiate୦୦Iter୦string{
		c: c,
	}
	iter.push((*instantiate୦୦Iter୦string).mainIter).iNode = c.ReadOnlySnapshot().readRoot()
	return iter
}

//line ctrie.go2:485
func (c *instantiate୦୦Ctrie୦string,) assertReadWrite() {
	if c.readOnly {
		panic("Cannot modify read-only snapshot")
	}
}

func (c *instantiate୦୦Ctrie୦string,) insert(entry *instantiate୦୦Entry୦string,) {
	root := c.readRoot()
	if !c.iinsert(root, entry, 0, nil, root.gen) {
		c.insert(entry)
	}
}

func (c *instantiate୦୦Ctrie୦string,) lookup(entry *instantiate୦୦Entry୦string,) (string,

//line ctrie.go2:498
 bool) {
	root := c.readRoot()
	result, exists, ok := c.ilookup(root, entry, 0, nil, root.gen)
	for !ok {
		return c.lookup(entry)
	}
	return result, exists
}

func (c *instantiate୦୦Ctrie୦string,) remove(entry *instantiate୦୦Entry୦string,) (string,

//line ctrie.go2:507
 bool) {
	root := c.readRoot()
	result, exists, ok := c.iremove(root, entry, 0, nil, root.gen)
	for !ok {
		return c.remove(entry)
	}
	return result, exists
}

func (c *instantiate୦୦Ctrie୦string,) hash(k []byte) uint32 {
	hasher := c.hashFactory()
	hasher.Write(k)
	return hasher.Sum32()
}

//line ctrie.go2:524
func (c *instantiate୦୦Ctrie୦string,) iinsert(i *instantiate୦୦iNode୦string, entry *instantiate୦୦Entry୦string, lev uint, parent *instantiate୦୦iNode୦string, startGen *generation) bool {

	main := instantiate୦୦gcasRead୦string(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:535
   rn := cn
			if cn.gen != i.gen {
				rn = cn.renewed(i.gen, c)
			}
			ncn := &instantiate୦୦mainNode୦string{cNode: rn.inserted(pos, flag, &instantiate୦୦sNode୦string{entry}, i.gen)}
			return instantiate୦୦gcas୦string(i, main, ncn, c)
		}

//line ctrie.go2:544
  branch := cn.array[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦string:

			if startGen == branch.gen {
				return c.iinsert(branch, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦string(i, main, &instantiate୦୦mainNode୦string{cNode: cn.renewed(startGen, c)}, c) {
				return c.iinsert(i, entry, lev, parent, startGen)
			}
			return false
		case *instantiate୦୦sNode୦string:
			sn := branch
			if !bytes.Equal(sn.entry.Key, entry.Key) {

//line ctrie.go2:565
    rn := cn
				if cn.gen != i.gen {
					rn = cn.renewed(i.gen, c)
				}
				nsn := &instantiate୦୦sNode୦string{entry}
				nin := &instantiate୦୦iNode୦string{main: instantiate୦୦newMainNode୦string(sn, sn.entry.hash, nsn, nsn.entry.hash, lev+w, i.gen), gen: i.gen}
				ncn := &instantiate୦୦mainNode୦string{cNode: rn.updated(pos, nin, i.gen)}
				return instantiate୦୦gcas୦string(i, main, ncn, c)
			}

//line ctrie.go2:577
   ncn := &instantiate୦୦mainNode୦string{cNode: cn.updated(pos, &instantiate୦୦sNode୦string{entry}, i.gen)}
			return instantiate୦୦gcas୦string(i, main, ncn, c)
		default:
			panic("Ctrie is in an invalid state")
		}
	case main.tNode != nil:
//line ctrie.go2:582
  instantiate୦୦clean୦string(parent, lev-w, c)
//line ctrie.go2:584
  return false
	case main.lNode != nil:
		nln := &instantiate୦୦mainNode୦string{lNode: main.lNode.inserted(entry)}
		return instantiate୦୦gcas୦string(i, main, nln, c)
	default:
		panic("Ctrie is in an invalid state")
	}
}

//line ctrie.go2:597
func (c *instantiate୦୦Ctrie୦string,) ilookup(i *instantiate୦୦iNode୦string, entry *instantiate୦୦Entry୦string, lev uint, parent *instantiate୦୦iNode୦string, startGen *generation) (string,

//line ctrie.go2:597
 bool, bool) {

	main := instantiate୦୦gcasRead୦string(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:607
   return instantiate୦୦z୦string(), false, true
		}

		branch := cn.array[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦string:

//line ctrie.go2:615
   in := branch
			if c.readOnly || startGen == in.gen {
				return c.ilookup(in, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦string(i, main, &instantiate୦୦mainNode୦string{cNode: cn.renewed(startGen, c)}, c) {
				return c.ilookup(i, entry, lev, parent, startGen)
			}
			return instantiate୦୦z୦string(), false, false
		case *instantiate୦୦sNode୦string:

//line ctrie.go2:629
   sn := branch
			if bytes.Equal(sn.entry.Key, entry.Key) {
				return sn.entry.Value, true, true
			}
			return instantiate୦୦z୦string(), false, true
		default:
			panic("Ctrie is in an invalid state")
		}
	case main.tNode != nil:
		return instantiate୦୦cleanReadOnly୦string(main.tNode, lev, parent, c, entry)
	case main.lNode != nil:

//line ctrie.go2:642
  val, ok := main.lNode.lookup(entry)
		return val, ok, true
	default:
		panic("Ctrie is in an invalid state")
	}
}

//line ctrie.go2:653
func (c *instantiate୦୦Ctrie୦string,) iremove(i *instantiate୦୦iNode୦string, entry *instantiate୦୦Entry୦string, lev uint, parent *instantiate୦୦iNode୦string, startGen *generation) (string,

//line ctrie.go2:653
 bool, bool) {

	main := instantiate୦୦gcasRead୦string(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:663
   return instantiate୦୦z୦string(), false, true
		}

		branch := cn.array[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦string:

//line ctrie.go2:671
   in := branch
			if startGen == in.gen {
				return c.iremove(in, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦string(i, main, &instantiate୦୦mainNode୦string{cNode: cn.renewed(startGen, c)}, c) {
				return c.iremove(i, entry, lev, parent, startGen)
			}
			return instantiate୦୦z୦string(), false, false
		case *instantiate୦୦sNode୦string:

//line ctrie.go2:682
   sn := branch
			if !bytes.Equal(sn.entry.Key, entry.Key) {

				return instantiate୦୦z୦string(), false, true
			}

//line ctrie.go2:693
   ncn := cn.removed(pos, flag, i.gen)
			cntr := instantiate୦୦toContracted୦string(ncn, lev)
			if instantiate୦୦gcas୦string(i, main, cntr, c) {
				if parent != nil {
					main = instantiate୦୦gcasRead୦string(i, c)
					if main.tNode != nil {
//line ctrie.go2:698
      instantiate୦୦cleanParent୦string(parent, i, entry.hash, lev-w, c, startGen)
//line ctrie.go2:700
     }
				}
				return sn.entry.Value, true, true
			}
			return instantiate୦୦z୦string(), false, false
		default:
			panic("Ctrie is in an invalid state")
		}
	case main.tNode != nil:
//line ctrie.go2:708
  instantiate୦୦clean୦string(parent, lev-w, c)
//line ctrie.go2:710
  return instantiate୦୦z୦string(), false, false
	case main.lNode != nil:
		nln := &instantiate୦୦mainNode୦string{lNode: main.lNode.removed(entry)}
		if nln.lNode != nil && nln.lNode.tail == nil {

			nln = instantiate୦୦entomb୦string(nln.lNode.head)
		}
		if instantiate୦୦gcas୦string(i, main, nln, c) {
			val, ok := main.lNode.lookup(entry)
			return val, ok, true
		}
		return instantiate୦୦z୦string(), false, true
	default:
		panic("Ctrie is in an invalid state")
	}
}

//line ctrie.go2:900
func (c *instantiate୦୦Ctrie୦string,) readRoot() *instantiate୦୦iNode୦string {
	return c.rdcssReadRoot(false)
}

//line ctrie.go2:906
func (c *instantiate୦୦Ctrie୦string,) rdcssReadRoot(abort bool) *instantiate୦୦iNode୦string {
	r := instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8string୮9(&c.root)
	if r.rdcss != nil {
		return c.rdcssComplete(abort)
	}
	return r
}

//line ctrie.go2:917
func (c *instantiate୦୦Ctrie୦string,) rdcssRoot(old *instantiate୦୦iNode୦string, expected *instantiate୦୦mainNode୦string, nv *instantiate୦୦iNode୦string,) bool {
	desc := &instantiate୦୦iNode୦string{
		rdcss: &instantiate୦୦rdcssDescriptor୦string{
			old:      old,
			expected: expected,
			nv:       nv,
		},
	}
	if c.casRoot(old, desc) {
		c.rdcssComplete(false)
		return gatomic.LoadInt32(&desc.rdcss.committed) == 1
	}
	return false
}

//line ctrie.go2:933
func (c *instantiate୦୦Ctrie୦string,) rdcssComplete(abort bool) *instantiate୦୦iNode୦string {
	for {
		r := instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8string୮9(&c.root)
		if r.rdcss == nil {
			return r
		}

		var (
			desc = r.rdcss
			ov   = desc.old
			exp  = desc.expected
			nv   = desc.nv
		)

		if abort {
			if c.casRoot(r, ov) {
				return ov
			}
			continue
		}

		oldeMain := instantiate୦୦gcasRead୦string(ov, c)
		if oldeMain == exp {

			if c.casRoot(r, nv) {
				gatomic.StoreInt32(&desc.committed, 1)
				return nv
			}
			continue
		}
		if c.casRoot(r, ov) {
			return ov
		}
		continue
	}
}

//line ctrie.go2:971
func (c *instantiate୦୦Ctrie୦string,) casRoot(ov, nv *instantiate୦୦iNode୦string,) bool {
	c.assertReadWrite()
	return instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮aiNode୮8string୮9(&c.root, ov, nv)
}

//line ctrie.go2:974
type instantiate୦୦iNode୦string struct {
//line ctrie.go2:67
 main *instantiate୦୦mainNode୦string
			gen  *generation

//line ctrie.go2:73
 rdcss *instantiate୦୦rdcssDescriptor୦string
}

//line ctrie.go2:77
func (i *instantiate୦୦iNode୦string,) copyToGen(gen *generation, ctrie *instantiate୦୦Ctrie୦string,) *instantiate୦୦iNode୦string {
			nin := &instantiate୦୦iNode୦string{gen: gen}
			main := instantiate୦୦gcasRead୦string(i, ctrie)
//line ctrie.go2:79
 instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8string୮9(&nin.main, main)
//line ctrie.go2:81
 return nin
}

//line ctrie.go2:82
type instantiate୦୦mainNode୦string struct {
//line ctrie.go2:87
 cNode *instantiate୦୦cNode୦string
			tNode  *instantiate୦୦tNode୦string
			lNode  *instantiate୦୦lNode୦string
			failed *instantiate୦୦mainNode୦string

//line ctrie.go2:96
 prev *instantiate୦୦mainNode୦string
}
//line ctrie.go2:97
type instantiate୦୦cNode୦string struct {
//line ctrie.go2:103
 bmp uint32
	array []branch
	gen   *generation
}

//line ctrie.go2:140
func (c *instantiate୦୦cNode୦string,) inserted(pos, flag uint32, br branch, gen *generation) *instantiate୦୦cNode୦string {
	length := uint32(len(c.array))
	bmp := c.bmp
	array := make([]branch, length+1)
	copy(array, c.array)
	array[pos] = br
	for i, x := pos, uint32(0); x < length-pos; i++ {
		array[i+1] = c.array[i]
		x++
	}
	ncn := &instantiate୦୦cNode୦string{bmp: bmp | flag, array: array, gen: gen}
	return ncn
}

//line ctrie.go2:156
func (c *instantiate୦୦cNode୦string,) updated(pos uint32, br branch, gen *generation) *instantiate୦୦cNode୦string {
	array := make([]branch, len(c.array))
	copy(array, c.array)
	array[pos] = br
	ncn := &instantiate୦୦cNode୦string{bmp: c.bmp, array: array, gen: gen}
	return ncn
}

//line ctrie.go2:166
func (c *instantiate୦୦cNode୦string,) removed(pos, flag uint32, gen *generation) *instantiate୦୦cNode୦string {
	length := uint32(len(c.array))
	bmp := c.bmp
	array := make([]branch, length-1)
	for i := uint32(0); i < pos; i++ {
		array[i] = c.array[i]
	}
	for i, x := pos, uint32(0); x < length-pos-1; i++ {
		array[i] = c.array[i+1]
		x++
	}
	ncn := &instantiate୦୦cNode୦string{bmp: bmp ^ flag, array: array, gen: gen}
	return ncn
}

//line ctrie.go2:183
func (c *instantiate୦୦cNode୦string,) renewed(gen *generation, ctrie *instantiate୦୦Ctrie୦string,) *instantiate୦୦cNode୦string {
	array := make([]branch, len(c.array))
	for i, br := range c.array {
		switch t := br.(type) {
		case *instantiate୦୦iNode୦string:
			array[i] = t.copyToGen(gen, ctrie)
		default:
			array[i] = br
		}
	}
	return &instantiate୦୦cNode୦string{bmp: c.bmp, array: array, gen: gen}
}

//line ctrie.go2:278
func instantiate୦୦newCtrie୦string(root *instantiate୦୦iNode୦string, hashFactory HashFactory, readOnly bool) *instantiate୦୦Ctrie୦string {
	return &instantiate୦୦Ctrie୦string{
		root:        root,
		hashFactory: hashFactory,
		readOnly:    readOnly,
	}
}

//line ctrie.go2:284
type instantiate୦୦Ctrie୦int struct {
//line ctrie.go2:52
 root        *instantiate୦୦iNode୦int
			readOnly    bool
			hashFactory HashFactory
}

//line ctrie.go2:288
func (c *instantiate୦୦Ctrie୦int,) Insert(key []byte, value int,

//line ctrie.go2:288
) {
	c.assertReadWrite()
	c.insert(&instantiate୦୦Entry୦int{
		Key:   key,
		Value: value,
		hash:  c.hash(key),
	})
}

//line ctrie.go2:299
func (c *instantiate୦୦Ctrie୦int,) Lookup(key []byte) (int,

//line ctrie.go2:299
 bool) {
	return c.lookup(&instantiate୦୦Entry୦int{Key: key, hash: c.hash(key)})
}

//line ctrie.go2:305
func (c *instantiate୦୦Ctrie୦int,) Remove(key []byte) (int,

//line ctrie.go2:305
 bool) {
	c.assertReadWrite()
	return c.remove(&instantiate୦୦Entry୦int{Key: key, hash: c.hash(key)})
}

//line ctrie.go2:312
func (c *instantiate୦୦Ctrie୦int,) Snapshot() *instantiate୦୦Ctrie୦int {
	return c.snapshot(c.readOnly)
}

//line ctrie.go2:318
func (c *instantiate୦୦Ctrie୦int,) ReadOnlySnapshot() *instantiate୦୦Ctrie୦int {
	return c.snapshot(true)
}

//line ctrie.go2:323
func (c *instantiate୦୦Ctrie୦int,) snapshot(readOnly bool) *instantiate୦୦Ctrie୦int {
	if readOnly && c.readOnly {
		return c
	}
	for {
		root := c.readRoot()
		main := instantiate୦୦gcasRead୦int(root, c)
		if c.rdcssRoot(root, main, root.copyToGen(&generation{}, c)) {
			if readOnly {

//line ctrie.go2:334
    return instantiate୦୦newCtrie୦int(root, c.hashFactory, readOnly)
			}

//line ctrie.go2:338
   return instantiate୦୦newCtrie୦int(c.readRoot().copyToGen(&generation{}, c), c.hashFactory, readOnly)
		}
	}
}

//line ctrie.go2:344
func (c *instantiate୦୦Ctrie୦int,) Clear() {
	for {
		root := c.readRoot()
		gen := &generation{}
		newRoot := &instantiate୦୦iNode୦int{
			main: &instantiate୦୦mainNode୦int{cNode: &instantiate୦୦cNode୦int{array: make([]branch, 0), gen: gen}},
			gen:  gen,
		}
		if c.rdcssRoot(root, instantiate୦୦gcasRead୦int(root, c), newRoot) {
			return
		}
	}
}

//line ctrie.go2:359
func (c *instantiate୦୦Ctrie୦int,) Len() int {

//line ctrie.go2:365
 size := 0
	for iter := c.Iterator(); iter.Next(); {
		size++
	}
	return size
}

//line ctrie.go2:375
func (c *instantiate୦୦Ctrie୦int,) Iterator() *instantiate୦୦Iter୦int {
	iter := &instantiate୦୦Iter୦int{
		c: c,
	}
	iter.push((*instantiate୦୦Iter୦int).mainIter).iNode = c.ReadOnlySnapshot().readRoot()
	return iter
}

//line ctrie.go2:485
func (c *instantiate୦୦Ctrie୦int,) assertReadWrite() {
	if c.readOnly {
		panic("Cannot modify read-only snapshot")
	}
}

func (c *instantiate୦୦Ctrie୦int,) insert(entry *instantiate୦୦Entry୦int,) {
	root := c.readRoot()
	if !c.iinsert(root, entry, 0, nil, root.gen) {
		c.insert(entry)
	}
}

func (c *instantiate୦୦Ctrie୦int,) lookup(entry *instantiate୦୦Entry୦int,) (int,

//line ctrie.go2:498
 bool) {
	root := c.readRoot()
	result, exists, ok := c.ilookup(root, entry, 0, nil, root.gen)
	for !ok {
		return c.lookup(entry)
	}
	return result, exists
}

func (c *instantiate୦୦Ctrie୦int,) remove(entry *instantiate୦୦Entry୦int,) (int,

//line ctrie.go2:507
 bool) {
	root := c.readRoot()
	result, exists, ok := c.iremove(root, entry, 0, nil, root.gen)
	for !ok {
		return c.remove(entry)
	}
	return result, exists
}

func (c *instantiate୦୦Ctrie୦int,) hash(k []byte) uint32 {
	hasher := c.hashFactory()
	hasher.Write(k)
	return hasher.Sum32()
}

//line ctrie.go2:524
func (c *instantiate୦୦Ctrie୦int,) iinsert(i *instantiate୦୦iNode୦int, entry *instantiate୦୦Entry୦int, lev uint, parent *instantiate୦୦iNode୦int, startGen *generation) bool {

	main := instantiate୦୦gcasRead୦int(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:535
   rn := cn
			if cn.gen != i.gen {
				rn = cn.renewed(i.gen, c)
			}
			ncn := &instantiate୦୦mainNode୦int{cNode: rn.inserted(pos, flag, &instantiate୦୦sNode୦int{entry}, i.gen)}
			return instantiate୦୦gcas୦int(i, main, ncn, c)
		}

//line ctrie.go2:544
  branch := cn.array[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦int:

			if startGen == branch.gen {
				return c.iinsert(branch, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦int(i, main, &instantiate୦୦mainNode୦int{cNode: cn.renewed(startGen, c)}, c) {
				return c.iinsert(i, entry, lev, parent, startGen)
			}
			return false
		case *instantiate୦୦sNode୦int:
			sn := branch
			if !bytes.Equal(sn.entry.Key, entry.Key) {

//line ctrie.go2:565
    rn := cn
				if cn.gen != i.gen {
					rn = cn.renewed(i.gen, c)
				}
				nsn := &instantiate୦୦sNode୦int{entry}
				nin := &instantiate୦୦iNode୦int{main: instantiate୦୦newMainNode୦int(sn, sn.entry.hash, nsn, nsn.entry.hash, lev+w, i.gen), gen: i.gen}
				ncn := &instantiate୦୦mainNode୦int{cNode: rn.updated(pos, nin, i.gen)}
				return instantiate୦୦gcas୦int(i, main, ncn, c)
			}

//line ctrie.go2:577
   ncn := &instantiate୦୦mainNode୦int{cNode: cn.updated(pos, &instantiate୦୦sNode୦int{entry}, i.gen)}
			return instantiate୦୦gcas୦int(i, main, ncn, c)
		default:
			panic("Ctrie is in an invalid state")
		}
	case main.tNode != nil:
//line ctrie.go2:582
  instantiate୦୦clean୦int(parent, lev-w, c)
//line ctrie.go2:584
  return false
	case main.lNode != nil:
		nln := &instantiate୦୦mainNode୦int{lNode: main.lNode.inserted(entry)}
		return instantiate୦୦gcas୦int(i, main, nln, c)
	default:
		panic("Ctrie is in an invalid state")
	}
}

//line ctrie.go2:597
func (c *instantiate୦୦Ctrie୦int,) ilookup(i *instantiate୦୦iNode୦int, entry *instantiate୦୦Entry୦int, lev uint, parent *instantiate୦୦iNode୦int, startGen *generation) (int,

//line ctrie.go2:597
 bool, bool) {

	main := instantiate୦୦gcasRead୦int(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:607
   return instantiate୦୦z୦int(), false, true
		}

		branch := cn.array[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦int:

//line ctrie.go2:615
   in := branch
			if c.readOnly || startGen == in.gen {
				return c.ilookup(in, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦int(i, main, &instantiate୦୦mainNode୦int{cNode: cn.renewed(startGen, c)}, c) {
				return c.ilookup(i, entry, lev, parent, startGen)
			}
			return instantiate୦୦z୦int(), false, false
		case *instantiate୦୦sNode୦int:

//line ctrie.go2:629
   sn := branch
			if bytes.Equal(sn.entry.Key, entry.Key) {
				return sn.entry.Value, true, true
			}
			return instantiate୦୦z୦int(), false, true
		default:
			panic("Ctrie is in an invalid state")
		}
	case main.tNode != nil:
		return instantiate୦୦cleanReadOnly୦int(main.tNode, lev, parent, c, entry)
	case main.lNode != nil:

//line ctrie.go2:642
  val, ok := main.lNode.lookup(entry)
		return val, ok, true
	default:
		panic("Ctrie is in an invalid state")
	}
}

//line ctrie.go2:653
func (c *instantiate୦୦Ctrie୦int,) iremove(i *instantiate୦୦iNode୦int, entry *instantiate୦୦Entry୦int, lev uint, parent *instantiate୦୦iNode୦int, startGen *generation) (int,

//line ctrie.go2:653
 bool, bool) {

	main := instantiate୦୦gcasRead୦int(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:663
   return instantiate୦୦z୦int(), false, true
		}

		branch := cn.array[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦int:

//line ctrie.go2:671
   in := branch
			if startGen == in.gen {
				return c.iremove(in, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦int(i, main, &instantiate୦୦mainNode୦int{cNode: cn.renewed(startGen, c)}, c) {
				return c.iremove(i, entry, lev, parent, startGen)
			}
			return instantiate୦୦z୦int(), false, false
		case *instantiate୦୦sNode୦int:

//line ctrie.go2:682
   sn := branch
			if !bytes.Equal(sn.entry.Key, entry.Key) {

				return instantiate୦୦z୦int(), false, true
			}

//line ctrie.go2:693
   ncn := cn.removed(pos, flag, i.gen)
			cntr := instantiate୦୦toContracted୦int(ncn, lev)
			if instantiate୦୦gcas୦int(i, main, cntr, c) {
				if parent != nil {
					main = instantiate୦୦gcasRead୦int(i, c)
					if main.tNode != nil {
//line ctrie.go2:698
      instantiate୦୦cleanParent୦int(parent, i, entry.hash, lev-w, c, startGen)
//line ctrie.go2:700
     }
				}
				return sn.entry.Value, true, true
			}
			return instantiate୦୦z୦int(), false, false
		default:
			panic("Ctrie is in an invalid state")
		}
	case main.tNode != nil:
//line ctrie.go2:708
  instantiate୦୦clean୦int(parent, lev-w, c)
//line ctrie.go2:710
  return instantiate୦୦z୦int(), false, false
	case main.lNode != nil:
		nln := &instantiate୦୦mainNode୦int{lNode: main.lNode.removed(entry)}
		if nln.lNode != nil && nln.lNode.tail == nil {

			nln = instantiate୦୦entomb୦int(nln.lNode.head)
		}
		if instantiate୦୦gcas୦int(i, main, nln, c) {
			val, ok := main.lNode.lookup(entry)
			return val, ok, true
		}
		return instantiate୦୦z୦int(), false, true
	default:
		panic("Ctrie is in an invalid state")
	}
}

//line ctrie.go2:900
func (c *instantiate୦୦Ctrie୦int,) readRoot() *instantiate୦୦iNode୦int {
	return c.rdcssReadRoot(false)
}

//line ctrie.go2:906
func (c *instantiate୦୦Ctrie୦int,) rdcssReadRoot(abort bool) *instantiate୦୦iNode୦int {
	r := instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8int୮9(&c.root)
	if r.rdcss != nil {
		return c.rdcssComplete(abort)
	}
	return r
}

//line ctrie.go2:917
func (c *instantiate୦୦Ctrie୦int,) rdcssRoot(old *instantiate୦୦iNode୦int, expected *instantiate୦୦mainNode୦int, nv *instantiate୦୦iNode୦int,) bool {
	desc := &instantiate୦୦iNode୦int{
		rdcss: &instantiate୦୦rdcssDescriptor୦int{
			old:      old,
			expected: expected,
			nv:       nv,
		},
	}
	if c.casRoot(old, desc) {
		c.rdcssComplete(false)
		return gatomic.LoadInt32(&desc.rdcss.committed) == 1
	}
	return false
}

//line ctrie.go2:933
func (c *instantiate୦୦Ctrie୦int,) rdcssComplete(abort bool) *instantiate୦୦iNode୦int {
	for {
		r := instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8int୮9(&c.root)
		if r.rdcss == nil {
			return r
		}

		var (
			desc = r.rdcss
			ov   = desc.old
			exp  = desc.expected
			nv   = desc.nv
		)

		if abort {
			if c.casRoot(r, ov) {
				return ov
			}
			continue
		}

		oldeMain := instantiate୦୦gcasRead୦int(ov, c)
		if oldeMain == exp {

			if c.casRoot(r, nv) {
				gatomic.StoreInt32(&desc.committed, 1)
				return nv
			}
			continue
		}
		if c.casRoot(r, ov) {
			return ov
		}
		continue
	}
}

//line ctrie.go2:971
func (c *instantiate୦୦Ctrie୦int,) casRoot(ov, nv *instantiate୦୦iNode୦int,) bool {
	c.assertReadWrite()
	return instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮aiNode୮8int୮9(&c.root, ov, nv)
}

//line ctrie.go2:974
type instantiate୦୦iNode୦int struct {
//line ctrie.go2:67
 main *instantiate୦୦mainNode୦int
			gen  *generation

//line ctrie.go2:73
 rdcss *instantiate୦୦rdcssDescriptor୦int
}

//line ctrie.go2:77
func (i *instantiate୦୦iNode୦int,) copyToGen(gen *generation, ctrie *instantiate୦୦Ctrie୦int,) *instantiate୦୦iNode୦int {
			nin := &instantiate୦୦iNode୦int{gen: gen}
			main := instantiate୦୦gcasRead୦int(i, ctrie)
//line ctrie.go2:79
 instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8int୮9(&nin.main, main)
//line ctrie.go2:81
 return nin
}

//line ctrie.go2:82
type instantiate୦୦mainNode୦int struct {
//line ctrie.go2:87
 cNode *instantiate୦୦cNode୦int
			tNode  *instantiate୦୦tNode୦int
			lNode  *instantiate୦୦lNode୦int
			failed *instantiate୦୦mainNode୦int

//line ctrie.go2:96
 prev *instantiate୦୦mainNode୦int
}
//line ctrie.go2:97
type instantiate୦୦cNode୦int struct {
//line ctrie.go2:103
 bmp uint32
	array []branch
	gen   *generation
}

//line ctrie.go2:140
func (c *instantiate୦୦cNode୦int,) inserted(pos, flag uint32, br branch, gen *generation) *instantiate୦୦cNode୦int {
	length := uint32(len(c.array))
	bmp := c.bmp
	array := make([]branch, length+1)
	copy(array, c.array)
	array[pos] = br
	for i, x := pos, uint32(0); x < length-pos; i++ {
		array[i+1] = c.array[i]
		x++
	}
	ncn := &instantiate୦୦cNode୦int{bmp: bmp | flag, array: array, gen: gen}
	return ncn
}

//line ctrie.go2:156
func (c *instantiate୦୦cNode୦int,) updated(pos uint32, br branch, gen *generation) *instantiate୦୦cNode୦int {
	array := make([]branch, len(c.array))
	copy(array, c.array)
	array[pos] = br
	ncn := &instantiate୦୦cNode୦int{bmp: c.bmp, array: array, gen: gen}
	return ncn
}

//line ctrie.go2:166
func (c *instantiate୦୦cNode୦int,) removed(pos, flag uint32, gen *generation) *instantiate୦୦cNode୦int {
	length := uint32(len(c.array))
	bmp := c.bmp
	array := make([]branch, length-1)
	for i := uint32(0); i < pos; i++ {
		array[i] = c.array[i]
	}
	for i, x := pos, uint32(0); x < length-pos-1; i++ {
		array[i] = c.array[i+1]
		x++
	}
	ncn := &instantiate୦୦cNode୦int{bmp: bmp ^ flag, array: array, gen: gen}
	return ncn
}

//line ctrie.go2:183
func (c *instantiate୦୦cNode୦int,) renewed(gen *generation, ctrie *instantiate୦୦Ctrie୦int,) *instantiate୦୦cNode୦int {
	array := make([]branch, len(c.array))
	for i, br := range c.array {
		switch t := br.(type) {
		case *instantiate୦୦iNode୦int:
			array[i] = t.copyToGen(gen, ctrie)
		default:
			array[i] = br
		}
	}
	return &instantiate୦୦cNode୦int{bmp: c.bmp, array: array, gen: gen}
}

//line ctrie.go2:278
func instantiate୦୦newCtrie୦int(root *instantiate୦୦iNode୦int, hashFactory HashFactory, readOnly bool) *instantiate୦୦Ctrie୦int {
	return &instantiate୦୦Ctrie୦int{
		root:        root,
		hashFactory: hashFactory,
		readOnly:    readOnly,
	}
}

//line ctrie.go2:284
type instantiate୦୦Ctrie୦interface୮4୮5 struct {
//line ctrie.go2:52
 root        *instantiate୦୦iNode୦interface୮4୮5
			readOnly    bool
			hashFactory HashFactory
}

//line ctrie.go2:288
func (c *instantiate୦୦Ctrie୦interface୮4୮5,) Insert(key []byte, value interface{},

//line ctrie.go2:288
) {
	c.assertReadWrite()
	c.insert(&instantiate୦୦Entry୦interface୮4୮5{
		Key:   key,
		Value: value,
		hash:  c.hash(key),
	})
}

//line ctrie.go2:299
func (c *instantiate୦୦Ctrie୦interface୮4୮5,) Lookup(key []byte) (interface{},

//line ctrie.go2:299
 bool) {
	return c.lookup(&instantiate୦୦Entry୦interface୮4୮5{Key: key, hash: c.hash(key)})
}

//line ctrie.go2:305
func (c *instantiate୦୦Ctrie୦interface୮4୮5,) Remove(key []byte) (interface{},

//line ctrie.go2:305
 bool) {
	c.assertReadWrite()
	return c.remove(&instantiate୦୦Entry୦interface୮4୮5{Key: key, hash: c.hash(key)})
}

//line ctrie.go2:312
func (c *instantiate୦୦Ctrie୦interface୮4୮5,) Snapshot() *instantiate୦୦Ctrie୦interface୮4୮5 {
	return c.snapshot(c.readOnly)
}

//line ctrie.go2:318
func (c *instantiate୦୦Ctrie୦interface୮4୮5,) ReadOnlySnapshot() *instantiate୦୦Ctrie୦interface୮4୮5 {
	return c.snapshot(true)
}

//line ctrie.go2:323
func (c *instantiate୦୦Ctrie୦interface୮4୮5,) snapshot(readOnly bool) *instantiate୦୦Ctrie୦interface୮4୮5 {
	if readOnly && c.readOnly {
		return c
	}
	for {
		root := c.readRoot()
		main := instantiate୦୦gcasRead୦interface୮4୮5(root, c)
		if c.rdcssRoot(root, main, root.copyToGen(&generation{}, c)) {
			if readOnly {

//line ctrie.go2:334
    return instantiate୦୦newCtrie୦interface୮4୮5(root, c.hashFactory, readOnly)
			}

//line ctrie.go2:338
   return instantiate୦୦newCtrie୦interface୮4୮5(c.readRoot().copyToGen(&generation{}, c), c.hashFactory, readOnly)
		}
	}
}

//line ctrie.go2:344
func (c *instantiate୦୦Ctrie୦interface୮4୮5,) Clear() {
	for {
		root := c.readRoot()
		gen := &generation{}
		newRoot := &instantiate୦୦iNode୦interface୮4୮5{
			main: &instantiate୦୦mainNode୦interface୮4୮5{cNode: &instantiate୦୦cNode୦interface୮4୮5{array: make([]branch, 0), gen: gen}},
			gen:  gen,
		}
		if c.rdcssRoot(root, instantiate୦୦gcasRead୦interface୮4୮5(root, c), newRoot) {
			return
		}
	}
}

//line ctrie.go2:359
func (c *instantiate୦୦Ctrie୦interface୮4୮5,) Len() int {

//line ctrie.go2:365
 size := 0
	for iter := c.Iterator(); iter.Next(); {
		size++
	}
	return size
}

//line ctrie.go2:375
func (c *instantiate୦୦Ctrie୦interface୮4୮5,) Iterator() *instantiate୦୦Iter୦interface୮4୮5 {
	iter := &instantiate୦୦Iter୦interface୮4୮5{
		c: c,
	}
	iter.push((*instantiate୦୦Iter୦interface୮4୮5).mainIter).iNode = c.ReadOnlySnapshot().readRoot()
	return iter
}

//line ctrie.go2:485
func (c *instantiate୦୦Ctrie୦interface୮4୮5,) assertReadWrite() {
	if c.readOnly {
		panic("Cannot modify read-only snapshot")
	}
}

func (c *instantiate୦୦Ctrie୦interface୮4୮5,) insert(entry *instantiate୦୦Entry୦interface୮4୮5,) {
	root := c.readRoot()
	if !c.iinsert(root, entry, 0, nil, root.gen) {
		c.insert(entry)
	}
}

func (c *instantiate୦୦Ctrie୦interface୮4୮5,) lookup(entry *instantiate୦୦Entry୦interface୮4୮5,) (interface{},

//line ctrie.go2:498
 bool) {
	root := c.readRoot()
	result, exists, ok := c.ilookup(root, entry, 0, nil, root.gen)
	for !ok {
		return c.lookup(entry)
	}
	return result, exists
}

func (c *instantiate୦୦Ctrie୦interface୮4୮5,) remove(entry *instantiate୦୦Entry୦interface୮4୮5,) (interface{},

//line ctrie.go2:507
 bool) {
	root := c.readRoot()
	result, exists, ok := c.iremove(root, entry, 0, nil, root.gen)
	for !ok {
		return c.remove(entry)
	}
	return result, exists
}

func (c *instantiate୦୦Ctrie୦interface୮4୮5,) hash(k []byte) uint32 {
	hasher := c.hashFactory()
	hasher.Write(k)
	return hasher.Sum32()
}

//line ctrie.go2:524
func (c *instantiate୦୦Ctrie୦interface୮4୮5,) iinsert(i *instantiate୦୦iNode୦interface୮4୮5, entry *instantiate୦୦Entry୦interface୮4୮5, lev uint, parent *instantiate୦୦iNode୦interface୮4୮5, startGen *generation) bool {

	main := instantiate୦୦gcasRead୦interface୮4୮5(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:535
   rn := cn
			if cn.gen != i.gen {
				rn = cn.renewed(i.gen, c)
			}
			ncn := &instantiate୦୦mainNode୦interface୮4୮5{cNode: rn.inserted(pos, flag, &instantiate୦୦sNode୦interface୮4୮5{entry}, i.gen)}
			return instantiate୦୦gcas୦interface୮4୮5(i, main, ncn, c)
		}

//line ctrie.go2:544
  branch := cn.array[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦interface୮4୮5:

			if startGen == branch.gen {
				return c.iinsert(branch, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦interface୮4୮5(i, main, &instantiate୦୦mainNode୦interface୮4୮5{cNode: cn.renewed(startGen, c)}, c) {
				return c.iinsert(i, entry, lev, parent, startGen)
			}
			return false
		case *instantiate୦୦sNode୦interface୮4୮5:
			sn := branch
			if !bytes.Equal(sn.entry.Key, entry.Key) {

//line ctrie.go2:565
    rn := cn
				if cn.gen != i.gen {
					rn = cn.renewed(i.gen, c)
				}
				nsn := &instantiate୦୦sNode୦interface୮4୮5{entry}
				nin := &instantiate୦୦iNode୦interface୮4୮5{main: instantiate୦୦newMainNode୦interface୮4୮5(sn, sn.entry.hash, nsn, nsn.entry.hash, lev+w, i.gen), gen: i.gen}
				ncn := &instantiate୦୦mainNode୦interface୮4୮5{cNode: rn.updated(pos, nin, i.gen)}
				return instantiate୦୦gcas୦interface୮4୮5(i, main, ncn, c)
			}

//line ctrie.go2:577
   ncn := &instantiate୦୦mainNode୦interface୮4୮5{cNode: cn.updated(pos, &instantiate୦୦sNode୦interface୮4୮5{entry}, i.gen)}
			return instantiate୦୦gcas୦interface୮4୮5(i, main, ncn, c)
		default:
			panic("Ctrie is in an invalid state")
		}
	case main.tNode != nil:
//line ctrie.go2:582
  instantiate୦୦clean୦interface୮4୮5(parent, lev-w, c)
//line ctrie.go2:584
  return false
	case main.lNode != nil:
		nln := &instantiate୦୦mainNode୦interface୮4୮5{lNode: main.lNode.inserted(entry)}
		return instantiate୦୦gcas୦interface୮4୮5(i, main, nln, c)
	default:
		panic("Ctrie is in an invalid state")
	}
}

//line ctrie.go2:597
func (c *instantiate୦୦Ctrie୦interface୮4୮5,) ilookup(i *instantiate୦୦iNode୦interface୮4୮5, entry *instantiate୦୦Entry୦interface୮4୮5, lev uint, parent *instantiate୦୦iNode୦interface୮4୮5, startGen *generation) (interface{},

//line ctrie.go2:597
 bool, bool) {

	main := instantiate୦୦gcasRead୦interface୮4୮5(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:607
   return instantiate୦୦z୦interface୮4୮5(), false, true
		}

		branch := cn.array[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦interface୮4୮5:

//line ctrie.go2:615
   in := branch
			if c.readOnly || startGen == in.gen {
				return c.ilookup(in, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦interface୮4୮5(i, main, &instantiate୦୦mainNode୦interface୮4୮5{cNode: cn.renewed(startGen, c)}, c) {
				return c.ilookup(i, entry, lev, parent, startGen)
			}
			return instantiate୦୦z୦interface୮4୮5(), false, false
		case *instantiate୦୦sNode୦interface୮4୮5:

//line ctrie.go2:629
   sn := branch
			if bytes.Equal(sn.entry.Key, entry.Key) {
				return sn.entry.Value, true, true
			}
			return instantiate୦୦z୦interface୮4୮5(), false, true
		default:
			panic("Ctrie is in an invalid state")
		}
	case main.tNode != nil:
		return instantiate୦୦cleanReadOnly୦interface୮4୮5(main.tNode, lev, parent, c, entry)
	case main.lNode != nil:

//line ctrie.go2:642
  val, ok := main.lNode.lookup(entry)
		return val, ok, true
	default:
		panic("Ctrie is in an invalid state")
	}
}

//line ctrie.go2:653
func (c *instantiate୦୦Ctrie୦interface୮4୮5,) iremove(i *instantiate୦୦iNode୦interface୮4୮5, entry *instantiate୦୦Entry୦interface୮4୮5, lev uint, parent *instantiate୦୦iNode୦interface୮4୮5, startGen *generation) (interface{},

//line ctrie.go2:653
 bool, bool) {

	main := instantiate୦୦gcasRead୦interface୮4୮5(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:663
   return instantiate୦୦z୦interface୮4୮5(), false, true
		}

		branch := cn.array[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦interface୮4୮5:

//line ctrie.go2:671
   in := branch
			if startGen == in.gen {
				return c.iremove(in, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦interface୮4୮5(i, main, &instantiate୦୦mainNode୦interface୮4୮5{cNode: cn.renewed(startGen, c)}, c) {
				return c.iremove(i, entry, lev, parent, startGen)
			}
			return instantiate୦୦z୦interface୮4୮5(), false, false
		case *instantiate୦୦sNode୦interface୮4୮5:

//line ctrie.go2:682
   sn := branch
			if !bytes.Equal(sn.entry.Key, entry.Key) {

				return instantiate୦୦z୦interface୮4୮5(), false, true
			}

//line ctrie.go2:693
   ncn := cn.removed(pos, flag, i.gen)
			cntr := instantiate୦୦toContracted୦interface୮4୮5(ncn, lev)
			if instantiate୦୦gcas୦interface୮4୮5(i, main, cntr, c) {
				if parent != nil {
					main = instantiate୦୦gcasRead୦interface୮4୮5(i, c)
					if main.tNode != nil {
//line ctrie.go2:698
      instantiate୦୦cleanParent୦interface୮4୮5(parent, i, entry.hash, lev-w, c, startGen)
//line ctrie.go2:700
     }
				}
				return sn.entry.Value, true, true
			}
			return instantiate୦୦z୦interface୮4୮5(), false, false
		default:
			panic("Ctrie is in an invalid state")
		}
	case main.tNode != nil:
//line ctrie.go2:708
  instantiate୦୦clean୦interface୮4୮5(parent, lev-w, c)
//line ctrie.go2:710
  return instantiate୦୦z୦interface୮4୮5(), false, false
	case main.lNode != nil:
		nln := &instantiate୦୦mainNode୦interface୮4୮5{lNode: main.lNode.removed(entry)}
		if nln.lNode != nil && nln.lNode.tail == nil {

			nln = instantiate୦୦entomb୦interface୮4୮5(nln.lNode.head)
		}
		if instantiate୦୦gcas୦interface୮4୮5(i, main, nln, c) {
			val, ok := main.lNode.lookup(entry)
			return val, ok, true
		}
		return instantiate୦୦z୦interface୮4୮5(), false, true
	default:
		panic("Ctrie is in an invalid state")
	}
}

//line ctrie.go2:900
func (c *instantiate୦୦Ctrie୦interface୮4୮5,) readRoot() *instantiate୦୦iNode୦interface୮4୮5 {
	return c.rdcssReadRoot(false)
}

//line ctrie.go2:906
func (c *instantiate୦୦Ctrie୦interface୮4୮5,) rdcssReadRoot(abort bool) *instantiate୦୦iNode୦interface୮4୮5 {
	r := instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8interface୮4୮5୮9(&c.root)
	if r.rdcss != nil {
		return c.rdcssComplete(abort)
	}
	return r
}

//line ctrie.go2:917
func (c *instantiate୦୦Ctrie୦interface୮4୮5,) rdcssRoot(old *instantiate୦୦iNode୦interface୮4୮5, expected *instantiate୦୦mainNode୦interface୮4୮5, nv *instantiate୦୦iNode୦interface୮4୮5,) bool {
	desc := &instantiate୦୦iNode୦interface୮4୮5{
		rdcss: &instantiate୦୦rdcssDescriptor୦interface୮4୮5{
			old:      old,
			expected: expected,
			nv:       nv,
		},
	}
	if c.casRoot(old, desc) {
		c.rdcssComplete(false)
		return gatomic.LoadInt32(&desc.rdcss.committed) == 1
	}
	return false
}

//line ctrie.go2:933
func (c *instantiate୦୦Ctrie୦interface୮4୮5,) rdcssComplete(abort bool) *instantiate୦୦iNode୦interface୮4୮5 {
	for {
		r := instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8interface୮4୮5୮9(&c.root)
		if r.rdcss == nil {
			return r
		}

		var (
			desc = r.rdcss
			ov   = desc.old
			exp  = desc.expected
			nv   = desc.nv
		)

		if abort {
			if c.casRoot(r, ov) {
				return ov
			}
			continue
		}

		oldeMain := instantiate୦୦gcasRead୦interface୮4୮5(ov, c)
		if oldeMain == exp {

			if c.casRoot(r, nv) {
				gatomic.StoreInt32(&desc.committed, 1)
				return nv
			}
			continue
		}
		if c.casRoot(r, ov) {
			return ov
		}
		continue
	}
}

//line ctrie.go2:971
func (c *instantiate୦୦Ctrie୦interface୮4୮5,) casRoot(ov, nv *instantiate୦୦iNode୦interface୮4୮5,) bool {
	c.assertReadWrite()
	return instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮aiNode୮8interface୮4୮5୮9(&c.root, ov, nv)
}

//line ctrie.go2:974
type instantiate୦୦iNode୦interface୮4୮5 struct {
//line ctrie.go2:67
 main *instantiate୦୦mainNode୦interface୮4୮5
			gen  *generation

//line ctrie.go2:73
 rdcss *instantiate୦୦rdcssDescriptor୦interface୮4୮5
}

//line ctrie.go2:77
func (i *instantiate୦୦iNode୦interface୮4୮5,) copyToGen(gen *generation, ctrie *instantiate୦୦Ctrie୦interface୮4୮5,) *instantiate୦୦iNode୦interface୮4୮5 {
			nin := &instantiate୦୦iNode୦interface୮4୮5{gen: gen}
			main := instantiate୦୦gcasRead୦interface୮4୮5(i, ctrie)
//line ctrie.go2:79
 instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8interface୮4୮5୮9(&nin.main, main)
//line ctrie.go2:81
 return nin
}

//line ctrie.go2:82
type instantiate୦୦mainNode୦interface୮4୮5 struct {
//line ctrie.go2:87
 cNode *instantiate୦୦cNode୦interface୮4୮5
			tNode  *instantiate୦୦tNode୦interface୮4୮5
			lNode  *instantiate୦୦lNode୦interface୮4୮5
			failed *instantiate୦୦mainNode୦interface୮4୮5

//line ctrie.go2:96
 prev *instantiate୦୦mainNode୦interface୮4୮5
}
//line ctrie.go2:97
type instantiate୦୦cNode୦interface୮4୮5 struct {
//line ctrie.go2:103
 bmp uint32
	array []branch
	gen   *generation
}

//line ctrie.go2:140
func (c *instantiate୦୦cNode୦interface୮4୮5,) inserted(pos, flag uint32, br branch, gen *generation) *instantiate୦୦cNode୦interface୮4୮5 {
	length := uint32(len(c.array))
	bmp := c.bmp
	array := make([]branch, length+1)
	copy(array, c.array)
	array[pos] = br
	for i, x := pos, uint32(0); x < length-pos; i++ {
		array[i+1] = c.array[i]
		x++
	}
	ncn := &instantiate୦୦cNode୦interface୮4୮5{bmp: bmp | flag, array: array, gen: gen}
	return ncn
}

//line ctrie.go2:156
func (c *instantiate୦୦cNode୦interface୮4୮5,) updated(pos uint32, br branch, gen *generation) *instantiate୦୦cNode୦interface୮4୮5 {
	array := make([]branch, len(c.array))
	copy(array, c.array)
	array[pos] = br
	ncn := &instantiate୦୦cNode୦interface୮4୮5{bmp: c.bmp, array: array, gen: gen}
	return ncn
}

//line ctrie.go2:166
func (c *instantiate୦୦cNode୦interface୮4୮5,) removed(pos, flag uint32, gen *generation) *instantiate୦୦cNode୦interface୮4୮5 {
	length := uint32(len(c.array))
	bmp := c.bmp
	array := make([]branch, length-1)
	for i := uint32(0); i < pos; i++ {
		array[i] = c.array[i]
	}
	for i, x := pos, uint32(0); x < length-pos-1; i++ {
		array[i] = c.array[i+1]
		x++
	}
	ncn := &instantiate୦୦cNode୦interface୮4୮5{bmp: bmp ^ flag, array: array, gen: gen}
	return ncn
}

//line ctrie.go2:183
func (c *instantiate୦୦cNode୦interface୮4୮5,) renewed(gen *generation, ctrie *instantiate୦୦Ctrie୦interface୮4୮5,) *instantiate୦୦cNode୦interface୮4୮5 {
	array := make([]branch, len(c.array))
	for i, br := range c.array {
		switch t := br.(type) {
		case *instantiate୦୦iNode୦interface୮4୮5:
			array[i] = t.copyToGen(gen, ctrie)
		default:
			array[i] = br
		}
	}
	return &instantiate୦୦cNode୦interface୮4୮5{bmp: c.bmp, array: array, gen: gen}
}

//line ctrie.go2:278
func instantiate୦୦newCtrie୦interface୮4୮5(root *instantiate୦୦iNode୦interface୮4୮5, hashFactory HashFactory, readOnly bool) *instantiate୦୦Ctrie୦interface୮4୮5 {
	return &instantiate୦୦Ctrie୦interface୮4୮5{
		root:        root,
		hashFactory: hashFactory,
		readOnly:    readOnly,
	}
}

//line ctrie.go2:284
type instantiate୦୦Ctrie୦bool struct {
//line ctrie.go2:52
 root        *instantiate୦୦iNode୦bool
			readOnly    bool
			hashFactory HashFactory
}

//line ctrie.go2:288
func (c *instantiate୦୦Ctrie୦bool,) Insert(key []byte, value bool) {
	c.assertReadWrite()
	c.insert(&instantiate୦୦Entry୦bool{
		Key:   key,
		Value: value,
		hash:  c.hash(key),
	})
}

//line ctrie.go2:299
func (c *instantiate୦୦Ctrie୦bool,) Lookup(key []byte) (

//line ctrie_test.go2:366
 bool, bool) {
//line ctrie.go2:300
 return c.lookup(&instantiate୦୦Entry୦bool{Key: key, hash: c.hash(key)})
}

//line ctrie.go2:305
func (c *instantiate୦୦Ctrie୦bool,) Remove(key []byte) (

//line ctrie_test.go2:366
 bool, bool) {
//line ctrie.go2:306
 c.assertReadWrite()
			return c.remove(&instantiate୦୦Entry୦bool{Key: key, hash: c.hash(key)})
}

//line ctrie.go2:312
func (c *instantiate୦୦Ctrie୦bool,) Snapshot() *instantiate୦୦Ctrie୦bool {
	return c.snapshot(c.readOnly)
}

//line ctrie.go2:318
func (c *instantiate୦୦Ctrie୦bool,) ReadOnlySnapshot() *instantiate୦୦Ctrie୦bool {
	return c.snapshot(true)
}

//line ctrie.go2:323
func (c *instantiate୦୦Ctrie୦bool,) snapshot(readOnly bool) *instantiate୦୦Ctrie୦bool {
	if readOnly && c.readOnly {
		return c
	}
	for {
		root := c.readRoot()
		main := instantiate୦୦gcasRead୦bool(root, c)
		if c.rdcssRoot(root, main, root.copyToGen(&generation{}, c)) {
			if readOnly {

//line ctrie.go2:334
    return instantiate୦୦newCtrie୦bool(root, c.hashFactory, readOnly)
			}

//line ctrie.go2:338
   return instantiate୦୦newCtrie୦bool(c.readRoot().copyToGen(&generation{}, c), c.hashFactory, readOnly)
		}
	}
}

//line ctrie.go2:344
func (c *instantiate୦୦Ctrie୦bool,) Clear() {
	for {
		root := c.readRoot()
		gen := &generation{}
		newRoot := &instantiate୦୦iNode୦bool{
			main: &instantiate୦୦mainNode୦bool{cNode: &instantiate୦୦cNode୦bool{array: make([]branch, 0), gen: gen}},
			gen:  gen,
		}
		if c.rdcssRoot(root, instantiate୦୦gcasRead୦bool(root, c), newRoot) {
			return
		}
	}
}

//line ctrie.go2:359
func (c *instantiate୦୦Ctrie୦bool,) Len() int {

//line ctrie.go2:365
 size := 0
	for iter := c.Iterator(); iter.Next(); {
		size++
	}
	return size
}

//line ctrie.go2:375
func (c *instantiate୦୦Ctrie୦bool,) Iterator() *instantiate୦୦Iter୦bool {
	iter := &instantiate୦୦Iter୦bool{
		c: c,
	}
	iter.push((*instantiate୦୦Iter୦bool).mainIter).iNode = c.ReadOnlySnapshot().readRoot()
	return iter
}

//line ctrie.go2:485
func (c *instantiate୦୦Ctrie୦bool,) assertReadWrite() {
	if c.readOnly {
		panic("Cannot modify read-only snapshot")
	}
}

func (c *instantiate୦୦Ctrie୦bool,) insert(entry *instantiate୦୦Entry୦bool,) {
	root := c.readRoot()
	if !c.iinsert(root, entry, 0, nil, root.gen) {
		c.insert(entry)
	}
}

func (c *instantiate୦୦Ctrie୦bool,) lookup(entry *instantiate୦୦Entry୦bool,) (bool,

//line ctrie.go2:498
 bool) {
	root := c.readRoot()
	result, exists, ok := c.ilookup(root, entry, 0, nil, root.gen)
	for !ok {
		return c.lookup(entry)
	}
	return result, exists
}

func (c *instantiate୦୦Ctrie୦bool,) remove(entry *instantiate୦୦Entry୦bool,) (bool,

//line ctrie.go2:507
 bool) {
	root := c.readRoot()
	result, exists, ok := c.iremove(root, entry, 0, nil, root.gen)
	for !ok {
		return c.remove(entry)
	}
	return result, exists
}

func (c *instantiate୦୦Ctrie୦bool,) hash(k []byte) uint32 {
	hasher := c.hashFactory()
	hasher.Write(k)
	return hasher.Sum32()
}

//line ctrie.go2:524
func (c *instantiate୦୦Ctrie୦bool,) iinsert(i *instantiate୦୦iNode୦bool, entry *instantiate୦୦Entry୦bool, lev uint, parent *instantiate୦୦iNode୦bool, startGen *generation) bool {

	main := instantiate୦୦gcasRead୦bool(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:535
   rn := cn
			if cn.gen != i.gen {
				rn = cn.renewed(i.gen, c)
			}
			ncn := &instantiate୦୦mainNode୦bool{cNode: rn.inserted(pos, flag, &instantiate୦୦sNode୦bool{entry}, i.gen)}
			return instantiate୦୦gcas୦bool(i, main, ncn, c)
		}

//line ctrie.go2:544
  branch := cn.array[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦bool:

			if startGen == branch.gen {
				return c.iinsert(branch, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦bool(i, main, &instantiate୦୦mainNode୦bool{cNode: cn.renewed(startGen, c)}, c) {
				return c.iinsert(i, entry, lev, parent, startGen)
			}
			return false
		case *instantiate୦୦sNode୦bool:
			sn := branch
			if !bytes.Equal(sn.entry.Key, entry.Key) {

//line ctrie.go2:565
    rn := cn
				if cn.gen != i.gen {
					rn = cn.renewed(i.gen, c)
				}
				nsn := &instantiate୦୦sNode୦bool{entry}
				nin := &instantiate୦୦iNode୦bool{main: instantiate୦୦newMainNode୦bool(sn, sn.entry.hash, nsn, nsn.entry.hash, lev+w, i.gen), gen: i.gen}
				ncn := &instantiate୦୦mainNode୦bool{cNode: rn.updated(pos, nin, i.gen)}
				return instantiate୦୦gcas୦bool(i, main, ncn, c)
			}

//line ctrie.go2:577
   ncn := &instantiate୦୦mainNode୦bool{cNode: cn.updated(pos, &instantiate୦୦sNode୦bool{entry}, i.gen)}
			return instantiate୦୦gcas୦bool(i, main, ncn, c)
		default:
			panic("Ctrie is in an invalid state")
		}
	case main.tNode != nil:
//line ctrie.go2:582
  instantiate୦୦clean୦bool(parent, lev-w, c)
//line ctrie.go2:584
  return false
	case main.lNode != nil:
		nln := &instantiate୦୦mainNode୦bool{lNode: main.lNode.inserted(entry)}
		return instantiate୦୦gcas୦bool(i, main, nln, c)
	default:
		panic("Ctrie is in an invalid state")
	}
}

//line ctrie.go2:597
func (c *instantiate୦୦Ctrie୦bool,) ilookup(i *instantiate୦୦iNode୦bool, entry *instantiate୦୦Entry୦bool, lev uint, parent *instantiate୦୦iNode୦bool, startGen *generation) (bool,

//line ctrie.go2:597
 bool, bool) {

	main := instantiate୦୦gcasRead୦bool(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:607
   return instantiate୦୦z୦bool(), false, true
		}

		branch := cn.array[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦bool:

//line ctrie.go2:615
   in := branch
			if c.readOnly || startGen == in.gen {
				return c.ilookup(in, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦bool(i, main, &instantiate୦୦mainNode୦bool{cNode: cn.renewed(startGen, c)}, c) {
				return c.ilookup(i, entry, lev, parent, startGen)
			}
			return instantiate୦୦z୦bool(), false, false
		case *instantiate୦୦sNode୦bool:

//line ctrie.go2:629
   sn := branch
			if bytes.Equal(sn.entry.Key, entry.Key) {
				return sn.entry.Value, true, true
			}
			return instantiate୦୦z୦bool(), false, true
		default:
			panic("Ctrie is in an invalid state")
		}
	case main.tNode != nil:
		return instantiate୦୦cleanReadOnly୦bool(main.tNode, lev, parent, c, entry)
	case main.lNode != nil:

//line ctrie.go2:642
  val, ok := main.lNode.lookup(entry)
		return val, ok, true
	default:
		panic("Ctrie is in an invalid state")
	}
}

//line ctrie.go2:653
func (c *instantiate୦୦Ctrie୦bool,) iremove(i *instantiate୦୦iNode୦bool, entry *instantiate୦୦Entry୦bool, lev uint, parent *instantiate୦୦iNode୦bool, startGen *generation) (bool,

//line ctrie.go2:653
 bool, bool) {

	main := instantiate୦୦gcasRead୦bool(i, c)
	switch {
	case main.cNode != nil:
		cn := main.cNode
		flag, pos := flagPos(entry.hash, lev, cn.bmp)
		if cn.bmp&flag == 0 {

//line ctrie.go2:663
   return instantiate୦୦z୦bool(), false, true
		}

		branch := cn.array[pos]
		switch branch := branch.(type) {
		case *instantiate୦୦iNode୦bool:

//line ctrie.go2:671
   in := branch
			if startGen == in.gen {
				return c.iremove(in, entry, lev+w, i, startGen)
			}
			if instantiate୦୦gcas୦bool(i, main, &instantiate୦୦mainNode୦bool{cNode: cn.renewed(startGen, c)}, c) {
				return c.iremove(i, entry, lev, parent, startGen)
			}
			return instantiate୦୦z୦bool(), false, false
		case *instantiate୦୦sNode୦bool:

//line ctrie.go2:682
   sn := branch
			if !bytes.Equal(sn.entry.Key, entry.Key) {

				return instantiate୦୦z୦bool(), false, true
			}

//line ctrie.go2:693
   ncn := cn.removed(pos, flag, i.gen)
			cntr := instantiate୦୦toContracted୦bool(ncn, lev)
			if instantiate୦୦gcas୦bool(i, main, cntr, c) {
				if parent != nil {
					main = instantiate୦୦gcasRead୦bool(i, c)
					if main.tNode != nil {
//line ctrie.go2:698
      instantiate୦୦cleanParent୦bool(parent, i, entry.hash, lev-w, c, startGen)
//line ctrie.go2:700
     }
				}
				return sn.entry.Value, true, true
			}
			return instantiate୦୦z୦bool(), false, false
		default:
			panic("Ctrie is in an invalid state")
		}
	case main.tNode != nil:
//line ctrie.go2:708
  instantiate୦୦clean୦bool(parent, lev-w, c)
//line ctrie.go2:710
  return instantiate୦୦z୦bool(), false, false
	case main.lNode != nil:
		nln := &instantiate୦୦mainNode୦bool{lNode: main.lNode.removed(entry)}
		if nln.lNode != nil && nln.lNode.tail == nil {

			nln = instantiate୦୦entomb୦bool(nln.lNode.head)
		}
		if instantiate୦୦gcas୦bool(i, main, nln, c) {
			val, ok := main.lNode.lookup(entry)
			return val, ok, true
		}
		return instantiate୦୦z୦bool(), false, true
	default:
		panic("Ctrie is in an invalid state")
	}
}

//line ctrie.go2:900
func (c *instantiate୦୦Ctrie୦bool,) readRoot() *instantiate୦୦iNode୦bool {
	return c.rdcssReadRoot(false)
}

//line ctrie.go2:906
func (c *instantiate୦୦Ctrie୦bool,) rdcssReadRoot(abort bool) *instantiate୦୦iNode୦bool {
	r := instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8bool୮9(&c.root)
	if r.rdcss != nil {
		return c.rdcssComplete(abort)
	}
	return r
}

//line ctrie.go2:917
func (c *instantiate୦୦Ctrie୦bool,) rdcssRoot(old *instantiate୦୦iNode୦bool, expected *instantiate୦୦mainNode୦bool, nv *instantiate୦୦iNode୦bool,) bool {
	desc := &instantiate୦୦iNode୦bool{
		rdcss: &instantiate୦୦rdcssDescriptor୦bool{
			old:      old,
			expected: expected,
			nv:       nv,
		},
	}
	if c.casRoot(old, desc) {
		c.rdcssComplete(false)
		return gatomic.LoadInt32(&desc.rdcss.committed) == 1
	}
	return false
}

//line ctrie.go2:933
func (c *instantiate୦୦Ctrie୦bool,) rdcssComplete(abort bool) *instantiate୦୦iNode୦bool {
	for {
		r := instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8bool୮9(&c.root)
		if r.rdcss == nil {
			return r
		}

		var (
			desc = r.rdcss
			ov   = desc.old
			exp  = desc.expected
			nv   = desc.nv
		)

		if abort {
			if c.casRoot(r, ov) {
				return ov
			}
			continue
		}

		oldeMain := instantiate୦୦gcasRead୦bool(ov, c)
		if oldeMain == exp {

			if c.casRoot(r, nv) {
				gatomic.StoreInt32(&desc.committed, 1)
				return nv
			}
			continue
		}
		if c.casRoot(r, ov) {
			return ov
		}
		continue
	}
}

//line ctrie.go2:971
func (c *instantiate୦୦Ctrie୦bool,) casRoot(ov, nv *instantiate୦୦iNode୦bool,) bool {
	c.assertReadWrite()
	return instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮aiNode୮8bool୮9(&c.root, ov, nv)
}

//line ctrie.go2:974
type instantiate୦୦iNode୦bool struct {
//line ctrie.go2:67
 main *instantiate୦୦mainNode୦bool
			gen  *generation

//line ctrie.go2:73
 rdcss *instantiate୦୦rdcssDescriptor୦bool
}

//line ctrie.go2:77
func (i *instantiate୦୦iNode୦bool,) copyToGen(gen *generation, ctrie *instantiate୦୦Ctrie୦bool,) *instantiate୦୦iNode୦bool {
			nin := &instantiate୦୦iNode୦bool{gen: gen}
			main := instantiate୦୦gcasRead୦bool(i, ctrie)
//line ctrie.go2:79
 instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8bool୮9(&nin.main, main)
//line ctrie.go2:81
 return nin
}

//line ctrie.go2:82
type instantiate୦୦mainNode୦bool struct {
//line ctrie.go2:87
 cNode *instantiate୦୦cNode୦bool
			tNode  *instantiate୦୦tNode୦bool
			lNode  *instantiate୦୦lNode୦bool
			failed *instantiate୦୦mainNode୦bool

//line ctrie.go2:96
 prev *instantiate୦୦mainNode୦bool
}
//line ctrie.go2:97
type instantiate୦୦cNode୦bool struct {
//line ctrie.go2:103
 bmp uint32
	array []branch
	gen   *generation
}

//line ctrie.go2:140
func (c *instantiate୦୦cNode୦bool,) inserted(pos, flag uint32, br branch, gen *generation) *instantiate୦୦cNode୦bool {
	length := uint32(len(c.array))
	bmp := c.bmp
	array := make([]branch, length+1)
	copy(array, c.array)
	array[pos] = br
	for i, x := pos, uint32(0); x < length-pos; i++ {
		array[i+1] = c.array[i]
		x++
	}
	ncn := &instantiate୦୦cNode୦bool{bmp: bmp | flag, array: array, gen: gen}
	return ncn
}

//line ctrie.go2:156
func (c *instantiate୦୦cNode୦bool,) updated(pos uint32, br branch, gen *generation) *instantiate୦୦cNode୦bool {
	array := make([]branch, len(c.array))
	copy(array, c.array)
	array[pos] = br
	ncn := &instantiate୦୦cNode୦bool{bmp: c.bmp, array: array, gen: gen}
	return ncn
}

//line ctrie.go2:166
func (c *instantiate୦୦cNode୦bool,) removed(pos, flag uint32, gen *generation) *instantiate୦୦cNode୦bool {
	length := uint32(len(c.array))
	bmp := c.bmp
	array := make([]branch, length-1)
	for i := uint32(0); i < pos; i++ {
		array[i] = c.array[i]
	}
	for i, x := pos, uint32(0); x < length-pos-1; i++ {
		array[i] = c.array[i+1]
		x++
	}
	ncn := &instantiate୦୦cNode୦bool{bmp: bmp ^ flag, array: array, gen: gen}
	return ncn
}

//line ctrie.go2:183
func (c *instantiate୦୦cNode୦bool,) renewed(gen *generation, ctrie *instantiate୦୦Ctrie୦bool,) *instantiate୦୦cNode୦bool {
	array := make([]branch, len(c.array))
	for i, br := range c.array {
		switch t := br.(type) {
		case *instantiate୦୦iNode୦bool:
			array[i] = t.copyToGen(gen, ctrie)
		default:
			array[i] = br
		}
	}
	return &instantiate୦୦cNode୦bool{bmp: c.bmp, array: array, gen: gen}
}

//line ctrie.go2:278
func instantiate୦୦newCtrie୦bool(root *instantiate୦୦iNode୦bool, hashFactory HashFactory, readOnly bool) *instantiate୦୦Ctrie୦bool {
	return &instantiate୦୦Ctrie୦bool{
		root:        root,
		hashFactory: hashFactory,
		readOnly:    readOnly,
	}
}

//line ctrie.go2:284
type instantiate୦୦Entry୦string struct {
//line ctrie.go2:258
 Key   []byte
			Value string

//line ctrie.go2:260
 hash uint32
}

//line ctrie.go2:840
func instantiate୦୦gcasRead୦string(in *instantiate୦୦iNode୦string, ctrie *instantiate୦୦Ctrie୦string,) *instantiate୦୦mainNode୦string {
	m := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8string୮9(&in.main)
	prev := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8string୮9(&m.prev)
	if prev == nil {
		return m
	}
	return instantiate୦୦gcasComplete୦string(in, m, ctrie)
}

//line ctrie.go2:847
type instantiate୦୦Iter୦string struct {
//line ctrie.go2:385
 c *instantiate୦୦Ctrie୦string

//line ctrie.go2:389
 stack []instantiate୦୦iterFrame୦string
	curr *instantiate୦୦Entry୦string
}

//line ctrie.go2:403
func (i *instantiate୦୦Iter୦string,) Next() bool {
	i.curr = nil
	for i.curr == nil && len(i.stack) > 0 {
		if f := &i.stack[len(i.stack)-1]; !f.iter(i, f) {
			i.pop()
		}
	}
	return i.curr != nil
}

func (i *instantiate୦୦Iter୦string,) Value() string {
	if i.curr == nil {
		return instantiate୦୦z୦string()
	}
	return i.curr.Value
}

func (i *instantiate୦୦Iter୦string,) Key() []byte {
	if i.curr == nil {
		return nil
	}
	return i.curr.Key
}

func (i *instantiate୦୦Iter୦string,) mainIter(f *instantiate୦୦iterFrame୦string,) bool {
	if f.iNode == nil {
		return false
	}
	main := instantiate୦୦gcasRead୦string(f.iNode, i.c)
	f.iNode = nil
	switch {
	case main.cNode != nil:
		i.push((*instantiate୦୦Iter୦string).arrayIter).array = main.cNode.array
		return true
	case main.lNode != nil:
		i.push((*instantiate୦୦Iter୦string).listIter).lNode = main.lNode
		return true
	case main.tNode != nil:
		i.curr = main.tNode.sNode.entry
		return true
	}
	panic("unreachable")
}

func (i *instantiate୦୦Iter୦string,) arrayIter(f *instantiate୦୦iterFrame୦string,) bool {
	a := f.array
	if len(a) == 0 {
		return false
	}
	f.array = a[1:]
	switch b := a[0].(type) {
	case *instantiate୦୦iNode୦string:
		i.push((*instantiate୦୦Iter୦string).mainIter).iNode = b
		return true
	case *instantiate୦୦sNode୦string:
		i.curr = b.entry
		return true
	}
	panic("unreachable")
}

func (i *instantiate୦୦Iter୦string,) listIter(f *instantiate୦୦iterFrame୦string,) bool {
	l := f.lNode
	if l == nil {
		return false
	}
	f.lNode = f.lNode.tail
	i.curr = l.head.entry
	return true
}

func (i *instantiate୦୦Iter୦string,) pop() {
	i.stack = i.stack[0 : len(i.stack)-1]
}

func (i *instantiate୦୦Iter୦string,) push(f func(*instantiate୦୦Iter୦string, *instantiate୦୦iterFrame୦string,) bool) *instantiate୦୦iterFrame୦string {
	i.stack = append(i.stack, instantiate୦୦iterFrame୦string{})
	elem := &i.stack[len(i.stack)-1]
	elem.iter = f
	return elem
}

//line ctrie.go2:483
type instantiate୦୦sNode୦string struct {
//line ctrie.go2:265
 entry *instantiate୦୦Entry୦string
}

//line ctrie.go2:830
func instantiate୦୦gcas୦string(in *instantiate୦୦iNode୦string, old, n *instantiate୦୦mainNode୦string, ct *instantiate୦୦Ctrie୦string,) bool {
//line ctrie.go2:830
 instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8string୮9(&n.prev, old)
//line ctrie.go2:832
 if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8string୮9(&in.main, old, n) {
//line ctrie.go2:832
  instantiate୦୦gcasComplete୦string(in, n, ct)
//line ctrie.go2:834
  return instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8string୮9(&n.prev) == nil
	}
	return false
}
//line ctrie.go2:112
func instantiate୦୦newMainNode୦string(x *instantiate୦୦sNode୦string, xhc uint32, y *instantiate୦୦sNode୦string, yhc uint32, lev uint, gen *generation) *instantiate୦୦mainNode୦string {
	if lev < exp2 {
		xidx := (xhc >> lev) & 0x1f
		yidx := (yhc >> lev) & 0x1f
		bmp := uint32((1 << xidx) | (1 << yidx))

		if xidx == yidx {

			main := instantiate୦୦newMainNode୦string(x, xhc, y, yhc, lev+w, gen)
			iNode := &instantiate୦୦iNode୦string{main: main, gen: gen}
			return &instantiate୦୦mainNode୦string{cNode: &instantiate୦୦cNode୦string{bmp, []branch{iNode}, gen}}
		}
		if xidx < yidx {
			return &instantiate୦୦mainNode୦string{cNode: &instantiate୦୦cNode୦string{bmp, []branch{x, y}, gen}}
		}
		return &instantiate୦୦mainNode୦string{cNode: &instantiate୦୦cNode୦string{bmp, []branch{y, x}, gen}}
	}
	l := &instantiate୦୦lNode୦string{
		head: y,
		tail: &instantiate୦୦lNode୦string{
			head: x,
		},
	}
	return &instantiate୦୦mainNode୦string{lNode: l}
}

//line ctrie.go2:773
func instantiate୦୦clean୦string(i *instantiate୦୦iNode୦string, lev uint, ctrie *instantiate୦୦Ctrie୦string,) bool {
	main := instantiate୦୦gcasRead୦string(i, ctrie)
	if main.cNode != nil {
		return instantiate୦୦gcas୦string(i, main, instantiate୦୦toCompressed୦string(main.cNode, lev), ctrie)
	}
	return true
}

//line ctrie.go2:976
func instantiate୦୦z୦string() string {
			var v string

//line ctrie.go2:978
 return v
}
//line ctrie.go2:781
func instantiate୦୦cleanReadOnly୦string(tn *instantiate୦୦tNode୦string, lev uint, p *instantiate୦୦iNode୦string, ctrie *instantiate୦୦Ctrie୦string, entry *instantiate୦୦Entry୦string,) (val string, exists bool, ok bool) {
	if !ctrie.readOnly {
//line ctrie.go2:782
  instantiate୦୦clean୦string(p, lev-5, ctrie)
//line ctrie.go2:784
  return instantiate୦୦z୦string(), false, false
	}
	if tn.sNode.entry.hash == entry.hash && bytes.Equal(tn.sNode.entry.Key, entry.Key) {
		return tn.sNode.entry.Value, true, true
	}
	return instantiate୦୦z୦string(), false, true
}
//line ctrie.go2:731
func instantiate୦୦toContracted୦string(cn *instantiate୦୦cNode୦string, lev uint) *instantiate୦୦mainNode୦string {
	if lev > 0 && len(cn.array) == 1 {
		switch branch := cn.array[0].(type) {
		case *instantiate୦୦sNode୦string:
			return instantiate୦୦entomb୦string(branch)
		default:
			return &instantiate୦୦mainNode୦string{cNode: cn}
		}
	}
	return &instantiate୦୦mainNode୦string{cNode: cn}
}

//line ctrie.go2:792
func instantiate୦୦cleanParent୦string(p, i *instantiate୦୦iNode୦string, hc uint32, lev uint, ctrie *instantiate୦୦Ctrie୦string, startGen *generation) {
	main := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8string୮9(&i.main)
	pMain := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8string୮9(&p.main)
	if pMain.cNode != nil {
		flag, pos := flagPos(hc, lev, pMain.cNode.bmp)
		if pMain.cNode.bmp&flag != 0 {
			sub := pMain.cNode.array[pos]
			if sub == i && main.tNode != nil {
				ncn := pMain.cNode.updated(pos, instantiate୦୦resurrect୦string(i, main), i.gen)
				if !instantiate୦୦gcas୦string(p, pMain, instantiate୦୦toContracted୦string(ncn, lev), ctrie) && ctrie.readRoot().gen == startGen {
//line ctrie.go2:801
     instantiate୦୦cleanParent୦string(p, i, hc, lev, ctrie, startGen)
//line ctrie.go2:803
    }
			}
		}
	}
}
//line ctrie.go2:762
func instantiate୦୦entomb୦string(m *instantiate୦୦sNode୦string,) *instantiate୦୦mainNode୦string {
	return &instantiate୦୦mainNode୦string{tNode: &instantiate୦୦tNode୦string{m}}
}
//line ctrie_test.go2:4
func instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8string୮9(addr **instantiate୦୦iNode୦string,) *instantiate୦୦iNode୦string {
//line ctrie_test.go2:4
 return (*instantiate୦୦iNode୦string)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:6
 ))))
//line ctrie_test.go2:6
}

//line ctrie_test.go2:6
type instantiate୦୦rdcssDescriptor୦string struct {
//line ctrie.go2:891
 old *instantiate୦୦iNode୦string
	expected  *instantiate୦୦mainNode୦string
	nv        *instantiate୦୦iNode୦string
	committed int32
}

//line ctrie_test.go2:10
func instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮aiNode୮8string୮9(addr **instantiate୦୦iNode୦string, old, new *instantiate୦୦iNode୦string,) (swapped bool) {
	return atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:13
 )), unsafe.Pointer(old), unsafe.Pointer(new))
//line ctrie_test.go2:13
}
//line ctrie_test.go2:6
func instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8string୮9(addr **instantiate୦୦mainNode୦string, val *instantiate୦୦mainNode୦string,) {
//line ctrie_test.go2:8
  atomic.StorePointer((*unsafe.
//line ctrie_test.go2:10
  Pointer)(unsafe.Pointer(addr)), unsafe.Pointer(val))
//line ctrie_test.go2:10
}

//line ctrie_test.go2:10
type instantiate୦୦tNode୦string struct {
//line ctrie.go2:199
 sNode *instantiate୦୦sNode୦string
}

//line ctrie.go2:203
func (t *instantiate୦୦tNode୦string,) untombed() *instantiate୦୦sNode୦string {
	return &instantiate୦୦sNode୦string{&instantiate୦୦Entry୦string{Key: t.sNode.entry.Key, hash: t.sNode.entry.hash, Value: t.sNode.entry.Value}}
}

//line ctrie.go2:205
type instantiate୦୦lNode୦string struct {
//line ctrie.go2:210
 head *instantiate୦୦sNode୦string
	tail *instantiate୦୦lNode୦string
}

//line ctrie.go2:216
func (l *instantiate୦୦lNode୦string,) lookup(e *instantiate୦୦Entry୦string,) (string,

//line ctrie.go2:216
 bool) {
	for ; l != nil; l = l.tail {
		if bytes.Equal(e.Key, l.head.entry.Key) {
			return l.head.entry.Value, true
		}
	}
	return instantiate୦୦z୦string(), false
}

//line ctrie.go2:226
func (l *instantiate୦୦lNode୦string,) inserted(entry *instantiate୦୦Entry୦string,) *instantiate୦୦lNode୦string {
	return &instantiate୦୦lNode୦string{
		head: &instantiate୦୦sNode୦string{entry},
		tail: l.removed(entry),
	}
}

//line ctrie.go2:234
func (l *instantiate୦୦lNode୦string,) removed(e *instantiate୦୦Entry୦string,) *instantiate୦୦lNode୦string {
	for l1 := l; l1 != nil; l1 = l1.tail {
		if bytes.Equal(e.Key, l1.head.entry.Key) {
			return l.remove(l1)
		}
	}
	return l
}

func (l *instantiate୦୦lNode୦string,) remove(l1 *instantiate୦୦lNode୦string,) *instantiate୦୦lNode୦string {
	if l == l1 {
		return l.tail
	}
	return &instantiate୦୦lNode୦string{
		head: l.head,
		tail: l.tail.remove(l1),
	}
}

//line ctrie.go2:251
type instantiate୦୦Entry୦int struct {
//line ctrie.go2:258
 Key []byte
			Value int

//line ctrie.go2:260
 hash uint32
}

//line ctrie.go2:840
func instantiate୦୦gcasRead୦int(in *instantiate୦୦iNode୦int, ctrie *instantiate୦୦Ctrie୦int,) *instantiate୦୦mainNode୦int {
	m := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8int୮9(&in.main)
	prev := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8int୮9(&m.prev)
	if prev == nil {
		return m
	}
	return instantiate୦୦gcasComplete୦int(in, m, ctrie)
}

//line ctrie.go2:847
type instantiate୦୦Iter୦int struct {
//line ctrie.go2:385
 c *instantiate୦୦Ctrie୦int

//line ctrie.go2:389
 stack []instantiate୦୦iterFrame୦int
	curr *instantiate୦୦Entry୦int
}

//line ctrie.go2:403
func (i *instantiate୦୦Iter୦int,) Next() bool {
	i.curr = nil
	for i.curr == nil && len(i.stack) > 0 {
		if f := &i.stack[len(i.stack)-1]; !f.iter(i, f) {
			i.pop()
		}
	}
	return i.curr != nil
}

func (i *instantiate୦୦Iter୦int,) Value() int {
	if i.curr == nil {
		return instantiate୦୦z୦int()
	}
	return i.curr.Value
}

func (i *instantiate୦୦Iter୦int,) Key() []byte {
	if i.curr == nil {
		return nil
	}
	return i.curr.Key
}

func (i *instantiate୦୦Iter୦int,) mainIter(f *instantiate୦୦iterFrame୦int,) bool {
	if f.iNode == nil {
		return false
	}
	main := instantiate୦୦gcasRead୦int(f.iNode, i.c)
	f.iNode = nil
	switch {
	case main.cNode != nil:
		i.push((*instantiate୦୦Iter୦int).arrayIter).array = main.cNode.array
		return true
	case main.lNode != nil:
		i.push((*instantiate୦୦Iter୦int).listIter).lNode = main.lNode
		return true
	case main.tNode != nil:
		i.curr = main.tNode.sNode.entry
		return true
	}
	panic("unreachable")
}

func (i *instantiate୦୦Iter୦int,) arrayIter(f *instantiate୦୦iterFrame୦int,) bool {
	a := f.array
	if len(a) == 0 {
		return false
	}
	f.array = a[1:]
	switch b := a[0].(type) {
	case *instantiate୦୦iNode୦int:
		i.push((*instantiate୦୦Iter୦int).mainIter).iNode = b
		return true
	case *instantiate୦୦sNode୦int:
		i.curr = b.entry
		return true
	}
	panic("unreachable")
}

func (i *instantiate୦୦Iter୦int,) listIter(f *instantiate୦୦iterFrame୦int,) bool {
	l := f.lNode
	if l == nil {
		return false
	}
	f.lNode = f.lNode.tail
	i.curr = l.head.entry
	return true
}

func (i *instantiate୦୦Iter୦int,) pop() {
	i.stack = i.stack[0 : len(i.stack)-1]
}

func (i *instantiate୦୦Iter୦int,) push(f func(*instantiate୦୦Iter୦int, *instantiate୦୦iterFrame୦int,) bool) *instantiate୦୦iterFrame୦int {
	i.stack = append(i.stack, instantiate୦୦iterFrame୦int{})
	elem := &i.stack[len(i.stack)-1]
	elem.iter = f
	return elem
}

//line ctrie.go2:483
type instantiate୦୦sNode୦int struct {
//line ctrie.go2:265
 entry *instantiate୦୦Entry୦int
}

//line ctrie.go2:830
func instantiate୦୦gcas୦int(in *instantiate୦୦iNode୦int, old, n *instantiate୦୦mainNode୦int, ct *instantiate୦୦Ctrie୦int,) bool {
//line ctrie.go2:830
 instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8int୮9(&n.prev, old)
//line ctrie.go2:832
 if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8int୮9(&in.main, old, n) {
//line ctrie.go2:832
  instantiate୦୦gcasComplete୦int(in, n, ct)
//line ctrie.go2:834
  return instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8int୮9(&n.prev) == nil
	}
	return false
}
//line ctrie.go2:112
func instantiate୦୦newMainNode୦int(x *instantiate୦୦sNode୦int, xhc uint32, y *instantiate୦୦sNode୦int, yhc uint32, lev uint, gen *generation) *instantiate୦୦mainNode୦int {
	if lev < exp2 {
		xidx := (xhc >> lev) & 0x1f
		yidx := (yhc >> lev) & 0x1f
		bmp := uint32((1 << xidx) | (1 << yidx))

		if xidx == yidx {

			main := instantiate୦୦newMainNode୦int(x, xhc, y, yhc, lev+w, gen)
			iNode := &instantiate୦୦iNode୦int{main: main, gen: gen}
			return &instantiate୦୦mainNode୦int{cNode: &instantiate୦୦cNode୦int{bmp, []branch{iNode}, gen}}
		}
		if xidx < yidx {
			return &instantiate୦୦mainNode୦int{cNode: &instantiate୦୦cNode୦int{bmp, []branch{x, y}, gen}}
		}
		return &instantiate୦୦mainNode୦int{cNode: &instantiate୦୦cNode୦int{bmp, []branch{y, x}, gen}}
	}
	l := &instantiate୦୦lNode୦int{
		head: y,
		tail: &instantiate୦୦lNode୦int{
			head: x,
		},
	}
	return &instantiate୦୦mainNode୦int{lNode: l}
}

//line ctrie.go2:773
func instantiate୦୦clean୦int(i *instantiate୦୦iNode୦int, lev uint, ctrie *instantiate୦୦Ctrie୦int,) bool {
	main := instantiate୦୦gcasRead୦int(i, ctrie)
	if main.cNode != nil {
		return instantiate୦୦gcas୦int(i, main, instantiate୦୦toCompressed୦int(main.cNode, lev), ctrie)
	}
	return true
}

//line ctrie.go2:976
func instantiate୦୦z୦int() int {
			var v int

//line ctrie.go2:978
 return v
}
//line ctrie.go2:781
func instantiate୦୦cleanReadOnly୦int(tn *instantiate୦୦tNode୦int, lev uint, p *instantiate୦୦iNode୦int, ctrie *instantiate୦୦Ctrie୦int, entry *instantiate୦୦Entry୦int,) (val int, exists bool, ok bool) {
	if !ctrie.readOnly {
//line ctrie.go2:782
  instantiate୦୦clean୦int(p, lev-5, ctrie)
//line ctrie.go2:784
  return instantiate୦୦z୦int(), false, false
	}
	if tn.sNode.entry.hash == entry.hash && bytes.Equal(tn.sNode.entry.Key, entry.Key) {
		return tn.sNode.entry.Value, true, true
	}
	return instantiate୦୦z୦int(), false, true
}
//line ctrie.go2:731
func instantiate୦୦toContracted୦int(cn *instantiate୦୦cNode୦int, lev uint) *instantiate୦୦mainNode୦int {
	if lev > 0 && len(cn.array) == 1 {
		switch branch := cn.array[0].(type) {
		case *instantiate୦୦sNode୦int:
			return instantiate୦୦entomb୦int(branch)
		default:
			return &instantiate୦୦mainNode୦int{cNode: cn}
		}
	}
	return &instantiate୦୦mainNode୦int{cNode: cn}
}

//line ctrie.go2:792
func instantiate୦୦cleanParent୦int(p, i *instantiate୦୦iNode୦int, hc uint32, lev uint, ctrie *instantiate୦୦Ctrie୦int, startGen *generation) {
	main := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8int୮9(&i.main)
	pMain := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8int୮9(&p.main)
	if pMain.cNode != nil {
		flag, pos := flagPos(hc, lev, pMain.cNode.bmp)
		if pMain.cNode.bmp&flag != 0 {
			sub := pMain.cNode.array[pos]
			if sub == i && main.tNode != nil {
				ncn := pMain.cNode.updated(pos, instantiate୦୦resurrect୦int(i, main), i.gen)
				if !instantiate୦୦gcas୦int(p, pMain, instantiate୦୦toContracted୦int(ncn, lev), ctrie) && ctrie.readRoot().gen == startGen {
//line ctrie.go2:801
     instantiate୦୦cleanParent୦int(p, i, hc, lev, ctrie, startGen)
//line ctrie.go2:803
    }
			}
		}
	}
}
//line ctrie.go2:762
func instantiate୦୦entomb୦int(m *instantiate୦୦sNode୦int,) *instantiate୦୦mainNode୦int {
	return &instantiate୦୦mainNode୦int{tNode: &instantiate୦୦tNode୦int{m}}
}
//line ctrie_test.go2:4
func instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8int୮9(addr **instantiate୦୦iNode୦int,) *instantiate୦୦iNode୦int {
//line ctrie_test.go2:4
 return (*instantiate୦୦iNode୦int)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:6
 ))))
//line ctrie_test.go2:6
}

//line ctrie_test.go2:6
type instantiate୦୦rdcssDescriptor୦int struct {
//line ctrie.go2:891
 old *instantiate୦୦iNode୦int
	expected  *instantiate୦୦mainNode୦int
	nv        *instantiate୦୦iNode୦int
	committed int32
}

//line ctrie_test.go2:10
func instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮aiNode୮8int୮9(addr **instantiate୦୦iNode୦int, old, new *instantiate୦୦iNode୦int,) (swapped bool) {
	return atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:13
 )), unsafe.Pointer(old), unsafe.Pointer(new))
//line ctrie_test.go2:13
}
//line ctrie_test.go2:6
func instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8int୮9(addr **instantiate୦୦mainNode୦int, val *instantiate୦୦mainNode୦int,) {
//line ctrie_test.go2:8
  atomic.StorePointer((*unsafe.
//line ctrie_test.go2:10
  Pointer)(unsafe.Pointer(addr)), unsafe.Pointer(val))
//line ctrie_test.go2:10
}

//line ctrie_test.go2:10
type instantiate୦୦tNode୦int struct {
//line ctrie.go2:199
 sNode *instantiate୦୦sNode୦int
}

//line ctrie.go2:203
func (t *instantiate୦୦tNode୦int,) untombed() *instantiate୦୦sNode୦int {
	return &instantiate୦୦sNode୦int{&instantiate୦୦Entry୦int{Key: t.sNode.entry.Key, hash: t.sNode.entry.hash, Value: t.sNode.entry.Value}}
}

//line ctrie.go2:205
type instantiate୦୦lNode୦int struct {
//line ctrie.go2:210
 head *instantiate୦୦sNode୦int
	tail *instantiate୦୦lNode୦int
}

//line ctrie.go2:216
func (l *instantiate୦୦lNode୦int,) lookup(e *instantiate୦୦Entry୦int,) (int,

//line ctrie.go2:216
 bool) {
	for ; l != nil; l = l.tail {
		if bytes.Equal(e.Key, l.head.entry.Key) {
			return l.head.entry.Value, true
		}
	}
	return instantiate୦୦z୦int(), false
}

//line ctrie.go2:226
func (l *instantiate୦୦lNode୦int,) inserted(entry *instantiate୦୦Entry୦int,) *instantiate୦୦lNode୦int {
	return &instantiate୦୦lNode୦int{
		head: &instantiate୦୦sNode୦int{entry},
		tail: l.removed(entry),
	}
}

//line ctrie.go2:234
func (l *instantiate୦୦lNode୦int,) removed(e *instantiate୦୦Entry୦int,) *instantiate୦୦lNode୦int {
	for l1 := l; l1 != nil; l1 = l1.tail {
		if bytes.Equal(e.Key, l1.head.entry.Key) {
			return l.remove(l1)
		}
	}
	return l
}

func (l *instantiate୦୦lNode୦int,) remove(l1 *instantiate୦୦lNode୦int,) *instantiate୦୦lNode୦int {
	if l == l1 {
		return l.tail
	}
	return &instantiate୦୦lNode୦int{
		head: l.head,
		tail: l.tail.remove(l1),
	}
}

//line ctrie.go2:251
type instantiate୦୦Entry୦interface୮4୮5 struct {
//line ctrie.go2:258
 Key []byte
			Value interface{}

//line ctrie.go2:260
 hash uint32
}

//line ctrie.go2:840
func instantiate୦୦gcasRead୦interface୮4୮5(in *instantiate୦୦iNode୦interface୮4୮5, ctrie *instantiate୦୦Ctrie୦interface୮4୮5,) *instantiate୦୦mainNode୦interface୮4୮5 {
	m := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8interface୮4୮5୮9(&in.main)
	prev := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8interface୮4୮5୮9(&m.prev)
	if prev == nil {
		return m
	}
	return instantiate୦୦gcasComplete୦interface୮4୮5(in, m, ctrie)
}

//line ctrie.go2:847
type instantiate୦୦Iter୦interface୮4୮5 struct {
//line ctrie.go2:385
 c *instantiate୦୦Ctrie୦interface୮4୮5

//line ctrie.go2:389
 stack []instantiate୦୦iterFrame୦interface୮4୮5
	curr *instantiate୦୦Entry୦interface୮4୮5
}

//line ctrie.go2:403
func (i *instantiate୦୦Iter୦interface୮4୮5,) Next() bool {
	i.curr = nil
	for i.curr == nil && len(i.stack) > 0 {
		if f := &i.stack[len(i.stack)-1]; !f.iter(i, f) {
			i.pop()
		}
	}
	return i.curr != nil
}

func (i *instantiate୦୦Iter୦interface୮4୮5,) Value() interface{} {
	if i.curr == nil {
		return instantiate୦୦z୦interface୮4୮5()
	}
	return i.curr.Value
}

func (i *instantiate୦୦Iter୦interface୮4୮5,) Key() []byte {
	if i.curr == nil {
		return nil
	}
	return i.curr.Key
}

func (i *instantiate୦୦Iter୦interface୮4୮5,) mainIter(f *instantiate୦୦iterFrame୦interface୮4୮5,) bool {
	if f.iNode == nil {
		return false
	}
	main := instantiate୦୦gcasRead୦interface୮4୮5(f.iNode, i.c)
	f.iNode = nil
	switch {
	case main.cNode != nil:
		i.push((*instantiate୦୦Iter୦interface୮4୮5).arrayIter).array = main.cNode.array
		return true
	case main.lNode != nil:
		i.push((*instantiate୦୦Iter୦interface୮4୮5).listIter).lNode = main.lNode
		return true
	case main.tNode != nil:
		i.curr = main.tNode.sNode.entry
		return true
	}
	panic("unreachable")
}

func (i *instantiate୦୦Iter୦interface୮4୮5,) arrayIter(f *instantiate୦୦iterFrame୦interface୮4୮5,) bool {
	a := f.array
	if len(a) == 0 {
		return false
	}
	f.array = a[1:]
	switch b := a[0].(type) {
	case *instantiate୦୦iNode୦interface୮4୮5:
		i.push((*instantiate୦୦Iter୦interface୮4୮5).mainIter).iNode = b
		return true
	case *instantiate୦୦sNode୦interface୮4୮5:
		i.curr = b.entry
		return true
	}
	panic("unreachable")
}

func (i *instantiate୦୦Iter୦interface୮4୮5,) listIter(f *instantiate୦୦iterFrame୦interface୮4୮5,) bool {
	l := f.lNode
	if l == nil {
		return false
	}
	f.lNode = f.lNode.tail
	i.curr = l.head.entry
	return true
}

func (i *instantiate୦୦Iter୦interface୮4୮5,) pop() {
	i.stack = i.stack[0 : len(i.stack)-1]
}

func (i *instantiate୦୦Iter୦interface୮4୮5,) push(f func(*instantiate୦୦Iter୦interface୮4୮5, *instantiate୦୦iterFrame୦interface୮4୮5,) bool) *instantiate୦୦iterFrame୦interface୮4୮5 {
	i.stack = append(i.stack, instantiate୦୦iterFrame୦interface୮4୮5{})
	elem := &i.stack[len(i.stack)-1]
	elem.iter = f
	return elem
}

//line ctrie.go2:483
type instantiate୦୦sNode୦interface୮4୮5 struct {
//line ctrie.go2:265
 entry *instantiate୦୦Entry୦interface୮4୮5
}

//line ctrie.go2:830
func instantiate୦୦gcas୦interface୮4୮5(in *instantiate୦୦iNode୦interface୮4୮5, old, n *instantiate୦୦mainNode୦interface୮4୮5, ct *instantiate୦୦Ctrie୦interface୮4୮5,) bool {
//line ctrie.go2:830
 instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8interface୮4୮5୮9(&n.prev, old)
//line ctrie.go2:832
 if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8interface୮4୮5୮9(&in.main, old, n) {
//line ctrie.go2:832
  instantiate୦୦gcasComplete୦interface୮4୮5(in, n, ct)
//line ctrie.go2:834
  return instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8interface୮4୮5୮9(&n.prev) == nil
	}
	return false
}
//line ctrie.go2:112
func instantiate୦୦newMainNode୦interface୮4୮5(x *instantiate୦୦sNode୦interface୮4୮5, xhc uint32, y *instantiate୦୦sNode୦interface୮4୮5, yhc uint32, lev uint, gen *generation) *instantiate୦୦mainNode୦interface୮4୮5 {
	if lev < exp2 {
		xidx := (xhc >> lev) & 0x1f
		yidx := (yhc >> lev) & 0x1f
		bmp := uint32((1 << xidx) | (1 << yidx))

		if xidx == yidx {

			main := instantiate୦୦newMainNode୦interface୮4୮5(x, xhc, y, yhc, lev+w, gen)
			iNode := &instantiate୦୦iNode୦interface୮4୮5{main: main, gen: gen}
			return &instantiate୦୦mainNode୦interface୮4୮5{cNode: &instantiate୦୦cNode୦interface୮4୮5{bmp, []branch{iNode}, gen}}
		}
		if xidx < yidx {
			return &instantiate୦୦mainNode୦interface୮4୮5{cNode: &instantiate୦୦cNode୦interface୮4୮5{bmp, []branch{x, y}, gen}}
		}
		return &instantiate୦୦mainNode୦interface୮4୮5{cNode: &instantiate୦୦cNode୦interface୮4୮5{bmp, []branch{y, x}, gen}}
	}
	l := &instantiate୦୦lNode୦interface୮4୮5{
		head: y,
		tail: &instantiate୦୦lNode୦interface୮4୮5{
			head: x,
		},
	}
	return &instantiate୦୦mainNode୦interface୮4୮5{lNode: l}
}

//line ctrie.go2:773
func instantiate୦୦clean୦interface୮4୮5(i *instantiate୦୦iNode୦interface୮4୮5, lev uint, ctrie *instantiate୦୦Ctrie୦interface୮4୮5,) bool {
	main := instantiate୦୦gcasRead୦interface୮4୮5(i, ctrie)
	if main.cNode != nil {
		return instantiate୦୦gcas୦interface୮4୮5(i, main, instantiate୦୦toCompressed୦interface୮4୮5(main.cNode, lev), ctrie)
	}
	return true
}

//line ctrie.go2:976
func instantiate୦୦z୦interface୮4୮5() interface{} {
			var v interface{}

//line ctrie.go2:978
 return v
}
//line ctrie.go2:781
func instantiate୦୦cleanReadOnly୦interface୮4୮5(tn *instantiate୦୦tNode୦interface୮4୮5, lev uint, p *instantiate୦୦iNode୦interface୮4୮5, ctrie *instantiate୦୦Ctrie୦interface୮4୮5, entry *instantiate୦୦Entry୦interface୮4୮5,) (val interface {
//line ctrie.go2:781
}, exists bool, ok bool) {
	if !ctrie.readOnly {
//line ctrie.go2:782
  instantiate୦୦clean୦interface୮4୮5(p, lev-5, ctrie)
//line ctrie.go2:784
  return instantiate୦୦z୦interface୮4୮5(), false, false
	}
	if tn.sNode.entry.hash == entry.hash && bytes.Equal(tn.sNode.entry.Key, entry.Key) {
		return tn.sNode.entry.Value, true, true
	}
	return instantiate୦୦z୦interface୮4୮5(), false, true
}
//line ctrie.go2:731
func instantiate୦୦toContracted୦interface୮4୮5(cn *instantiate୦୦cNode୦interface୮4୮5, lev uint) *instantiate୦୦mainNode୦interface୮4୮5 {
	if lev > 0 && len(cn.array) == 1 {
		switch branch := cn.array[0].(type) {
		case *instantiate୦୦sNode୦interface୮4୮5:
			return instantiate୦୦entomb୦interface୮4୮5(branch)
		default:
			return &instantiate୦୦mainNode୦interface୮4୮5{cNode: cn}
		}
	}
	return &instantiate୦୦mainNode୦interface୮4୮5{cNode: cn}
}

//line ctrie.go2:792
func instantiate୦୦cleanParent୦interface୮4୮5(p, i *instantiate୦୦iNode୦interface୮4୮5, hc uint32, lev uint, ctrie *instantiate୦୦Ctrie୦interface୮4୮5, startGen *generation) {
	main := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8interface୮4୮5୮9(&i.main)
	pMain := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8interface୮4୮5୮9(&p.main)
	if pMain.cNode != nil {
		flag, pos := flagPos(hc, lev, pMain.cNode.bmp)
		if pMain.cNode.bmp&flag != 0 {
			sub := pMain.cNode.array[pos]
			if sub == i && main.tNode != nil {
				ncn := pMain.cNode.updated(pos, instantiate୦୦resurrect୦interface୮4୮5(i, main), i.gen)
				if !instantiate୦୦gcas୦interface୮4୮5(p, pMain, instantiate୦୦toContracted୦interface୮4୮5(ncn, lev), ctrie) && ctrie.readRoot().gen == startGen {
//line ctrie.go2:801
     instantiate୦୦cleanParent୦interface୮4୮5(p, i, hc, lev, ctrie, startGen)
//line ctrie.go2:803
    }
			}
		}
	}
}
//line ctrie.go2:762
func instantiate୦୦entomb୦interface୮4୮5(m *instantiate୦୦sNode୦interface୮4୮5,) *instantiate୦୦mainNode୦interface୮4୮5 {
	return &instantiate୦୦mainNode୦interface୮4୮5{tNode: &instantiate୦୦tNode୦interface୮4୮5{m}}
}
//line ctrie_test.go2:4
func instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8interface୮4୮5୮9(addr **instantiate୦୦iNode୦interface୮4୮5) *instantiate୦୦iNode୦interface୮4୮5 {
//line ctrie_test.go2:4
 return (*instantiate୦୦iNode୦interface୮4୮5)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:6
 ))))
//line ctrie_test.go2:6
}

//line ctrie_test.go2:6
type instantiate୦୦rdcssDescriptor୦interface୮4୮5 struct {
//line ctrie.go2:891
 old *instantiate୦୦iNode୦interface୮4୮5
	expected  *instantiate୦୦mainNode୦interface୮4୮5
	nv        *instantiate୦୦iNode୦interface୮4୮5
	committed int32
}

//line ctrie_test.go2:10
func instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮aiNode୮8interface୮4୮5୮9(addr **instantiate୦୦iNode୦interface୮4୮5, old, new *instantiate୦୦iNode୦interface୮4୮5,) (swapped bool) {
	return atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:13
 )), unsafe.Pointer(old), unsafe.Pointer(new))
//line ctrie_test.go2:13
}
//line ctrie_test.go2:6
func instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8interface୮4୮5୮9(addr **instantiate୦୦mainNode୦interface୮4୮5, val *instantiate୦୦mainNode୦interface୮4୮5,) {
//line ctrie_test.go2:8
  atomic.StorePointer((*unsafe.
//line ctrie_test.go2:10
  Pointer)(unsafe.Pointer(addr)), unsafe.Pointer(val))
//line ctrie_test.go2:10
}

//line ctrie_test.go2:10
type instantiate୦୦tNode୦interface୮4୮5 struct {
//line ctrie.go2:199
 sNode *instantiate୦୦sNode୦interface୮4୮5
}

//line ctrie.go2:203
func (t *instantiate୦୦tNode୦interface୮4୮5,) untombed() *instantiate୦୦sNode୦interface୮4୮5 {
	return &instantiate୦୦sNode୦interface୮4୮5{&instantiate୦୦Entry୦interface୮4୮5{Key: t.sNode.entry.Key, hash: t.sNode.entry.hash, Value: t.sNode.entry.Value}}
}

//line ctrie.go2:205
type instantiate୦୦lNode୦interface୮4୮5 struct {
//line ctrie.go2:210
 head *instantiate୦୦sNode୦interface୮4୮5
	tail *instantiate୦୦lNode୦interface୮4୮5
}

//line ctrie.go2:216
func (l *instantiate୦୦lNode୦interface୮4୮5,) lookup(e *instantiate୦୦Entry୦interface୮4୮5,) (interface{},

//line ctrie.go2:216
 bool) {
	for ; l != nil; l = l.tail {
		if bytes.Equal(e.Key, l.head.entry.Key) {
			return l.head.entry.Value, true
		}
	}
	return instantiate୦୦z୦interface୮4୮5(), false
}

//line ctrie.go2:226
func (l *instantiate୦୦lNode୦interface୮4୮5,) inserted(entry *instantiate୦୦Entry୦interface୮4୮5,) *instantiate୦୦lNode୦interface୮4୮5 {
	return &instantiate୦୦lNode୦interface୮4୮5{
		head: &instantiate୦୦sNode୦interface୮4୮5{entry},
		tail: l.removed(entry),
	}
}

//line ctrie.go2:234
func (l *instantiate୦୦lNode୦interface୮4୮5,) removed(e *instantiate୦୦Entry୦interface୮4୮5,) *instantiate୦୦lNode୦interface୮4୮5 {
	for l1 := l; l1 != nil; l1 = l1.tail {
		if bytes.Equal(e.Key, l1.head.entry.Key) {
			return l.remove(l1)
		}
	}
	return l
}

func (l *instantiate୦୦lNode୦interface୮4୮5,) remove(l1 *instantiate୦୦lNode୦interface୮4୮5,) *instantiate୦୦lNode୦interface୮4୮5 {
	if l == l1 {
		return l.tail
	}
	return &instantiate୦୦lNode୦interface୮4୮5{
		head: l.head,
		tail: l.tail.remove(l1),
	}
}

//line ctrie.go2:251
type instantiate୦୦Entry୦bool struct {
//line ctrie.go2:258
 Key []byte
	Value bool
	hash  uint32
}

//line ctrie.go2:840
func instantiate୦୦gcasRead୦bool(in *instantiate୦୦iNode୦bool, ctrie *instantiate୦୦Ctrie୦bool,) *instantiate୦୦mainNode୦bool {
	m := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8bool୮9(&in.main)
	prev := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8bool୮9(&m.prev)
	if prev == nil {
		return m
	}
	return instantiate୦୦gcasComplete୦bool(in, m, ctrie)
}

//line ctrie.go2:847
type instantiate୦୦Iter୦bool struct {
//line ctrie.go2:385
 c *instantiate୦୦Ctrie୦bool

//line ctrie.go2:389
 stack []instantiate୦୦iterFrame୦bool
	curr *instantiate୦୦Entry୦bool
}

//line ctrie.go2:403
func (i *instantiate୦୦Iter୦bool,) Next() bool {
	i.curr = nil
	for i.curr == nil && len(i.stack) > 0 {
		if f := &i.stack[len(i.stack)-1]; !f.iter(i, f) {
			i.pop()
		}
	}
	return i.curr != nil
}

func (i *instantiate୦୦Iter୦bool,) Value() bool {
	if i.curr == nil {
		return instantiate୦୦z୦bool()
	}
	return i.curr.Value
}

func (i *instantiate୦୦Iter୦bool,) Key() []byte {
	if i.curr == nil {
		return nil
	}
	return i.curr.Key
}

func (i *instantiate୦୦Iter୦bool,) mainIter(f *instantiate୦୦iterFrame୦bool,) bool {
	if f.iNode == nil {
		return false
	}
	main := instantiate୦୦gcasRead୦bool(f.iNode, i.c)
	f.iNode = nil
	switch {
	case main.cNode != nil:
		i.push((*instantiate୦୦Iter୦bool).arrayIter).array = main.cNode.array
		return true
	case main.lNode != nil:
		i.push((*instantiate୦୦Iter୦bool).listIter).lNode = main.lNode
		return true
	case main.tNode != nil:
		i.curr = main.tNode.sNode.entry
		return true
	}
	panic("unreachable")
}

func (i *instantiate୦୦Iter୦bool,) arrayIter(f *instantiate୦୦iterFrame୦bool,) bool {
	a := f.array
	if len(a) == 0 {
		return false
	}
	f.array = a[1:]
	switch b := a[0].(type) {
	case *instantiate୦୦iNode୦bool:
		i.push((*instantiate୦୦Iter୦bool).mainIter).iNode = b
		return true
	case *instantiate୦୦sNode୦bool:
		i.curr = b.entry
		return true
	}
	panic("unreachable")
}

func (i *instantiate୦୦Iter୦bool,) listIter(f *instantiate୦୦iterFrame୦bool,) bool {
	l := f.lNode
	if l == nil {
		return false
	}
	f.lNode = f.lNode.tail
	i.curr = l.head.entry
	return true
}

func (i *instantiate୦୦Iter୦bool,) pop() {
	i.stack = i.stack[0 : len(i.stack)-1]
}

func (i *instantiate୦୦Iter୦bool,) push(f func(*instantiate୦୦Iter୦bool, *instantiate୦୦iterFrame୦bool,) bool) *instantiate୦୦iterFrame୦bool {
	i.stack = append(i.stack, instantiate୦୦iterFrame୦bool{})
	elem := &i.stack[len(i.stack)-1]
	elem.iter = f
	return elem
}

//line ctrie.go2:483
type instantiate୦୦sNode୦bool struct {
//line ctrie.go2:265
 entry *instantiate୦୦Entry୦bool
}

//line ctrie.go2:830
func instantiate୦୦gcas୦bool(in *instantiate୦୦iNode୦bool, old, n *instantiate୦୦mainNode୦bool, ct *instantiate୦୦Ctrie୦bool,) bool {
//line ctrie.go2:830
 instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8bool୮9(&n.prev, old)
//line ctrie.go2:832
 if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8bool୮9(&in.main, old, n) {
//line ctrie.go2:832
  instantiate୦୦gcasComplete୦bool(in, n, ct)
//line ctrie.go2:834
  return instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8bool୮9(&n.prev) == nil
	}
	return false
}
//line ctrie.go2:112
func instantiate୦୦newMainNode୦bool(x *instantiate୦୦sNode୦bool, xhc uint32, y *instantiate୦୦sNode୦bool, yhc uint32, lev uint, gen *generation) *instantiate୦୦mainNode୦bool {
	if lev < exp2 {
		xidx := (xhc >> lev) & 0x1f
		yidx := (yhc >> lev) & 0x1f
		bmp := uint32((1 << xidx) | (1 << yidx))

		if xidx == yidx {

			main := instantiate୦୦newMainNode୦bool(x, xhc, y, yhc, lev+w, gen)
			iNode := &instantiate୦୦iNode୦bool{main: main, gen: gen}
			return &instantiate୦୦mainNode୦bool{cNode: &instantiate୦୦cNode୦bool{bmp, []branch{iNode}, gen}}
		}
		if xidx < yidx {
			return &instantiate୦୦mainNode୦bool{cNode: &instantiate୦୦cNode୦bool{bmp, []branch{x, y}, gen}}
		}
		return &instantiate୦୦mainNode୦bool{cNode: &instantiate୦୦cNode୦bool{bmp, []branch{y, x}, gen}}
	}
	l := &instantiate୦୦lNode୦bool{
		head: y,
		tail: &instantiate୦୦lNode୦bool{
			head: x,
		},
	}
	return &instantiate୦୦mainNode୦bool{lNode: l}
}

//line ctrie.go2:773
func instantiate୦୦clean୦bool(i *instantiate୦୦iNode୦bool, lev uint, ctrie *instantiate୦୦Ctrie୦bool,) bool {
	main := instantiate୦୦gcasRead୦bool(i, ctrie)
	if main.cNode != nil {
		return instantiate୦୦gcas୦bool(i, main, instantiate୦୦toCompressed୦bool(main.cNode, lev), ctrie)
	}
	return true
}

//line ctrie.go2:976
func instantiate୦୦z୦bool() bool {
			var v bool

//line ctrie.go2:978
 return v
}
//line ctrie.go2:781
func instantiate୦୦cleanReadOnly୦bool(tn *instantiate୦୦tNode୦bool, lev uint, p *instantiate୦୦iNode୦bool, ctrie *instantiate୦୦Ctrie୦bool, entry *instantiate୦୦Entry୦bool,) (val bool, exists bool, ok bool) {
	if !ctrie.readOnly {
//line ctrie.go2:782
  instantiate୦୦clean୦bool(p, lev-5, ctrie)
//line ctrie.go2:784
  return instantiate୦୦z୦bool(), false, false
	}
	if tn.sNode.entry.hash == entry.hash && bytes.Equal(tn.sNode.entry.Key, entry.Key) {
		return tn.sNode.entry.Value, true, true
	}
	return instantiate୦୦z୦bool(), false, true
}
//line ctrie.go2:731
func instantiate୦୦toContracted୦bool(cn *instantiate୦୦cNode୦bool, lev uint) *instantiate୦୦mainNode୦bool {
	if lev > 0 && len(cn.array) == 1 {
		switch branch := cn.array[0].(type) {
		case *instantiate୦୦sNode୦bool:
			return instantiate୦୦entomb୦bool(branch)
		default:
			return &instantiate୦୦mainNode୦bool{cNode: cn}
		}
	}
	return &instantiate୦୦mainNode୦bool{cNode: cn}
}

//line ctrie.go2:792
func instantiate୦୦cleanParent୦bool(p, i *instantiate୦୦iNode୦bool, hc uint32, lev uint, ctrie *instantiate୦୦Ctrie୦bool, startGen *generation) {
	main := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8bool୮9(&i.main)
	pMain := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8bool୮9(&p.main)
	if pMain.cNode != nil {
		flag, pos := flagPos(hc, lev, pMain.cNode.bmp)
		if pMain.cNode.bmp&flag != 0 {
			sub := pMain.cNode.array[pos]
			if sub == i && main.tNode != nil {
				ncn := pMain.cNode.updated(pos, instantiate୦୦resurrect୦bool(i, main), i.gen)
				if !instantiate୦୦gcas୦bool(p, pMain, instantiate୦୦toContracted୦bool(ncn, lev), ctrie) && ctrie.readRoot().gen == startGen {
//line ctrie.go2:801
     instantiate୦୦cleanParent୦bool(p, i, hc, lev, ctrie, startGen)
//line ctrie.go2:803
    }
			}
		}
	}
}
//line ctrie.go2:762
func instantiate୦୦entomb୦bool(m *instantiate୦୦sNode୦bool,) *instantiate୦୦mainNode୦bool {
	return &instantiate୦୦mainNode୦bool{tNode: &instantiate୦୦tNode୦bool{m}}
}
//line ctrie_test.go2:4
func instantiate୦gatomic୦LoadPointer୦ctrie୮aiNode୮8bool୮9(addr **instantiate୦୦iNode୦bool,) *instantiate୦୦iNode୦bool {
//line ctrie_test.go2:4
 return (*instantiate୦୦iNode୦bool)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:6
 ))))
//line ctrie_test.go2:6
}

//line ctrie_test.go2:6
type instantiate୦୦rdcssDescriptor୦bool struct {
//line ctrie.go2:891
 old *instantiate୦୦iNode୦bool
	expected  *instantiate୦୦mainNode୦bool
	nv        *instantiate୦୦iNode୦bool
	committed int32
}

//line ctrie_test.go2:10
func instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮aiNode୮8bool୮9(addr **instantiate୦୦iNode୦bool, old, new *instantiate୦୦iNode୦bool,) (swapped bool) {
	return atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:13
 )), unsafe.Pointer(old), unsafe.Pointer(new))
//line ctrie_test.go2:13
}
//line ctrie_test.go2:6
func instantiate୦gatomic୦StorePointer୦ctrie୮amainNode୮8bool୮9(addr **instantiate୦୦mainNode୦bool, val *instantiate୦୦mainNode୦bool,) {
//line ctrie_test.go2:8
  atomic.StorePointer((*unsafe.
//line ctrie_test.go2:10
  Pointer)(unsafe.Pointer(addr)), unsafe.Pointer(val))
//line ctrie_test.go2:10
}

//line ctrie_test.go2:10
type instantiate୦୦tNode୦bool struct {
//line ctrie.go2:199
 sNode *instantiate୦୦sNode୦bool
}

//line ctrie.go2:203
func (t *instantiate୦୦tNode୦bool,) untombed() *instantiate୦୦sNode୦bool {
	return &instantiate୦୦sNode୦bool{&instantiate୦୦Entry୦bool{Key: t.sNode.entry.Key, hash: t.sNode.entry.hash, Value: t.sNode.entry.Value}}
}

//line ctrie.go2:205
type instantiate୦୦lNode୦bool struct {
//line ctrie.go2:210
 head *instantiate୦୦sNode୦bool
	tail *instantiate୦୦lNode୦bool
}

//line ctrie.go2:216
func (l *instantiate୦୦lNode୦bool,) lookup(e *instantiate୦୦Entry୦bool,) (

//line ctrie_test.go2:366
 bool, bool) {
//line ctrie.go2:217
 for ; l != nil; l = l.tail {
		if bytes.Equal(e.Key, l.head.entry.Key) {
			return l.head.entry.Value, true
		}
	}
	return instantiate୦୦z୦bool(), false
}

//line ctrie.go2:226
func (l *instantiate୦୦lNode୦bool,) inserted(entry *instantiate୦୦Entry୦bool,) *instantiate୦୦lNode୦bool {
	return &instantiate୦୦lNode୦bool{
		head: &instantiate୦୦sNode୦bool{entry},
		tail: l.removed(entry),
	}
}

//line ctrie.go2:234
func (l *instantiate୦୦lNode୦bool,) removed(e *instantiate୦୦Entry୦bool,) *instantiate୦୦lNode୦bool {
	for l1 := l; l1 != nil; l1 = l1.tail {
		if bytes.Equal(e.Key, l1.head.entry.Key) {
			return l.remove(l1)
		}
	}
	return l
}

func (l *instantiate୦୦lNode୦bool,) remove(l1 *instantiate୦୦lNode୦bool,) *instantiate୦୦lNode୦bool {
	if l == l1 {
		return l.tail
	}
	return &instantiate୦୦lNode୦bool{
		head: l.head,
		tail: l.tail.remove(l1),
	}
}
//line ctrie_test.go2:4
func instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8string୮9(addr **instantiate୦୦mainNode୦string) *instantiate୦୦mainNode୦string {
//line ctrie_test.go2:4
 return (*instantiate୦୦mainNode୦string)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:6
 ))))
//line ctrie_test.go2:6
}

//line ctrie.go2:850
func instantiate୦୦gcasComplete୦string(i *instantiate୦୦iNode୦string, m *instantiate୦୦mainNode୦string, ctrie *instantiate୦୦Ctrie୦string,) *instantiate୦୦mainNode୦string {
	for {
		if m == nil {
			return nil
		}
		prev := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8string୮9(&m.prev)
		root := ctrie.rdcssReadRoot(true)
		if prev == nil {
			return m
		}

		if prev.failed != nil {

			fn := prev.failed
			if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8string୮9(&i.main, m, fn) {
				return fn
			}
			m = instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8string୮9(&i.main)
			continue
		}

		if root.gen == i.gen && !ctrie.readOnly {

			if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8string୮9(&m.prev, prev, nil) {
				return m
			}
			continue
		}
//line ctrie.go2:877
  instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8string୮9(&m.prev, prev, &instantiate୦୦mainNode୦string{failed: prev})
//line ctrie.go2:882
  m = instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8string୮9(&i.main)
		return instantiate୦୦gcasComplete୦string(i, m, ctrie)
	}
}

//line ctrie.go2:885
type instantiate୦୦iterFrame୦string struct {
//line ctrie.go2:394
 iter  func(*instantiate୦୦Iter୦string, *instantiate୦୦iterFrame୦string,) bool
			iNode *instantiate୦୦iNode୦string
			array []branch
			lNode *instantiate୦୦lNode୦string
}

//line ctrie_test.go2:10
func instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8string୮9(addr **instantiate୦୦mainNode୦string, old, new *instantiate୦୦mainNode୦string,) (swapped bool) {
	return atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:13
 )), unsafe.Pointer(old), unsafe.Pointer(new))
//line ctrie_test.go2:13
}

//line ctrie.go2:744
func instantiate୦୦toCompressed୦string(cn *instantiate୦୦cNode୦string, lev uint) *instantiate୦୦mainNode୦string {
	tmpArray := make([]branch, len(cn.array))
	for i, sub := range cn.array {
		switch sub := sub.(type) {
		case *instantiate୦୦iNode୦string:
			inode := sub
			main := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8string୮9(&inode.main)
			tmpArray[i] = instantiate୦୦resurrect୦string(inode, main)
		case *instantiate୦୦sNode୦string:
			tmpArray[i] = sub
		default:
			panic("Ctrie is in an invalid state")
		}
	}

	return instantiate୦୦toContracted୦string(&instantiate୦୦cNode୦string{bmp: cn.bmp, array: tmpArray}, lev)
}

//line ctrie.go2:766
func instantiate୦୦resurrect୦string(iNode *instantiate୦୦iNode୦string, main *instantiate୦୦mainNode୦string,) branch {
	if main.tNode != nil {
		return main.tNode.untombed()
	}
	return iNode
}
//line ctrie_test.go2:4
func instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8int୮9(addr **instantiate୦୦mainNode୦int,) *instantiate୦୦mainNode୦int {
//line ctrie_test.go2:4
 return (*instantiate୦୦mainNode୦int)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:6
 ))))
//line ctrie_test.go2:6
}

//line ctrie.go2:850
func instantiate୦୦gcasComplete୦int(i *instantiate୦୦iNode୦int, m *instantiate୦୦mainNode୦int, ctrie *instantiate୦୦Ctrie୦int,) *instantiate୦୦mainNode୦int {
	for {
		if m == nil {
			return nil
		}
		prev := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8int୮9(&m.prev)
		root := ctrie.rdcssReadRoot(true)
		if prev == nil {
			return m
		}

		if prev.failed != nil {

			fn := prev.failed
			if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8int୮9(&i.main, m, fn) {
				return fn
			}
			m = instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8int୮9(&i.main)
			continue
		}

		if root.gen == i.gen && !ctrie.readOnly {

			if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8int୮9(&m.prev, prev, nil) {
				return m
			}
			continue
		}
//line ctrie.go2:877
  instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8int୮9(&m.prev, prev, &instantiate୦୦mainNode୦int{failed: prev})
//line ctrie.go2:882
  m = instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8int୮9(&i.main)
		return instantiate୦୦gcasComplete୦int(i, m, ctrie)
	}
}

//line ctrie.go2:885
type instantiate୦୦iterFrame୦int struct {
//line ctrie.go2:394
 iter  func(*instantiate୦୦Iter୦int, *instantiate୦୦iterFrame୦int,) bool
			iNode *instantiate୦୦iNode୦int
			array []branch
			lNode *instantiate୦୦lNode୦int
}

//line ctrie_test.go2:10
func instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8int୮9(addr **instantiate୦୦mainNode୦int, old, new *instantiate୦୦mainNode୦int,) (swapped bool) {
	return atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:13
 )), unsafe.Pointer(old), unsafe.Pointer(new))
//line ctrie_test.go2:13
}

//line ctrie.go2:744
func instantiate୦୦toCompressed୦int(cn *instantiate୦୦cNode୦int, lev uint) *instantiate୦୦mainNode୦int {
	tmpArray := make([]branch, len(cn.array))
	for i, sub := range cn.array {
		switch sub := sub.(type) {
		case *instantiate୦୦iNode୦int:
			inode := sub
			main := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8int୮9(&inode.main)
			tmpArray[i] = instantiate୦୦resurrect୦int(inode, main)
		case *instantiate୦୦sNode୦int:
			tmpArray[i] = sub
		default:
			panic("Ctrie is in an invalid state")
		}
	}

	return instantiate୦୦toContracted୦int(&instantiate୦୦cNode୦int{bmp: cn.bmp, array: tmpArray}, lev)
}

//line ctrie.go2:766
func instantiate୦୦resurrect୦int(iNode *instantiate୦୦iNode୦int, main *instantiate୦୦mainNode୦int,) branch {
	if main.tNode != nil {
		return main.tNode.untombed()
	}
	return iNode
}
//line ctrie_test.go2:4
func instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8interface୮4୮5୮9(addr **instantiate୦୦mainNode୦interface୮4୮5) *instantiate୦୦mainNode୦interface୮4୮5 {
//line ctrie_test.go2:4
 return (*instantiate୦୦mainNode୦interface୮4୮5)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:6
 ))))
//line ctrie_test.go2:6
}

//line ctrie.go2:850
func instantiate୦୦gcasComplete୦interface୮4୮5(i *instantiate୦୦iNode୦interface୮4୮5, m *instantiate୦୦mainNode୦interface୮4୮5, ctrie *instantiate୦୦Ctrie୦interface୮4୮5,) *instantiate୦୦mainNode୦interface୮4୮5 {
	for {
		if m == nil {
			return nil
		}
		prev := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8interface୮4୮5୮9(&m.prev)
		root := ctrie.rdcssReadRoot(true)
		if prev == nil {
			return m
		}

		if prev.failed != nil {

			fn := prev.failed
			if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8interface୮4୮5୮9(&i.main, m, fn) {
				return fn
			}
			m = instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8interface୮4୮5୮9(&i.main)
			continue
		}

		if root.gen == i.gen && !ctrie.readOnly {

			if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8interface୮4୮5୮9(&m.prev, prev, nil) {
				return m
			}
			continue
		}
//line ctrie.go2:877
  instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8interface୮4୮5୮9(&m.prev, prev, &instantiate୦୦mainNode୦interface୮4୮5{failed: prev})
//line ctrie.go2:882
  m = instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8interface୮4୮5୮9(&i.main)
		return instantiate୦୦gcasComplete୦interface୮4୮5(i, m, ctrie)
	}
}

//line ctrie.go2:885
type instantiate୦୦iterFrame୦interface୮4୮5 struct {
//line ctrie.go2:394
 iter  func(*instantiate୦୦Iter୦interface୮4୮5, *instantiate୦୦iterFrame୦interface୮4୮5,) bool
			iNode *instantiate୦୦iNode୦interface୮4୮5
			array []branch
			lNode *instantiate୦୦lNode୦interface୮4୮5
}

//line ctrie_test.go2:10
func instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8interface୮4୮5୮9(addr **instantiate୦୦mainNode୦interface୮4୮5, old, new *instantiate୦୦mainNode୦interface୮4୮5,) (swapped bool) {
	return atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:13
 )), unsafe.Pointer(old), unsafe.Pointer(new))
//line ctrie_test.go2:13
}

//line ctrie.go2:744
func instantiate୦୦toCompressed୦interface୮4୮5(cn *instantiate୦୦cNode୦interface୮4୮5, lev uint) *instantiate୦୦mainNode୦interface୮4୮5 {
	tmpArray := make([]branch, len(cn.array))
	for i, sub := range cn.array {
		switch sub := sub.(type) {
		case *instantiate୦୦iNode୦interface୮4୮5:
			inode := sub
			main := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8interface୮4୮5୮9(&inode.main)
			tmpArray[i] = instantiate୦୦resurrect୦interface୮4୮5(inode, main)
		case *instantiate୦୦sNode୦interface୮4୮5:
			tmpArray[i] = sub
		default:
			panic("Ctrie is in an invalid state")
		}
	}

	return instantiate୦୦toContracted୦interface୮4୮5(&instantiate୦୦cNode୦interface୮4୮5{bmp: cn.bmp, array: tmpArray}, lev)
}

//line ctrie.go2:766
func instantiate୦୦resurrect୦interface୮4୮5(iNode *instantiate୦୦iNode୦interface୮4୮5, main *instantiate୦୦mainNode୦interface୮4୮5,) branch {
	if main.tNode != nil {
		return main.tNode.untombed()
	}
	return iNode
}
//line ctrie_test.go2:4
func instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8bool୮9(addr **instantiate୦୦mainNode୦bool,) *instantiate୦୦mainNode୦bool {
//line ctrie_test.go2:4
 return (*instantiate୦୦mainNode୦bool)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:6
 ))))
//line ctrie_test.go2:6
}

//line ctrie.go2:850
func instantiate୦୦gcasComplete୦bool(i *instantiate୦୦iNode୦bool, m *instantiate୦୦mainNode୦bool, ctrie *instantiate୦୦Ctrie୦bool,) *instantiate୦୦mainNode୦bool {
	for {
		if m == nil {
			return nil
		}
		prev := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8bool୮9(&m.prev)
		root := ctrie.rdcssReadRoot(true)
		if prev == nil {
			return m
		}

		if prev.failed != nil {

			fn := prev.failed
			if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8bool୮9(&i.main, m, fn) {
				return fn
			}
			m = instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8bool୮9(&i.main)
			continue
		}

		if root.gen == i.gen && !ctrie.readOnly {

			if instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8bool୮9(&m.prev, prev, nil) {
				return m
			}
			continue
		}
//line ctrie.go2:877
  instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8bool୮9(&m.prev, prev, &instantiate୦୦mainNode୦bool{failed: prev})
//line ctrie.go2:882
  m = instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8bool୮9(&i.main)
		return instantiate୦୦gcasComplete୦bool(i, m, ctrie)
	}
}

//line ctrie.go2:885
type instantiate୦୦iterFrame୦bool struct {
//line ctrie.go2:394
 iter  func(*instantiate୦୦Iter୦bool, *instantiate୦୦iterFrame୦bool,) bool
			iNode *instantiate୦୦iNode୦bool
			array []branch
			lNode *instantiate୦୦lNode୦bool
}

//line ctrie_test.go2:10
func instantiate୦gatomic୦CompareAndSwapPointer୦ctrie୮amainNode୮8bool୮9(addr **instantiate୦୦mainNode୦bool, old, new *instantiate୦୦mainNode୦bool,) (swapped bool) {
	return atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(addr,
//line ctrie_test.go2:13
 )), unsafe.Pointer(old), unsafe.Pointer(new))
//line ctrie_test.go2:13
}

//line ctrie.go2:744
func instantiate୦୦toCompressed୦bool(cn *instantiate୦୦cNode୦bool, lev uint) *instantiate୦୦mainNode୦bool {
	tmpArray := make([]branch, len(cn.array))
	for i, sub := range cn.array {
		switch sub := sub.(type) {
		case *instantiate୦୦iNode୦bool:
			inode := sub
			main := instantiate୦gatomic୦LoadPointer୦ctrie୮amainNode୮8bool୮9(&inode.main)
			tmpArray[i] = instantiate୦୦resurrect୦bool(inode, main)
		case *instantiate୦୦sNode୦bool:
			tmpArray[i] = sub
		default:
			panic("Ctrie is in an invalid state")
		}
	}

	return instantiate୦୦toContracted୦bool(&instantiate୦୦cNode୦bool{bmp: cn.bmp, array: tmpArray}, lev)
}

//line ctrie.go2:766
func instantiate୦୦resurrect୦bool(iNode *instantiate୦୦iNode୦bool, main *instantiate୦୦mainNode୦bool,) branch {
	if main.tNode != nil {
		return main.tNode.untombed()
	}
	return iNode
}

//line ctrie.go2:771
type _ bytes.Buffer

//line ctrie.go2:771
var _ = errors.As

//line ctrie.go2:771
type _ gatomic.Importable୦
//line ctrie.go2:771
type _ hash.Hash

//line ctrie.go2:771
var _ = fnv.New128
//line ctrie.go2:771
var _ = strconv.AppendBool

//line ctrie.go2:771
type _ sync.Cond

//line ctrie.go2:771
var _ = atomic.AddInt32
//line ctrie.go2:771
var _ = testing.AllocsPerRun

//line ctrie.go2:771
const _ = time.ANSIC

//line ctrie.go2:771
type _ unsafe.Pointer
